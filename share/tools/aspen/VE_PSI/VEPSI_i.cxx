// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// .\be\be_codegen.cpp:1063

#include "stdafx.h"
#include "VEPSI_i.h"
#include "VE_PSI.h"
#include <ves/open/xml/model/Network.h>
#include <ves/open/xml/model/Link.h>
#include <ves/open/xml/model/Model.h>
#include <ves/open/xml/DataValuePair.h>
#include <ves/open/xml/XMLReaderWriter.h>
#include <ves/open/xml/Command.h>
#include <ves/open/xml/model/Point.h>
#include <ves/open/xml/model/Port.h>
#include <ves/open/xml/XMLObjectFactory.h>
#include <ves/open/xml/XMLCreator.h>
#include <ves/open/xml/shader/ShaderCreator.h>
#include <ves/open/xml/model/ModelCreator.h>
#include <ves/open/xml/cad/CADCreator.h>
#include <ves/open/xml/DOMDocumentManager.h>
#include <fstream>
#include <iostream>

#include <vpr/vpr.h>
#include <vpr/System.h>
#include <boost/bind.hpp>

#include <ves/open/xml/XMLObject.h>
#include <xercesc/sax/HandlerBase.hpp>
#include <xercesc/dom/DOM.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/parsers/XercesDOMParser.hpp>
#include <ves/open/xml/util/Convert.h>

// Implementation skeleton constructor
VEPSI_i::VEPSI_i( std::string name, VE_PSIDlg * dialog, 
                         CorbaUnitManager* parent, std::string dir )
    :
    UnitWrapper( parent->GetExecutive(), name ),
    AspenLog( 0 ),
    theParent( parent ),
    theDialog( dialog ),
    return_state( 0 ),
    cur_id_( 0 ),
    UnitName_( name ),
    mWorkingDir( dir ),
    dyn(NULL),
    bkp(NULL),
    dynSim(NULL),
    mQuerying(false)
{
    AspenLog = reinterpret_cast<CEdit *>(theDialog->GetDlgItem(IDC_EDIT1));

    mQueryCommandNames.insert( "getNetwork");
    mQueryCommandNames.insert( "openSimulation");
    mQueryCommandNames.insert( "runNetwork");
    mQueryCommandNames.insert( "reinitNetwork");
    mQueryCommandNames.insert( "reinitBlock");
    mQueryCommandNames.insert( "stepNetwork");
    mQueryCommandNames.insert( "showSimulation");
    mQueryCommandNames.insert( "hideSimulation");
    mQueryCommandNames.insert( "closeSimulation");
    mQueryCommandNames.insert( "saveSimulation");
    mQueryCommandNames.insert( "saveAsSimulation");
    mQueryCommandNames.insert( "getModuleParamList");
    mQueryCommandNames.insert( "getInputModuleParamList");
    mQueryCommandNames.insert( "getInputModuleProperties");
    mQueryCommandNames.insert( "getOutputModuleParamList");
    mQueryCommandNames.insert( "getOutputModuleProperties");
    mQueryCommandNames.insert( "getStreamModuleParamList");
    mQueryCommandNames.insert( "getStreamInputModuleParamList");
    mQueryCommandNames.insert( "getStreamInputModuleProperties");
    mQueryCommandNames.insert( "getStreamOutputModuleParamList");
    mQueryCommandNames.insert( "getStreamOutputModuleProperties");
    mQueryCommandNames.insert( "setParam");
    mQueryCommandNames.insert( "setLinkParam");
    mQueryCommandNames.insert( "addVariable");

    //DynSim and OPC
    mQueryCommandNames.insert( "getOPCValue");
    mQueryCommandNames.insert( "getOPCValues");
    mQueryCommandNames.insert( "setOPCValues");
    mQueryCommandNames.insert( "connectToOPC");
    mQueryCommandNames.insert( "getAllOPCVariables");

    //DWSIM
    mQueryCommandNames.insert( "readInputs");
    mQueryCommandNames.insert( "readOutputs");
    mQueryCommandNames.insert( "readInputFileOutputs");
    mQueryCommandNames.insert( "setInputs");
    mQueryCommandNames.insert( "setOutputPort");
    mQueryCommandNames.insert( "setInputPort");

    dynFlag = false;
    bkpFlag = false;
    dwFlag = false;
}
////////////////////////////////////////////////////////////////////////////////
// Implementation skeleton destructor
VEPSI_i::~VEPSI_i( void )
{
    if( bkpFlag )
    {
        delete bkp;
    }
    
    if( dynFlag )
    {
        delete dyn;
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::ShowAspen()
{
    if( bkpFlag )
    {
        bkp->showAspen( true );
    }
    
    if( dynFlag )
    {
        dyn->SetVisibility( true );
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::HideAspen()
{
    if( bkpFlag )
    {
        bkp->showAspen(false);
    }
    
    if( dynFlag )
    {
        dyn->SetVisibility(false);
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::CloseAspen()
{
    if( bkpFlag )
    {
        bkp->closeFile();
    }
    
    if( dynFlag )
    {
        dyn->CloseFile();
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::SaveAspen( std::string filename)
{
    if( bkpFlag )
    {
        bkp->saveAs(( mWorkingDir + filename + ".apw" ).c_str());
        bkp->saveAs(( mWorkingDir + filename + ".bkp" ).c_str());
    }
    
    if( dynFlag )
    {
        dyn->SaveAs(( mWorkingDir + filename + ".dynf" ).c_str());
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::StepSim()
{
    if( bkpFlag )
    {
        bkp->step();
    }
    
    if( dynFlag )
    {
        //dyn->Step();
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::ReinitializeAspen()
{
    try
    {
        if( bkpFlag )
        {
            bkp->ReinitAspen();
        }
        
        if( dynFlag )
        {
            dyn->ReinitDynamics();
        }
    }
    catch(...)
    {
        AspenLog->SetSel(-1, -1);
        AspenLog->ReplaceSel("Reinitialize Failed.\r\n");
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::StartCalc (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    if( bkpFlag )
    {
        bkp->aspendoc->runSolver( false );
    }
    else if( dynFlag )
    {
        dyn->dyndoc->RunSolver( );
    }
    else if( dwFlag )
    {
        std::string inFile = mWorkingDir + mFileName + ".input.xml";
        std::string outFile = mWorkingDir + mFileName + ".output.xml";

        std::ostringstream strm;
        strm << activeId;

        //check for inputs
        //const std::vector< ves::open::xml::CommandPtr > inputsVec = xmlModelMap[ strm.str() ]->GetInputs();
        //if (inputsVec.size() != 0)
        if( !mPortInput.first.empty() )
        {
            //grab the value from one output variable
            std::string value;
            ves::open::xml::CommandPtr tempCmd =
                boost::dynamic_pointer_cast<ves::open::xml::Command>
                ( xmlModelMap[ strm.str() ]->GetInput( "Upstream Model Results" )->
                    GetDataValuePair( "DWSim Output" )->GetDataXMLObject() );
            tempCmd->GetDataValuePair( 0 )->GetData( value );

            //write to xml file
            ves::open::xml::DOMDocumentManager* mDomDocManager = new ves::open::xml::DOMDocumentManager();
            mDomDocManager->SetParseXMLFileOn();
            mDomDocManager->Load( inFile );

            ///get input parameter entry
            XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* mCommandDocument = mDomDocManager->GetCommandDocument();
            DOMElement* root_elem = mCommandDocument->getDocumentElement();
            DOMNodeList* inputList = 
                root_elem->getElementsByTagName (
                XMLString::transcode("InputParameters")
                );
            DOMNode* node = inputList->item( 0 );
            DOMElement* input_element = dynamic_cast< DOMElement* > ( node );
            
            ves::open::xml::DataValuePairPtr
                dvp( new ves::open::xml::DataValuePair() );

            //get object entries
            DOMNodeList*objList = 
                input_element->getElementsByTagName (
                XMLString::transcode("Object")
                );

            int objCount = objList->getLength();
            for( int i = 0; i < objCount; i++)
            {
                //get object name
                DOMNode* objNode = objList->item( i );
                DOMElement* element =
                    dynamic_cast<DOMElement*> ( objNode );
                std::string objName;
                dvp->GetAttribute( element, "Name", objName );

                //loop over names name
                if( objName.compare(mPortInput.first) == 0 )
                {
                    //get properties
                    DOMElement* obj_element = dynamic_cast< DOMElement* > ( objNode );
                    DOMNodeList* propList = 
                        obj_element->getElementsByTagName (
                        XMLString::transcode("Property")
                        );
                    int propCount = propList->getLength();

                    //loop over properties and change those requested
                    for( int j = 0; j < propCount; j++)
                    {
                        DOMNode* propNode = propList->item( j );
                        DOMElement* prop_element =
                            dynamic_cast<DOMElement*> ( propNode );

                        //prop id
                        std::string id;
                        dvp->GetAttribute( prop_element, "ID", id );
                        
                        if( id.compare(mPortInput.second.first)==0)
                        {                   
                            //set input
                            dvp->SetAttribute( "Value", value, prop_element );
                            
                            //save inputs file
                            mDomDocManager->SetOuputXMLFile( inFile );
                            mDomDocManager->SetWriteXMLFileOn();
                            mDomDocManager->WriteAndReleaseRootElement();
                            break;
                        }
                    }
                }
            }
        }

        //create the sys call
        std::string dwExe = "C:\\Program Files (x86)\\DWSIM\\DWSIM.EXE";
        std::string dwFile = "\"" + mWorkingDir + mFileName + ".dwsim\"";
        std::string outFileSys = "\"" + outFile + "\"";
        std::string inFileSys = "\"" + inFile + "\"";
          
        std::string syscall = "\"" + dwExe + "\"" + " -commandline " +
            " -nosplash " + " -show 1 " + " -locale \"en-US\" " +
            " -simfile " + dwFile + " -input " + inFile + " -output " + outFile;

        LPSTR cmd = strdup( syscall.c_str() );
        LPSTR exe = strdup( dwExe.c_str() );

        //execute the dwsim from the command line  
        BOOL bRet ;
        STARTUPINFO sui ;
        PROCESS_INFORMATION pi ;
        sui.cb = sizeof (STARTUPINFO);
        GetStartupInfo (&sui);
        sui.dwFlags = STARTF_USESHOWWINDOW ;
        sui.wShowWindow = SW_SHOW ;
        bRet = CreateProcess( exe, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &sui, &pi );
        WaitForSingleObject(pi.hProcess, INFINITE);

        if( !mPortOutput.first.empty() )
        {
            std::string value;
            //read the results xml file
            //grab the results you want
            ves::open::xml::DOMDocumentManager* mDomDocManager = new ves::open::xml::DOMDocumentManager();
            mDomDocManager->SetParseXMLFileOn();
            mDomDocManager->Load( outFile );

            ///get input parameter entry
            XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* mCommandDocument = mDomDocManager->GetCommandDocument();
            DOMElement* root_elem = mCommandDocument->getDocumentElement();
            DOMNodeList* inputList = 
                root_elem->getElementsByTagName (
                XMLString::transcode("OutputParameters")
                );
            DOMNode* node = inputList->item( 0 );
            DOMElement* input_element = dynamic_cast< DOMElement* > ( node );
            
            ves::open::xml::DataValuePairPtr
                dvp( new ves::open::xml::DataValuePair() );

            //get object entries
            DOMNodeList*objList = 
                input_element->getElementsByTagName (
                XMLString::transcode("Object")
                );

            int objCount = objList->getLength();
            for( int i = 0; i < objCount; i++)
            {
                //get object name
                DOMNode* objNode = objList->item( i );
                DOMElement* element =
                    dynamic_cast<DOMElement*> ( objNode );
                std::string objName;
                dvp->GetAttribute( element, "Name", objName );

                //loop over names name
                if( objName.compare(mPortOutput.first) == 0 )
                {
                    //get properties
                    DOMElement* obj_element = dynamic_cast< DOMElement* > ( objNode );
                    DOMNodeList* propList = 
                        obj_element->getElementsByTagName (
                        XMLString::transcode("Property")
                        );
                    int propCount = propList->getLength();

                    //loop over properties and change those requested
                    for( int j = 0; j < propCount; j++)
                    {
                        DOMNode* propNode = propList->item( j );
                        DOMElement* prop_element =
                            dynamic_cast<DOMElement*> ( propNode );

                        //prop id
                        std::string id;
                        dvp->GetAttribute( prop_element, "ID", id );
                        
                        if( id.compare(mPortOutput.second.first) == 0 )
                        {                   
                            //set input
                            //dvp->SetAttribute( "Value", value, prop_element );
                            dvp->GetAttribute( prop_element, "Value", value);
                            
                            //save inputs file
                            //mDomDocManager->SetOuputXMLFile( inFile );
                            //mDomDocManager->SetWriteXMLFileOn();
                            //mDomDocManager->WriteAndReleaseCommandDocumentRoot();
                            break;
                        }
                    }
                }
            }

            //write them as dvps to the command to the currentmodel
            ves::open::xml::CommandPtr command( new ves::open::xml::Command() );
            command->SetCommandName( "DWSim Output" );
            ves::open::xml::DataValuePairPtr outputDVP( new ves::open::xml::DataValuePair() );
            outputDVP->SetData( mPortOutput.first, value );
            command->AddDataValuePair( outputDVP );
            xmlModelMap[ strm.str() ]->SetResult( command );      
        }
    }
    AspenLog->SetSel( -1, -1 );
    AspenLog->ReplaceSel( "Simulation Complete\r\n" );
    return_state=0;
}
////////////////////////////////////////////////////////////////////////////////
char * VEPSI_i::Query ( const char * query_str
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    std::string tempResult = UnitWrapper::Query( query_str );
    if(tempResult != "NULL" )
    {
        return CORBA::string_dup( tempResult.c_str() );
    }
    else
    {
        mQuerying = true;
        AspenLog->SetSel( -1, -1 );
        AspenLog->ReplaceSel( "Query\r\n" );
        _mutex.acquire();
        ves::open::xml::XMLReaderWriter networkWriter;
        networkWriter.UseStandaloneDOMDocumentManager();
        networkWriter.ReadFromString();
        networkWriter.ReadXMLData( query_str, "Command", "vecommand" );

        std::vector< ves::open::xml::XMLObjectPtr > objectVector =
            networkWriter.GetLoadedXMLObjects();

        ves::open::xml::CommandPtr cmd;    
        std::string cmdname;
        
        cmd = boost::dynamic_pointer_cast<ves::open::xml::Command>
            ( objectVector.at( 0 ) );
        cmdname = cmd->GetCommandName();
        
        std::set< std::string >::const_iterator commandItr
            = mQueryCommandNames.find( cmdname );
        
        //If the command is not processed here - do not bother doing anything more
        if( commandItr == mQueryCommandNames.end() )
        {
            _mutex.release();
            mQuerying = false;
            return CORBA::string_dup("NULL");
        }
        
        AspenLog->SetSel( -1, -1 );
        AspenLog->ReplaceSel( ("Command: "+cmdname+"\r\n").c_str() );
        char* returnValue = "empty";

        if ( cmdname == "getNetwork" )
        {
            returnValue = handleGetNetwork( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if( cmdname == "openSimulation" )
        {
            returnValue = handleOpenSimulation( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "runNetwork" )
        {
            StartCalc();
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "networkRun" );
        }
        else if ( cmdname == "stepNetwork" )
        {
            StepSim();
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "networkRun" );
        }
        else if ( cmdname == "showSimulation" )
        {
            ShowAspen();
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Simulation Shown." );
        }
        else if ( cmdname == "hideSimulation" )
        {
            HideAspen();
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Simulation hidden." );
        }
        else if ( cmdname == "closeSimulation" )
        {
            AspenLog->SetSel( -1, -1 );
            AspenLog->ReplaceSel( "closing...\r\n" );
            CloseAspen();
            AspenLog->SetSel( -1, -1 );
            AspenLog->ReplaceSel( "closed.\r\n" );
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Simulation closed." );
        }
        else if ( cmdname == "saveSimulation" )
        {
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel( "saving...\r\n" );
            try
            {
                SaveAspen( mFileName );
                AspenLog->SetSel( -1, -1 );
                AspenLog->ReplaceSel( "saved.\r\n" );
            }
            catch(...)
            {
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel( "messed up save.\r\n" );
                mQuerying = false;
                _mutex.release();
            }
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Simulation Saved." );
        }
        else if ( cmdname == "saveAsSimulation" )
        {
            returnValue = handleSaveAs( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if( cmdname == "reinitNetwork" )
        {
            ReinitializeAspen();
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Simulation reinitialized." );
        }
        else if( cmdname == "reinitBlock" )
        {
            ReinitializeBlock( cmd );
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Block reinitialized." );
        }

        //Blocks
        else if ( cmdname == "getModuleParamList" )
        {
            //executive_->SetModuleMessage(cur_id_,"Querying inputs...\n");
            returnValue = handleGetModuleParamList( cmd );
            //executive_->SetModuleMessage(cur_id_,"Querying completed.\n");
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getInputModuleParamList" )
        {
            //executive_->SetModuleMessage(cur_id_,"Querying inputs...\n");
            returnValue = handleGetInputModuleParamList( cmd );
            //executive_->SetModuleMessage(cur_id_,"Querying completed.\n");
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getInputModuleProperties" )
        {
            returnValue = handleGetInputModuleProperties( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getOutputModuleParamList" )
        {
            //executive_->SetModuleMessage(cur_id_,"Querying outputs...\n");
            returnValue = handleGetOutputModuleParamList( cmd );
            //executive_->SetModuleMessage(cur_id_,"Querying completed.\n");
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getOutputModuleProperties" )
        {
            returnValue = handleGetOutputModuleProperties( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }

        //Streams
        else if ( cmdname == "getStreamModuleParamList" )
        {
            //executive_->SetModuleMessage(cur_id_,"Querying inputs...\n");
            returnValue = handleGetStreamModuleParamList( cmd );
            //executive_->SetModuleMessage(cur_id_,"Querying completed.\n");
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getStreamInputModuleParamList" )
        {
            //executive_->SetModuleMessage(cur_id_,"Querying link inputs...\n");
            returnValue = handleGetStreamInputModuleParamList( cmd );
            //executive_->SetModuleMessage(cur_id_,"Querying link completed.\n");
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getStreamInputModuleProperties" )
        {
            returnValue = handleGetStreamInputModuleProperties( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getStreamOutputModuleParamList" )
        {
            //executive_->SetModuleMessage(cur_id_,"Querying link outputs...\n");
            returnValue = handleGetStreamOutputModuleParamList( cmd );
            //executive_->SetModuleMessage(cur_id_,"Querying link completed.\n");
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }
        else if ( cmdname == "getStreamOutputModuleProperties" )
        {
            returnValue = handleGetStreamOutputModuleProperties( cmd );
            mQuerying = false;
            _mutex.release();
            return returnValue;
        }

        //Params
        else if ( cmdname == "setParam" )
        {
            SetParam( cmd );
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Param Set" );
        }
        else if ( cmdname == "setLinkParam" )
        {
            SetLinkParam( cmd );
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "Param Set" );
        }
        else if ( cmdname == "addVariable" )
        {
            addVariable( cmd );
            mQuerying = false;
            _mutex.release();
            return( "NULL" );
        }

        //DynSim
        else if ( cmdname == "getOPCValues" )
        {
            returnValue = getOPCValues( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }
        else if ( cmdname == "setOPCValues" )
        {
            returnValue = setOPCValues( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }
        else if ( cmdname == "connectToOPC" )
        {
            connectToOPC( cmd );
            _mutex.release();
            mQuerying = false;
            return( "NULL" );
        }
        else if ( cmdname == "addVariable" )
        {
            addVariable( cmd );
            _mutex.release();
            mQuerying = false;
            return( "NULL" );
        }
        else if ( cmdname == "getAllOPCVariables" )
        {
            returnValue = getAllOPCVariables( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }

        //DWSIM
        else if ( cmdname == "readInputs" )
        {
            returnValue = readInputFile( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }
        else if ( cmdname == "readOutputs" )
        {
            returnValue = readOutputFile( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }
        else if ( cmdname == "readInputFileOutputs" )
        {
            returnValue = readInputFileOutputs( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }
        else if ( cmdname == "setInputs" )
        {
            returnValue = setInputs( cmd );
            _mutex.release();
            mQuerying = false;
            return returnValue;
        }
        else if ( cmdname == "setInputPort" )
        {
            setInputPort( cmd );
            _mutex.release();
            mQuerying = false;
            return( "NULL" );
        }
        else if ( cmdname == "setOutputPort" )
        {
            setOutputPort( cmd );
            _mutex.release();
            mQuerying = false;
            return( "NULL" );
        }

        else
        {
            mQuerying = false;
            _mutex.release();
            return CORBA::string_dup( "NULL" );
        }
    }
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetNetwork(ves::open::xml::CommandPtr cmd)
{
    CEdit *Display;
    Display = reinterpret_cast<CEdit *>(theDialog->GetDlgItem(IDC_EDIT2));

    //this command has no params
    bool firsttime=true;

    std::string filename = cmd->GetDataValuePair(1)->GetDataString();

    std::string extension = filename.substr( filename.size() - 4, 4 );
 
    if( extension.find( "bkp" ) != std::string::npos )
    {
        bkpFlag = true;
        dynFlag = false;
        dynSimFlag = false;
        filename.resize( filename.size() - 4 );
        bkp = new AspenPlus( mWorkingDir, UnitName_ );
    }
    else if( extension.find( "dynf" ) != std::string::npos )
    {
        bkpFlag = false;
        dynFlag = true;
        dynSimFlag = false;
        filename.resize( filename.size() - 5 );
        dyn = new AspenDynamics( mWorkingDir, UnitName_ );
    }
    else if( extension.find( "xml" ) != std::string::npos )
    {
        bkpFlag = false;
        dynFlag = false;
        dynSimFlag = true;
        filename.resize( filename.size() - 4 );
        dynSim = new DynSim( UnitName_ );
    }
    
    if( bkpFlag )
    {
        if (firsttime)
        {
            //make sure bkp file exists
            std::ifstream bkpFile( ( mWorkingDir + filename + ".bkp" ).c_str(),
                std::ios::binary);
            if( !bkpFile.is_open() )
            {
                //no bkp file
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel("BKP File Does NOT exist.\r\n");
                return CORBA::string_dup( "BKPDNE" );
            }
            bkpFile.close();

            //make sure apw file exists
            std::ifstream apwFile( ( mWorkingDir + filename + ".apw" ).c_str(),
                std::ios::binary);
            if( !apwFile.is_open() )
            {
                //no apw file
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel("APW File Does NOT exist.\r\n");
                return CORBA::string_dup( "APWDNE" );
            }
            apwFile.close();

            //Display->SetWindowText( ( mWorkingDir + filename ).c_str());
            Display->SetWindowText( ( filename ).c_str());
            //go through bkp parsing procedure
            bkp->OpenSimAndParse( filename.c_str() );
            mFileName = filename;
            firsttime=false;
        }
           
        //Display->SetWindowText(filename.c_str());

        std::string network;
        try
        {
            network = bkp->CreateNetwork( );
        }
        catch(...)
        {
            std::cout << "GetNetwork Exception Aspen Unit" << std::endl;
            return NULL;
        }

        return CORBA::string_dup( network.c_str() );
    }
    
    if( dynFlag )
    {
        if (firsttime)
        {
            //make sure bkp file exists
            std::ifstream dynFile( ( mWorkingDir + filename + ".dynf" ).c_str(),
                std::ios::binary);
            if( !dynFile.is_open() )
            {
                //no dyn file
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel("Dynf File Does NOT exist.\r\n");
                return CORBA::string_dup( "DYNDNE" );
            }
            dynFile.close();

            //Display->SetWindowText( ( mWorkingDir + filename ).c_str());
            Display->SetWindowText( ( filename ).c_str());
            //go through dyn parsing procedure
            dyn->OpenFile( filename.c_str() );
            m_thread = new vpr::Thread( boost::bind( &VEPSI_i::Monitor, this ) );
            //dyn->ParseFile((mWorkingDir + filename + ".dynf" ).c_str());
            //Monitor(  );
            mFileName = filename;
            firsttime=false;
        }
           
        //Display->SetWindowText(filename.c_str());

        std::string network;
        try
        {
            network = dyn->CreateNetwork();
        }
        catch(...)
        {
            std::cout << "GetNetwork Exception Dynamics Unit" << std::endl;
            return NULL;
        }
        return CORBA::string_dup(network.c_str());
    }

    if( dynSimFlag )
    {
        std::string network;
        if (firsttime)
        {
            //make sure bkp file exists
            std::ifstream xmlFile( ( mWorkingDir + filename + ".xml" ).c_str(),
                std::ios::binary);
            if( !xmlFile.is_open() )
            {
                //no bkp file
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel("XML File Does NOT exist.\r\n");
                return CORBA::string_dup( "XMLDNE" );
            }
            xmlFile.close();

            //make sure apw file exists
            std::ifstream s4mFile( ( mWorkingDir + filename + ".s4m" ).c_str(),
                std::ios::binary);
            if( !s4mFile.is_open() )
            {
                //no apw file
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel("S4M File Does NOT exist.\r\n");
                return CORBA::string_dup( "S4MDNE" );
            }
            s4mFile.close();

            Display->SetWindowText( ( filename ).c_str());
            //go through bkp parsing procedure
            const std::string fullFilename = mWorkingDir + filename;
            network = dynSim->CreateNetwork( fullFilename );

            mFileName = filename;
            firsttime=false;
        }
        return CORBA::string_dup( network.c_str() );
    }

    return NULL;
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleOpenSimulation(ves::open::xml::CommandPtr cmd)
{
    CEdit *Display;
    Display = reinterpret_cast<CEdit *>(theDialog->GetDlgItem(IDC_EDIT2));

    //this command has no params
    std::string filename = cmd->GetDataValuePair(1)->GetDataString();

    std::string extension = filename.substr( filename.size() - 5, 5 );
 
    if( extension.find( "bkp" ) != std::string::npos )
    {
        filename.resize( filename.size() - 4 );
        //make sure bkp file exists
        std::ifstream bkpFile( ( mWorkingDir + filename + ".bkp" ).c_str(),
            std::ios::binary);
        if( !bkpFile.is_open() )
        {
            //no bkp file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("BKP File Does NOT exist.\r\n");
            return CORBA::string_dup( "BKPDNE" );
        }
        bkpFile.close();

        //make sure apw file exists
        std::ifstream apwFile( ( mWorkingDir + filename + ".apw" ).c_str(),
            std::ios::binary);
        if( !apwFile.is_open() )
        {
            //no apw file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("APW File Does NOT exist.\r\n");
            return CORBA::string_dup( "APWDNE" );
        }
        apwFile.close();

        bkpFlag = true;
        dynFlag = false;
        dwFlag = false;
        Display->SetWindowText(filename.c_str());
        bkp = new AspenPlus( mWorkingDir, UnitName_ );
        bkp->OpenSim(filename.c_str());
    }
    else if( extension.find( "dynf" ) != std::string::npos )
    {   
        filename.resize( filename.size() - 5 );
        //make sure dynf file exists
        std::ifstream dynFile( ( mWorkingDir + filename + ".dynf" ).c_str(),
            std::ios::binary);
        if( !dynFile.is_open() )
        {
            //no dyn file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("Dynf File Does NOT exist.\r\n");
            return CORBA::string_dup( "DYNDNE" );
        }
        dynFile.close();
        
        bkpFlag = false;
        dynFlag = true;
        dwFlag = false;
        Display->SetWindowText(filename.c_str());
        dyn = new AspenDynamics( mWorkingDir, UnitName_ );
        dyn->OpenFile(filename.c_str());
    }
    else if( extension.find( "dwsim" ) != std::string::npos )
    {   
        filename.resize( filename.size() - 6 );
        
        //make sure dynf file exists
        std::ifstream dwFile( ( mWorkingDir + filename + ".dwsim" ).c_str(),
            std::ios::binary);
        if( !dwFile.is_open() )
        {
            //no dyn file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("DWSIM File Does NOT exist.\r\n");
            return CORBA::string_dup( "DWDNE" );
        }
        dwFile.close();
        
        //check for input and output xml files
        std::ifstream inFile( ( mWorkingDir + filename + ".input.xml" ).c_str(),
            std::ios::binary);
        if( !inFile.is_open() )
        {
            //no dyn file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("Input File Does NOT exist.\r\n");
            return CORBA::string_dup( "DWInDNE" );
        }
        inFile.close();

        std::ifstream outFile( ( mWorkingDir + filename + ".output.xml" ).c_str(),
            std::ios::binary);
        if( !outFile.is_open() )
        {
            //no dyn file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("Output File Does NOT exist.\r\n");
            return CORBA::string_dup( "DWOutDNE" );
        }
        outFile.close();

        bkpFlag = false;
        dynFlag = false;
        dwFlag = true;
        Display->SetWindowText(filename.c_str());
        mFileName = filename;
        //dyn = new AspenDynamics();
        //dyn->SetWorkingDir( mWorkingDir );
        //dyn->OpenFile(filename.c_str());
    }
    return CORBA::string_dup("Simulation Opened.");
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleSaveAs(ves::open::xml::CommandPtr cmd)
{
    AspenLog->SetSel(-1, -1);
    AspenLog->ReplaceSel("saving...\r\n");
    std::string filename = cmd->GetDataValuePair(1)->GetDataString();
    mFileName = filename;
    SaveAspen( mFileName );
    AspenLog->SetSel(-1, -1);
    AspenLog->ReplaceSel("saved.\r\n");
    return CORBA::string_dup("Simulation Saved.");
}
////////////////////////////////////////////////////////////////////////////////
//no reinitialize of block in dynamics
void VEPSI_i::ReinitializeBlock(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
            modname=curPair->GetDataString();
        else if (curPair->GetDataName()=="ModuleId")
            curPair->GetData(modId);
    }
    bkp->ReinitBlock(modname);
}

////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetModuleParamList(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
            modname=curPair->GetDataString();
        else if (curPair->GetDataName()=="ModuleId")
            curPair->GetData(modId);
    }

    //There shouldn't be two intances of an Dynamics framework. so discard the 
    //moduleId
    //the returned string will be a well formated XML within "vecommand" element
    std::string netPak = dyn->GetModuleParams( modname, true );

    return CORBA::string_dup(netPak.c_str());
}

////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetInputModuleParamList(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
            modname=curPair->GetDataString();
        else if (curPair->GetDataName()=="ModuleId")
            curPair->GetData(modId);
    }

    //There shouldn't be two intances of an Aspen framework. so discard the moduleId
    //the returned string will be a well formated XML within "vecommand" element
    std::string netPak = bkp->GetInputModuleParams(modname);

    //std::ofstream output("inputList.txt");
    //output<<netPak;
    //output.close();  

    return CORBA::string_dup(netPak.c_str());
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetInputModuleProperties(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname,paramName;
    unsigned int modId;

    for ( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        if (curPair->GetDataName()=="ModuleName")
            modname=curPair->GetDataString();
        else if (curPair->GetDataName()=="moduleId")
            curPair->GetData(modId); //modId is discarded because of the same reason as before
        else if (curPair->GetDataName()=="ParamName")
            paramName=curPair->GetDataString();
    }
    std::string netPak = bkp->GetInputModuleParamProperties(modname, paramName);
    return CORBA::string_dup(netPak.c_str());

}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetOutputModuleParamList(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
            modname=curPair->GetDataString();
        else if (curPair->GetDataName()=="ModuleId")
            curPair->GetData(modId);
    }

    //There shouldn't be two intances of an Aspen framework. so discard the
    //moduleId
    //the returned string will be a well formated XML within "vecommand" element
    std::string netPak = bkp->GetOutputModuleParams(modname);
    return CORBA::string_dup(netPak.c_str());
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetOutputModuleProperties(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname,paramName;
    unsigned int modId;

    for ( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        if (curPair->GetDataName()=="ModuleName")
        {
            modname=curPair->GetDataString();
        }
        else if (curPair->GetDataName()=="moduleId")
        {
            //modId is discarded because of the same reason as before
            curPair->GetData(modId); 
        }
        else if (curPair->GetDataName()=="ParamName")
        {
        paramName=curPair->GetDataString();
        }
    }
    std::string netPak = bkp->GetOutputModuleParamProperties(modname, paramName);
    return CORBA::string_dup(netPak.c_str());

}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetStreamModuleParamList(ves::open::xml::CommandPtr cmd)
{    
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
        {
            modname=curPair->GetDataString();
        }
        else if (curPair->GetDataName()=="ModuleId")
        {
            curPair->GetData(modId);
        }
    }

    //There shouldn't be two intances of an Dynamics framework. so discard the 
    //moduleId
    //the returned string will be a well formated XML within "vecommand" element
    std::string netPak = dyn->GetModuleParams( modname, false );

    return CORBA::string_dup(netPak.c_str());
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetStreamInputModuleParamList(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for ( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
        {
            modname=curPair->GetDataString();
        }
        else if (curPair->GetDataName()=="ModuleId")
        {
            curPair->GetData(modId);
        }
    }

    //There shouldn't be two intances of an Aspen framework. so discard the moduleId
    //the returned string will be a well formated XML within "vecommand" element
    std::string netPak = bkp->GetStreamInputModuleParams(modname);
    return CORBA::string_dup(netPak.c_str());
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetStreamInputModuleProperties(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname,paramName;
    unsigned int modId;

    for ( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        if (curPair->GetDataName()=="ModuleName")
        {
            modname=curPair->GetDataString();
        }
        else if (curPair->GetDataName()=="moduleId")
        {
            curPair->GetData(modId); //modId is discarded because of the same reason as before
        }
        else if (curPair->GetDataName()=="ParamName")
        {
            paramName=curPair->GetDataString();
        }
    }
    std::string netPak = bkp->GetStreamInputModuleParamProperties(modname, paramName);
    return CORBA::string_dup(netPak.c_str());

}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetStreamOutputModuleParamList(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        
        if (curPair->GetDataName()=="ModuleName")
        {
            modname=curPair->GetDataString();
        }
        else if (curPair->GetDataName()=="ModuleId")
        {
            curPair->GetData(modId);
        }
    }

    //There shouldn't be two intances of an Aspen framework. so discard the moduleId
    //the returned string will be a well formated XML within "vecommand" element
    std::string netPak = bkp->GetStreamOutputModuleParams(modname);
    return CORBA::string_dup(netPak.c_str());
}
////////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::handleGetStreamOutputModuleProperties(ves::open::xml::CommandPtr cmd)
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname,paramName;
    unsigned int modId;

    for( size_t i=0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        if (curPair->GetDataName()=="ModuleName")
        {
            modname=curPair->GetDataString();
        }
        else if (curPair->GetDataName()=="moduleId")
        {
            curPair->GetData(modId); //modId is discarded because of the same reason as before
        }
        else if (curPair->GetDataName()=="ParamName")
        {
            paramName=curPair->GetDataString();
        }
    }
    std::string netPak = bkp->GetStreamOutputModuleParamProperties(modname, paramName);
    return CORBA::string_dup(netPak.c_str());

}
////////////////////////////////////////////////////////////////////////////////
/*void VEPSI_i::SetParams (CORBA::Long id,
    const char * param)
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    //discard the id, it is not used;
    ves::open::xml::XMLReaderWriter networkWriter;
    networkWriter.UseStandaloneDOMDocumentManager();
    networkWriter.ReadFromString();
    networkWriter.ReadXMLData( param, "Command", "vecommand" );
    std::vector< ves::open::xml::XMLObjectPtr > objectVector = 
        networkWriter.GetLoadedXMLObjects();

    //this part would need rewrite later
    for( size_t i = 0; i < objectVector.size(); ++i )
    {
        ves::open::xml::CommandPtr paramCmd = 
            boost::dynamic_pointer_cast<ves::open::xml::Command>( 
            objectVector.at( i ) );
        std::string paramName = paramCmd->GetCommandName();

        //insert code here to resolve how upwind data is passed to aspen unit
        //when it is included in a network
        size_t numDVP = boost::dynamic_pointer_cast< ves::open::xml::Command >(
            paramCmd->GetDataValuePair( "setParam" )->GetDataXMLObject())->
            GetNumberOfDataValuePairs();
 
        for( size_t j = 0; j < numDVP; ++j )
        {
            ves::open::xml::DataValuePairPtr tempDVP =
                boost::dynamic_pointer_cast< ves::open::xml::Command >(
                paramCmd->GetDataValuePair( "setParam" )->GetDataXMLObject())->
                GetDataValuePair( j );
           
            ves::open::xml::CommandPtr tempCmd =
                boost::dynamic_pointer_cast< ves::open::xml::Command >(
                tempDVP->GetDataXMLObject());

            SetParam( tempCmd );
        }
    }
}*/
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::SetParam( ves::open::xml::CommandPtr cmd )
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname,paramName, paramValue;

    if( bkpFlag )
    {
        for( size_t i = 0; i < num; i++)
        {
            ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
            if (curPair->GetDataName()=="ModuleName")
            {
                modname=curPair->GetDataString();
            }
            else if (curPair->GetDataName()=="ParamName")
            {
                paramName=curPair->GetDataString();
            }
            else if (curPair->GetDataName()=="ParamValue")
            {
                paramValue=curPair->GetDataString();
            }
        }
        
        CASI::CASIObj cur_block = bkp->aspendoc->getBlockByName(modname.c_str());
        CASI::Variable tempvar = cur_block.getInputVarByName(paramName.c_str());
        CASI::Variable cur_var = bkp->aspendoc->getVarByNodePath(tempvar.getNodePath());
        CString newValue;
        newValue = paramValue.c_str();
        bool success = cur_var.setValue(newValue);
    }
    
    if( dynFlag )
    {
        for( size_t i = 0; i < num; i++)
        {
            ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( i );
            std::vector< std::string > temp_vector;
            pair->GetData( temp_vector );
            dyn->SetValue( temp_vector[0], temp_vector[1], temp_vector[2], true );
        }
    }
}
////////////////////////////////////////////////////////////////////////////////
void VEPSI_i::SetLinkParam( ves::open::xml::CommandPtr cmd )
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::string modname,paramName, paramValue;

    if( dynFlag )
    {
        for( size_t i = 0; i < num; i++)
        {
            ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( i );
            std::vector< std::string > temp_vector;
            pair->GetData( temp_vector );
            dyn->SetValue( temp_vector[0].c_str(), temp_vector[1].c_str(),
                temp_vector[2].c_str(), false );
        }
    }
}
///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::addVariable( ves::open::xml::CommandPtr cmd )
{
    ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( 0 );
    std::string var;
    pair->GetData( var );
    if( dynFlag )
    {
        dyn->AddADVariable( var );
    }
    else if( dynSimFlag )
    {
        dynSim->AddOPCVariable( var.c_str() );
    }
}
///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::Monitor(  )
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    while (true)
    {
        //Aspen Dynamics
        if( dynFlag )
        {
            int temp = dyn->NumADVars();
            bool tempBool = dyn->IsADVarsEmpty();
            if( !tempBool && dyn && !mQuerying )
            {
                _mutex.acquire();
                std::string netPak = dyn->GetADValues( );
                theParent->GetExecutive()->SetParams(0, 0, CORBA::string_dup( netPak.c_str( ) ) );     
                _mutex.release();
            }
        }

        //DynSim
        if( dynSimFlag )
        {
            if( connected && !dynSim->IsOPCVarsEmpty()&& !mQuerying && dynSim )
            {
                _mutex.acquire();
                //dynsim->AddOPCVariable( "MY_SWITCH" );
                std::string netPak = dynSim->GetOPCValues( );
                theParent->GetExecutive()->SetParams(0, 0, CORBA::string_dup( netPak.c_str( ) ) );            
                _mutex.release();
            }
        }
        vpr::System::msleep( 5 );
    }
    CoUninitialize();
}

///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::UpdateVars( )
{
    if( connected )
    {
        std::vector< std::pair< std::string, std::string > > vars =
            dynSim->ReadVars();
        //std::map< std::string, std::pair< std::string, VARTYPE > > vars =
        //    dynsim->ReadVars();

        if( !vars.empty() )
        {
            //dump results to aspen log
            for( int i = 0; i < vars.size(); i++)
            {
                std::string temp = vars[i].first + " " + vars[i].second +"\n";
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel( temp.c_str() );
            }

            //dump results to aspen log
            //std::map< std::string, std::pair< std::string, VARTYPE > >::iterator iter;
            //for( iter = vars.begin(); iter != vars.end(); ++iter)
            //{
            //    std::string temp = iter->first + " " + iter->second.first +"\n";
            //    AspenLog->SetSel(-1, -1);
            //    AspenLog->ReplaceSel( temp.c_str() );
            //}
        }
    }
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::getOPCValues( ves::open::xml::CommandPtr cmd )
{
    std::string netPak = dynSim->GetOPCValues( );
    return CORBA::string_dup( netPak.c_str( ) );
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::setOPCValues( ves::open::xml::CommandPtr cmd )
{
    //read and parse command into map of var name and value
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::vector< std::pair< std::string, std::string > > varsAndValues;
    for ( size_t i=0; i < num; i++ )
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        std::pair< std::string, std::string > temp;
        temp.first = curPair->GetDataName();
        temp.second = curPair->GetDataString();
        varsAndValues.push_back( temp );
    }
    dynSim->SetOPCValues( varsAndValues );
    return CORBA::string_dup( "NULL" );
}
///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::connectWithList( ves::open::xml::CommandPtr cmd )
{
        //create variable list
        //ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( 0 );
        //std::vector< std::string > list;
        //pair->GetData( list );
        //dynSim->ConnectWithList( list );
}
///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::connectToOPC( ves::open::xml::CommandPtr cmd )
{
    connected = dynSim->ConnectToOPCServer();
    m_thread = new vpr::Thread( boost::bind( &VEPSI_i::Monitor,
            this ) );
    //m_Thread = AfxBeginThread( ThreadFunc, this);
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::getAllOPCVariables( ves::open::xml::CommandPtr cmd )
{
    ves::open::xml::DataValuePairPtr curPair = cmd->GetDataValuePair( 0 );
    std::string modname = curPair->GetDataString( );
    std::string netPak = dynSim->GetAllOPCVariables( modname.c_str() );
    return CORBA::string_dup( netPak.c_str( ) );
}

///DWSIM Functions
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::readInputFile( ves::open::xml::CommandPtr cmd )
{   
    ///Parse Output XML File
    std::string filename = mWorkingDir + mFileName + ".input.xml";
    
    ves::open::xml::DOMDocumentManager* mDomDocManager = new ves::open::xml::DOMDocumentManager();
    mDomDocManager->SetParseXMLFileOn();
    mDomDocManager->Load( filename );

    ///get input parameter entry
    std::map< std::string, std::vector< std::string > > inList;

    XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* mCommandDocument = mDomDocManager->GetCommandDocument();
    DOMElement* root_elem = mCommandDocument->getDocumentElement();
    DOMNodeList* inputList = 
        root_elem->getElementsByTagName (
        XMLString::transcode("InputParameters")
        );
    DOMNode* node = inputList->item( 0 );
    DOMElement* input_element = dynamic_cast< DOMElement* > ( node );
    
    ves::open::xml::DataValuePairPtr
        dvp( new ves::open::xml::DataValuePair() );
    
    ///may need simulationobjects tag first

    //get object entries
    DOMNodeList*objList = 
        input_element->getElementsByTagName (
        XMLString::transcode("Object")
        );

    int objCount = objList->getLength();
    //ves::open::xml::XMLObject* convert = new ves::open::xml::XMLObject();
    for( int i = 0; i < objCount; i++)
    {
        //get object name
        DOMNode* objNode = objList->item( i );
        DOMElement* element =
            dynamic_cast<DOMElement*> ( objNode );
        std::string objName;
        //ves::open::xml::XMLObject::GetAttribute( element, "Name", objName );
        dvp->GetAttribute( element, "Name", objName );

        //get properties
        //THIS GETS ALL THE PROPERTIES NOT OBJECT SPECIFIC
        //NEED TO GET ONLY THE PROPERTIES OF THE CURRENT OBJECT
        DOMElement* obj_element = dynamic_cast< DOMElement* > ( objNode );
        DOMNodeList* propList = 
            obj_element->getElementsByTagName (
            XMLString::transcode("Property")
            );
        int propCount = propList->getLength();
        for( int j = 0; j < propCount; j++)
        {
            DOMNode* propNode = propList->item( j );
            DOMElement* prop_element =
                dynamic_cast<DOMElement*> ( propNode );
            //prop tempProp;
            std::vector< std::string > tempProp;

            //prop id
            std::string id;
            dvp->GetAttribute( prop_element, "ID", id );
            if( id.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.id = id;
                tempProp.push_back( id );
            }
            
            //prop name
            std::string name;
            dvp->GetAttribute( prop_element, "Name", name );
            if( name.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.name = name;
                tempProp.push_back( name );
            }

            //prop value
            //double value;
            std::string value;
            dvp->GetAttribute( prop_element, "Value", value );
            if( value.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.value = value;
                tempProp.push_back( value );
            }
            
            //prop unit
            std::string unit;
            dvp->GetAttribute( prop_element, "Unit", unit );
            if( unit.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.unit = unit;
                tempProp.push_back( unit );
            }
                        
            inList[objName+"."+id] =( tempProp );
        }
    }
    
    //Construct return packet
    ves::open::xml::CommandPtr varsAndValues( new ves::open::xml::Command() );
    varsAndValues->SetCommandName("DWSIM_Data");
    //std::map< std::string, std::vector< std::vector< std::string > > >::iterator inIter;
    std::map< std::string, std::vector< std::string > >::iterator inIter;
    for( inIter = inList.begin(); inIter != inList.end(); ++inIter)
    {
        //for( int j = 0; j < inIter->second.size(); j++ )
        //{
            ves::open::xml::DataValuePairPtr
                entry( new ves::open::xml::DataValuePair() );
            entry->SetData( inIter->first, inIter->second );
            varsAndValues->AddDataValuePair( entry );
        //}
    }
    std::vector< std::pair< ves::open::xml::XMLObjectPtr, std::string > >
        nodes;
    nodes.push_back( std::pair< ves::open::xml::XMLObjectPtr, std::string >
        ( varsAndValues, "vecommand" ) );

    ves::open::xml::XMLReaderWriter commandWriter;
    std::string status="returnString";
    commandWriter.UseStandaloneDOMDocumentManager();
    commandWriter.WriteXMLDocument( nodes, status, "Command" );
    return CORBA::string_dup( status.c_str( ) );
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::readOutputFile( ves::open::xml::CommandPtr cmd )
{
    ///Parse Output XML File
    std::string filename = mWorkingDir + mFileName + ".output.xml";
    
    ves::open::xml::DOMDocumentManager* mDomDocManager = new ves::open::xml::DOMDocumentManager();
    mDomDocManager->SetParseXMLFileOn();
    mDomDocManager->Load( filename );

    ///get output parameter entry
    std::map< std::string, std::vector< std::string > > outList;

    XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* mCommandDocument = mDomDocManager->GetCommandDocument();
    DOMElement* root_elem = mCommandDocument->getDocumentElement();
    DOMNodeList* outputList = 
        root_elem->getElementsByTagName (
        XMLString::transcode("OutputParameters")
        );
    DOMNode* node = outputList->item( 0 );
    DOMElement* output_element = dynamic_cast< DOMElement* > ( node );
    
    ves::open::xml::DataValuePairPtr
        dvp( new ves::open::xml::DataValuePair() );
    
    ///may need simulationobjects tag first

    //get object entries
    DOMNodeList*objList = 
        output_element->getElementsByTagName (
        XMLString::transcode("Object")
        );

    int objCount = objList->getLength();
    //ves::open::xml::XMLObject* convert = new ves::open::xml::XMLObject();
    for( int i = 0; i < objCount; i++)
    {
        //get object name
        DOMNode* objNode = objList->item( i );
        DOMElement* element =
            dynamic_cast<DOMElement*> ( objNode );
        std::string objName;
        //ves::open::xml::XMLObject::GetAttribute( element, "Name", objName );
        dvp->GetAttribute( element, "Name", objName );

        //get properties
        //THIS GETS ALL THE PROPERTIES NOT OBJECT SPECIFIC
        //NEED TO GET ONLY THE PROPERTIES OF THE CURRENT OBJECT
        DOMElement* obj_element = dynamic_cast< DOMElement* > ( objNode );
        DOMNodeList* propList = 
            obj_element->getElementsByTagName (
            XMLString::transcode("Property")
            );
        int propCount = propList->getLength();
        for( int j = 0; j < propCount; j++)
        {
            DOMNode* propNode = propList->item( j );
            DOMElement* prop_element =
                dynamic_cast<DOMElement*> ( propNode );
            //prop tempProp;
            std::vector< std::string > tempProp;

            //prop id
            std::string id;
            dvp->GetAttribute( prop_element, "ID", id );
            if( id.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.id = id;
                tempProp.push_back( id );
            }
            
            //prop name
            std::string name;
            dvp->GetAttribute( prop_element, "Name", name );
            if( name.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.name = name;
                tempProp.push_back( name );
            }

            //prop value
            //double value;
            std::string value;
            dvp->GetAttribute( prop_element, "Value", value );
            if( value.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.value = value;
                tempProp.push_back( value );
            }
            
            //prop unit
            std::string unit;
            dvp->GetAttribute( prop_element, "Unit", unit );
            if( unit.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.unit = unit;
                tempProp.push_back( unit );
            }
                        
            outList[objName+"."+id] =( tempProp );
        }
    }
    
    //Construct return packet
    ves::open::xml::CommandPtr varsAndValues( new ves::open::xml::Command() );
    varsAndValues->SetCommandName("DWSIM_Data");
    //std::map< std::string, std::vector< std::vector< std::string > > >::iterator inIter;
    std::map< std::string, std::vector< std::string > >::iterator inIter;
    for( inIter = outList.begin(); inIter != outList.end(); ++inIter)
    {
        //for( int j = 0; j < inIter->second.size(); j++ )
        //{
            ves::open::xml::DataValuePairPtr
                entry( new ves::open::xml::DataValuePair() );
            entry->SetData( inIter->first, inIter->second );
            varsAndValues->AddDataValuePair( entry );
        //}
    }
    std::vector< std::pair< ves::open::xml::XMLObjectPtr, std::string > >
        nodes;
    nodes.push_back( std::pair< ves::open::xml::XMLObjectPtr, std::string >
        ( varsAndValues, "vecommand" ) );

    ves::open::xml::XMLReaderWriter commandWriter;
    std::string status="returnString";
    commandWriter.UseStandaloneDOMDocumentManager();
    commandWriter.WriteXMLDocument( nodes, status, "Command" );
    return CORBA::string_dup( status.c_str( ) );
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::readInputFileOutputs( ves::open::xml::CommandPtr cmd )
{
    ///Parse Output XML File
    std::string filename = mWorkingDir + mFileName + ".input.xml";
    
    ves::open::xml::DOMDocumentManager* mDomDocManager = new ves::open::xml::DOMDocumentManager();
    mDomDocManager->SetParseXMLFileOn();
    mDomDocManager->Load( filename );

    ///get output parameter entry
    std::map< std::string, std::vector< std::string > > outList;

    XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* mCommandDocument = mDomDocManager->GetCommandDocument();
    DOMElement* root_elem = mCommandDocument->getDocumentElement();
    DOMNodeList* outputList = 
        root_elem->getElementsByTagName (
        XMLString::transcode("OutputParameters")
        );
    DOMNode* node = outputList->item( 0 );
    DOMElement* output_element = dynamic_cast< DOMElement* > ( node );
    
    ves::open::xml::DataValuePairPtr
        dvp( new ves::open::xml::DataValuePair() );
    
    ///may need simulationobjects tag first

    //get object entries
    DOMNodeList*objList = 
        output_element->getElementsByTagName (
        XMLString::transcode("Object")
        );

    int objCount = objList->getLength();
    //ves::open::xml::XMLObject* convert = new ves::open::xml::XMLObject();
    for( int i = 0; i < objCount; i++)
    {
        //get object name
        DOMNode* objNode = objList->item( i );
        DOMElement* element =
            dynamic_cast<DOMElement*> ( objNode );
        std::string objName;
        //ves::open::xml::XMLObject::GetAttribute( element, "Name", objName );
        dvp->GetAttribute( element, "Name", objName );

        //get properties
        //THIS GETS ALL THE PROPERTIES NOT OBJECT SPECIFIC
        //NEED TO GET ONLY THE PROPERTIES OF THE CURRENT OBJECT
        DOMElement* obj_element = dynamic_cast< DOMElement* > ( objNode );
        DOMNodeList* propList = 
            obj_element->getElementsByTagName (
            XMLString::transcode("Property")
            );
        int propCount = propList->getLength();
        for( int j = 0; j < propCount; j++)
        {
            DOMNode* propNode = propList->item( j );
            DOMElement* prop_element =
                dynamic_cast<DOMElement*> ( propNode );
            //prop tempProp;
            std::vector< std::string > tempProp;

            //prop id
            std::string id;
            dvp->GetAttribute( prop_element, "ID", id );
            if( id.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.id = id;
                tempProp.push_back( id );
            }
            
            //prop name
            std::string name;
            dvp->GetAttribute( prop_element, "Name", name );
            if( name.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.name = name;
                tempProp.push_back( name );
            }

            //prop value
            //double value;
            std::string value;
            dvp->GetAttribute( prop_element, "Value", value );
            if( value.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.value = value;
                tempProp.push_back( value );
            }
            
            //prop unit
            std::string unit;
            dvp->GetAttribute( prop_element, "Unit", unit );
            if( unit.compare("") == 0 )
            {
                tempProp.push_back( "N/A" );
            }
            else
            {
                //tempProp.unit = unit;
                tempProp.push_back( unit );
            }
                        
            outList[objName+"."+id] =( tempProp );
        }
    }
    
    //Construct return packet
    ves::open::xml::CommandPtr varsAndValues( new ves::open::xml::Command() );
    varsAndValues->SetCommandName("DWSIM_Data");
    //std::map< std::string, std::vector< std::vector< std::string > > >::iterator inIter;
    std::map< std::string, std::vector< std::string > >::iterator inIter;
    for( inIter = outList.begin(); inIter != outList.end(); ++inIter)
    {
        //for( int j = 0; j < inIter->second.size(); j++ )
        //{
            ves::open::xml::DataValuePairPtr
                entry( new ves::open::xml::DataValuePair() );
            entry->SetData( inIter->first, inIter->second );
            varsAndValues->AddDataValuePair( entry );
        //}
    }
    std::vector< std::pair< ves::open::xml::XMLObjectPtr, std::string > >
        nodes;
    nodes.push_back( std::pair< ves::open::xml::XMLObjectPtr, std::string >
        ( varsAndValues, "vecommand" ) );

    ves::open::xml::XMLReaderWriter commandWriter;
    std::string status="returnString";
    commandWriter.UseStandaloneDOMDocumentManager();
    commandWriter.WriteXMLDocument( nodes, status, "Command" );
    return CORBA::string_dup( status.c_str( ) );
}
///////////////////////////////////////////////////////////////////////////////
char* VEPSI_i::setInputs( ves::open::xml::CommandPtr cmd )
{
    std::string filename = mWorkingDir + mFileName + ".input.xml";
    
    ves::open::xml::DOMDocumentManager* mDomDocManager = new ves::open::xml::DOMDocumentManager();
    mDomDocManager->SetParseXMLFileOn();
    mDomDocManager->Load( filename );

    ///get input parameter entry
    XERCES_CPP_NAMESPACE_QUALIFIER DOMDocument* mCommandDocument = mDomDocManager->GetCommandDocument(); //= mParser->getDocument();
    DOMElement* root_elem = mCommandDocument->getDocumentElement();
    DOMNodeList* inputList = 
        root_elem->getElementsByTagName (
        XMLString::transcode("InputParameters")
        );
    DOMNode* node = inputList->item( 0 );
    DOMElement* input_element = dynamic_cast< DOMElement* > ( node );
    
    ves::open::xml::DataValuePairPtr
        dvp( new ves::open::xml::DataValuePair() );
    
    ///populate map of variables to change
    std::map< std::string, std::map< std::string, std::string > > tempMap;
    size_t num = cmd->GetNumberOfDataValuePairs();
    for( size_t i = 0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( i );
        std::vector< std::string > temp_vector;
        pair->GetData( temp_vector );
        tempMap[temp_vector[0]][temp_vector[1]] = temp_vector[2];
    }

    //get object entries
    DOMNodeList*objList = 
        input_element->getElementsByTagName (
        XMLString::transcode("Object")
        );

    int objCount = objList->getLength();
    for( int i = 0; i < objCount; i++)
    {
        //get object name
        DOMNode* objNode = objList->item( i );
        DOMElement* element =
            dynamic_cast<DOMElement*> ( objNode );
        std::string objName;
        dvp->GetAttribute( element, "Name", objName );

        //loop over names name
        if( tempMap.find(objName) != tempMap.end() )
        {
            //get properties
            DOMElement* obj_element = dynamic_cast< DOMElement* > ( objNode );
            DOMNodeList* propList = 
                obj_element->getElementsByTagName (
                XMLString::transcode("Property")
                );
            int propCount = propList->getLength();

            //loop over properties and change those requested
            for( int j = 0; j < propCount; j++)
            {
                DOMNode* propNode = propList->item( j );
                DOMElement* prop_element =
                    dynamic_cast<DOMElement*> ( propNode );

                //prop id
                std::string id;
                dvp->GetAttribute( prop_element, "ID", id );
                
                //if( id.compare("PROP_ES_0")==0)
                if( tempMap[objName].find(id) != tempMap[objName].end() )
                {                   
                    //set input
                    dvp->SetAttribute( "Value", tempMap[objName][id], prop_element );
                    
                    //save inputs file
                    mDomDocManager->SetOuputXMLFile( filename );
                    mDomDocManager->SetWriteXMLFileOn();
                    mDomDocManager->WriteAndReleaseCommandDocument();
                    return NULL;
                }
            }
        }
    }
    return NULL;
}

///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::setInputPort( ves::open::xml::CommandPtr cmd )
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    for( size_t i = 0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( i );
        std::vector< std::string > temp_vector;
        pair->GetData( temp_vector );
        mPortInput.first = temp_vector[0];
        mPortInput.second.first = temp_vector[1];
        mPortInput.second.second = temp_vector[2];
    }
}
///////////////////////////////////////////////////////////////////////////////
void VEPSI_i::setOutputPort( ves::open::xml::CommandPtr cmd )
{
    size_t num = cmd->GetNumberOfDataValuePairs();
    for( size_t i = 0; i < num; i++)
    {
        ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( i );
        std::vector< std::string > temp_vector;
        pair->GetData( temp_vector );
        mPortOutput.first = temp_vector[0];
        mPortOutput.second.first = temp_vector[1];
        mPortOutput.second.second = temp_vector[2];
    }
}