// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// .\be\be_codegen.cpp:1063

#include "stdafx.h"
#include "AspenUnit_i.h"
#include "DynSimUnit.h"
#include <ves/open/xml/model/Network.h>
#include <ves/open/xml/model/Link.h>
#include <ves/open/xml/model/Model.h>
#include <ves/open/xml/DataValuePair.h>
#include <ves/open/xml/XMLReaderWriter.h>
#include <ves/open/xml/model/Point.h>
#include <ves/open/xml/model/Port.h>
#include <ves/open/xml/Command.h>
#include <ves/open/xml/XMLObjectFactory.h>
#include <ves/open/xml/XMLCreator.h>
#include <ves/open/xml/shader/ShaderCreator.h>
#include <ves/open/xml/model/ModelCreator.h>
#include <ves/open/xml/cad/CADCreator.h>
#include <fstream>
#include <iostream>

#include <vpr/vpr.h>
#include <vpr/System.h>
#include <boost/bind.hpp>

// Implementation skeleton constructor
AspenUnit_i::AspenUnit_i( std::string name, CDynSimUnitDlg * dialog, 
                         CorbaUnitManager* parent, std::string dir )
    :
    AspenLog( 0 ),
    theParent( parent ),
    theDialog( dialog ),
    return_state( 0 ),
    cur_id_( 0 ),
    UnitName_( name ),
    mWorkingDir( dir ),
    dynsim ( NULL ),
    mQuerying(false)
{
    ves::open::xml::XMLObjectFactory::Instance()->
        RegisterObjectCreator( "XML",new ves::open::xml::XMLCreator() );
    ves::open::xml::XMLObjectFactory::Instance()->
        RegisterObjectCreator(
        "Shader",new ves::open::xml::shader::ShaderCreator() );
    ves::open::xml::XMLObjectFactory::Instance()->
        RegisterObjectCreator(
        "Model",new ves::open::xml::model::ModelCreator() );
    ves::open::xml::XMLObjectFactory::Instance()->
        RegisterObjectCreator( "CAD",new ves::open::xml::cad::CADCreator() );

    AspenLog = reinterpret_cast<CEdit *>(theDialog->GetDlgItem(IDC_EDIT1));

    mQueryCommandNames.insert( "getNetwork");
    mQueryCommandNames.insert( "getOPCValue");
    mQueryCommandNames.insert( "getOPCValues");
    mQueryCommandNames.insert( "setOPCValues");
    //mQueryCommandNames.insert( "connectWithList");
    mQueryCommandNames.insert( "connectToOPC");
    mQueryCommandNames.insert( "addVariable");
    mQueryCommandNames.insert( "getAllOPCVariables");
}
////////////////////////////////////////////////////////////////////////////////
// Implementation skeleton destructor
AspenUnit_i::~AspenUnit_i( void )
{
}

////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::StartCalc (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::StopCalc (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::PauseCalc (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::Resume (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
}
////////////////////////////////////////////////////////////////////////////////
char * AspenUnit_i::GetStatusMessage (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
  // Add your implementation here
    return NULL;
}
////////////////////////////////////////////////////////////////////////////////
char * AspenUnit_i::GetUserData (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
  // Add your implementation here
    return NULL;
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::SetID (
    ::CORBA::Long id
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
  // Add your implementation here
  // no need to implement this
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::SetCurID (
    ::CORBA::Long id
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
}
////////////////////////////////////////////////////////////////////////////////
::Types::ArrayLong* AspenUnit_i::GetID (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    /*
    return &ids_;
    */
    return NULL;
}
////////////////////////////////////////////////////////////////////////////////
CORBA::Long AspenUnit_i::GetCurID (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    /*
    return cur_id_;
    */
    return NULL;
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::DeleteModuleInstance(CORBA::Long id) 
ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    /*
    return; //do nothing;
    */
}
////////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::SetName (
    const char * name
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
  // Add your implementation here
}
////////////////////////////////////////////////////////////////////////////////
char * AspenUnit_i::GetName (
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    return NULL;
}

////////////////////////////////////////////////////////////////////////////////
char * AspenUnit_i::Query ( const char * query_str
    
  )
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
    mQuerying = true;

    AspenLog->SetSel( -1, -1 );
    AspenLog->ReplaceSel( "Query\r\n" );
    _mutex.acquire();

    ves::open::xml::XMLReaderWriter networkWriter;
    networkWriter.UseStandaloneDOMDocumentManager();
    networkWriter.ReadFromString();
    networkWriter.ReadXMLData( query_str, "Command", "vecommand" );

    std::vector< ves::open::xml::XMLObjectPtr > objectVector =
        networkWriter.GetLoadedXMLObjects();

    ves::open::xml::CommandPtr cmd;    
    std::string cmdname;
    
    cmd = boost::dynamic_pointer_cast<ves::open::xml::Command>
        ( objectVector.at( 0 ) );
    cmdname = cmd->GetCommandName();
    
    std::set< std::string >::const_iterator commandItr
        = mQueryCommandNames.find( cmdname );
    
    //If the command is not processed here - do not bother doing anything more
    if( commandItr == mQueryCommandNames.end() )
    {
        _mutex.release();
        mQuerying = false;
        return CORBA::string_dup("NULL");
    }
    
    AspenLog->SetSel( -1, -1 );
    AspenLog->ReplaceSel( ("Command: "+cmdname+"\r\n").c_str() );
    char* returnValue = "empty";

    if ( cmdname == "getNetwork" )
    {
        returnValue = handleGetNetwork( cmd );
        _mutex.release();
        mQuerying = false;
        return returnValue;
    }
    else if ( cmdname == "getOPCValues" )
    {
        returnValue = getOPCValues( cmd );
        _mutex.release();
        mQuerying = false;
        return returnValue;
    }
    else if ( cmdname == "setOPCValues" )
    {
        returnValue = setOPCValues( cmd );
        _mutex.release();
        mQuerying = false;
        return returnValue;
    }
    //else if ( cmdname == "connectWithList" )
    //{
    //    //returnValue = monitorValues( cmd );
    //    connectWithList( cmd );
    //    //return returnValue;
    //    return( "NULL" );
    //}
    else if ( cmdname == "connectToOPC" )
    {
        connectToOPC( cmd );
        _mutex.release();
        mQuerying = false;
        return( "NULL" );
    }
    else if ( cmdname == "addVariable" )
    {
        addVariable( cmd );
        _mutex.release();
        mQuerying = false;
        return( "NULL" );
    }
    else if ( cmdname == "getAllOPCVariables" )
    {
        returnValue = getAllOPCVariables( cmd );
        _mutex.release();
        mQuerying = false;
        return returnValue;
    }
    else
    {
        _mutex.release();
        mQuerying = false;
        return CORBA::string_dup( "NULL" );
    }
}
///////////////////////////////////////////////////////////////////////////////
char* AspenUnit_i::handleGetNetwork(ves::open::xml::CommandPtr cmd)
{
    CEdit *Display;
    Display = reinterpret_cast<CEdit *>(theDialog->GetDlgItem(IDC_EDIT2));

    //this command has no params
    bool firsttime=true;

    std::string filename = cmd->GetDataValuePair(1)->GetDataString();

    std::string extension = filename.substr( filename.size() - 4, 4 );
 
    //xmlFlag = true;
    filename.resize( filename.size() - 4 );
    //bkp = new BKPParser();
    //bkp->SetWorkingDir( mWorkingDir );
    dynsim = new DynSimParser();

    std::string network;
    if (firsttime)
    {
        //make sure bkp file exists
        std::ifstream xmlFile( ( mWorkingDir + filename + ".xml" ).c_str(),
            std::ios::binary);
        if( !xmlFile.is_open() )
        {
            //no bkp file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("XML File Does NOT exist.\r\n");
            return CORBA::string_dup( "XMLDNE" );
        }
        xmlFile.close();

        //make sure apw file exists
        std::ifstream s4mFile( ( mWorkingDir + filename + ".s4m" ).c_str(),
            std::ios::binary);
        if( !s4mFile.is_open() )
        {
            //no apw file
            AspenLog->SetSel(-1, -1);
            AspenLog->ReplaceSel("S4M File Does NOT exist.\r\n");
            return CORBA::string_dup( "S4MDNE" );
        }
        s4mFile.close();

        //Display->SetWindowText( ( mWorkingDir + filename ).c_str());
        Display->SetWindowText( ( filename ).c_str());
        //go through bkp parsing procedure
        network = dynsim->CreateNetwork( filename );
        //boost::fs::path( mWorkingDir, boost::fs::
        
        //this is a system call to open dynsim
        //for now we will manual open and run dynsim flowsheet before the unit
        //dynsim->OpenFile( mWorkingDir + filename + ".s4m" );

        mFileName = filename;
        firsttime=false;
    }

    //hack to add some form of opc development to VE-PSI
    //connected = dynsim->ConnectToOPC();

    return CORBA::string_dup( network.c_str() );
    //return NULL;
}
void AspenUnit_i::UpdateVars( )
{
    if( connected )
    {
        std::vector< std::pair< std::string, std::string > > vars =
            dynsim->ReadVars();

        if( !vars.empty() )
        {
            //dump results to aspen log
            for( int i = 0; i < vars.size(); i++)
            {
                std::string temp = vars[i].first + " " + vars[i].second +"\n";
                AspenLog->SetSel(-1, -1);
                AspenLog->ReplaceSel( temp.c_str() );
            }
        }
    }
}
///////////////////////////////////////////////////////////////////////////////
/*char* AspenUnit_i::getOPCValue( ves::open::xml::CommandPtr cmd )
{
    ves::open::xml::DataValuePairPtr curPair = cmd->GetDataValuePair( 0 );
    std::string modname = curPair->GetDataString( );
    std::string netPak = dynsim->GetOPCValue( modname.c_str() );
    return CORBA::string_dup( netPak.c_str( ) );
}*/
///////////////////////////////////////////////////////////////////////////////
char* AspenUnit_i::getOPCValues( ves::open::xml::CommandPtr cmd )
{
    std::string netPak = dynsim->GetOPCValues( );
    return CORBA::string_dup( netPak.c_str( ) );
}
///////////////////////////////////////////////////////////////////////////////
char* AspenUnit_i::setOPCValues( ves::open::xml::CommandPtr cmd )
{
    //read and parse command into map of var name and value
    size_t num = cmd->GetNumberOfDataValuePairs();
    std::vector< std::pair< std::string, std::string > > varsAndValues;
    for ( size_t i=0; i < num; i++ )
    {
        ves::open::xml::DataValuePairPtr curPair= cmd->GetDataValuePair(i);
        std::pair< std::string, std::string > temp;
        temp.first = curPair->GetDataName();
        temp.second = curPair->GetDataString();
        varsAndValues.push_back( temp );
    }
    dynsim->SetOPCValues( varsAndValues );
    return CORBA::string_dup( "NULL" );
}
///////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::connectWithList( ves::open::xml::CommandPtr cmd )
{
        //create variable list
        //ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( 0 );
        //std::vector< std::string > list;
        //pair->GetData( list );
        //dynsim->ConnectWithList( list );
}

UINT ThreadFunc ( LPVOID empty );

UINT ThreadFunc ( LPVOID empty )
{
    AspenUnit_i * temp = (AspenUnit_i *) empty;
    temp->Monitor();
    return 0;
}

///////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::connectToOPC( ves::open::xml::CommandPtr cmd )
{
    connected = dynsim->ConnectToOPCServer();
    m_thread = new vpr::Thread( boost::bind( &AspenUnit_i::Monitor,
            this ) );
    //m_Thread = AfxBeginThread( ThreadFunc, this);
}
///////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::addVariable( ves::open::xml::CommandPtr cmd )
{
    ves::open::xml::DataValuePairPtr pair = cmd->GetDataValuePair( 0 );
    std::string var;
    pair->GetData( var );
    dynsim->AddOPCVariable( var.c_str() );
}
///////////////////////////////////////////////////////////////////////////////
char* AspenUnit_i::getAllOPCVariables( ves::open::xml::CommandPtr cmd )
{
    ves::open::xml::DataValuePairPtr curPair = cmd->GetDataValuePair( 0 );
    std::string modname = curPair->GetDataString( );
    std::string netPak = dynsim->GetAllOPCVariables( modname.c_str() );
    return CORBA::string_dup( netPak.c_str( ) );
}

///////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::SetParams (CORBA::Long id,
    const char * param)
  ACE_THROW_SPEC ((
    ::CORBA::SystemException,
    ::Error::EUnknown
  ))
{
}

///////////////////////////////////////////////////////////////////////////////
void AspenUnit_i::Monitor(  )
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    while (true)
    {
    AspenLog->SetSel( -1, -1 );
    AspenLog->ReplaceSel( "Update\r\n" );
        if( connected && !dynsim->IsOPCVarsEmpty()&& !mQuerying && dynsim )
        {
            
        _mutex.acquire();
            //dynsim->AddOPCVariable( "MY_SWITCH" );
            std::string netPak = dynsim->GetOPCValues( );
            theParent->GetExecutive()->SetParams(0, 0, CORBA::string_dup( netPak.c_str( ) ) );
            
        _mutex.release();
        }
        vpr::System::msleep( 10 );
    }
    CoUninitialize();
}
