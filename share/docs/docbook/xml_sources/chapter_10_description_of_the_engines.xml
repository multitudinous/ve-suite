<?xml version="1.0" encoding="UTF-8"?>
<chapter id="Description_of_the_Engines">
  <title>Description of the Engines</title>

  <para>VE-Suite is composed of three main software engines that coordinate
  the flow of data from the engineer to the virtual components being designed.
  The following sections will detail the design of each of these engines and
  describe how they contribute to the overall framework functionality.</para>

  <mediaobject>
    <imageobject>
      <imagedata fileref="../veimages/descriptionofengines1.jpg" />
    </imageobject>
  </mediaobject>

  <section id="gui_veconductor">
    <title>Graphical User Interface (VE-Conductor)</title>

    <para>To achieve the goals outlined for the project, a powerful and
    flexible user interface (UI) was implemented. Key features of the VE-Suite
    two-dimensional UI (VE-Conductor) are described in the following
    sections.</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="../veimages/conductorTri.jpg" />
      </imageobject>
    </mediaobject>

    <section id="conductor_multiplatform_support">
      <title>Multi-Platform Support</title>

      <para>The UI makes use of platform independent libraries to enable the
      software to run on a wide range of computer hardware and operating
      systems. These platforms range from Unix workstations to Pocket PCs and
      PDAs. This functionality is ideal for the virtual engineering-based
      system since users will frequently make use of handheld computing
      devices inside of immersive environments (e.g., cave-like systems at
      ISU-VRAC and NETL).</para>

      <para>After reviewing a number of different UI libraries, <ulink
      url="www.wxwidgets.org">WxWidgets</ulink> was chosen. WxWidgets is one
      of the best cross-platform GUI packages available. It is
      well-maintained, has a large user base, and has ports for Windows,
      Unix/X11, Unix/Motif, OS2, Mac, and GTK. It also has an alpha version of
      a Windows CE port, which is under active development. This ensures that
      the user interface will run on all major platforms and even on Pocket
      PC-based PDAs.</para>
    </section>

    <section id="conductor_detachable_location_transparency">
      <title>Detachable/Location Transparency</title>

      <para>The UI exists independently from the computational engine as a
      separate CORBA component. This functionality allows the UI to be
      attached and detached from an active simulation from any compatible
      computer on the network. As an example, this would allow a user to build
      and start a simulation and then detach from the computational engine.
      The user could then go to a different location, re-attach to the
      simulation, and regain monitoring and control functions.</para>

      <para>To accomplish this functionality a CORBA IDL interface between the
      UI and the computational engine was defined. This CORBA interface
      provides all the necessary communication mechanisms between these
      components. The communication link is bidirectional and handles items
      such as model parameters passed to the computational engine and receives
      items such as execution status and results from the computational
      engine.</para>

      <para>Another advantage of this design is the ability for multiple UIs
      to be attached to the same computational engine, allowing multiple users
      to monitor a simulation from different locations. A locking mechanism is
      used so that only one UI (controller) can change the design and inputs
      of the simulation. The UI also has the ability to connect to the
      graphical environment and control what graphical representations are
      shown for high fidelity data (i.e., contour planes, vector planes,
      streamlines, iso-surfaces) or for low fidelity data (i.e., gauges
      showing scalar information about plant performance, costing data, or
      emissions data).</para>
    </section>

    <section id="conductor_extensibility">
      <title>Extensibility</title>

      <para>Another important consideration for the UI design is
      extensibility. The UI is able to dynamically discover, identify, and
      load UI elements for new component models. This capability keeps the
      level of difficulty involved in integrating new component models to a
      minimum since it eliminates the need for modifications to the core
      interface when new models are added.</para>

      <para>The dynamic discover and load capability is accomplished by
      loading user developed module UIs from dynamic link libraries (DLL in
      Windows) or shared libraries (SO lib in Linux/Unix). A plugin C++ base
      class defining this UI-module interface is provided to all module
      developers. Developers can inherit from this class to create their own
      module UIs and then compile the resulting code into a DLL/shared
      library. The UI frameworkâ€™s plug loader code will recognize the new
      module and bring that into its user-module library. By this mechanism,
      the core UI can plug in the third-party module-specific UI directly from
      binaries.</para>
    </section>

    <section id="conductor_unified_control">
      <title>Unified Control</title>

      <para>Another feature of the UI is unified control for all user
      interaction. This ensures that the user is not burdened with moving
      between different UIs to perform operations. There is a single UI with
      the ability to: 1) construct, specify, execute and monitor simulations;
      and 2) provide complete control of the three-dimensional virtual
      environment.</para>

      <para>To provide this functionality, the UI is designed to communicate
      via CORBA to not only the computational engine, but also to the
      graphical engine. As was discussed for the UI-to-computational engine
      link, the use of CORBA with an appropriate IDL provides a flexible,
      detachable, and platform independent communication mechanism for this
      link as well.</para>

      <para>The following figure shows the two-dimensional GUI. A list of
      available modules is maintained in a tree structure on the left side of
      the window, while the main canvas area shows the current simulation
      network.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="../veimages/descriptionofengines2.jpg" />
        </imageobject>
      </mediaobject>
    </section>
  </section>

  <section id="computational_engine_vece">
    <title>Computational Engine (VE-CE)</title>

    <para>The computational engine (VE-CE) is the core of the framework. Its
    duties are to construct, coordinate, schedule, and monitor plant
    simulation runs. It is capable of running a simulation containing a
    multitude of different types of models, each accepting and generating a
    myriad of data types. The computational engine is able to analyze a plant
    configuration, determine execution order, marshal system resources to
    create model instances, and coordinate the flow of data through the
    simulation framework. Tasks that require specific knowledge about a data
    type or model are relegated to either a detachable UI or to a specific
    model, thus keeping the computational engine generalized at a high
    level.</para>

    <para>Important functions that the computational engine controls can be
    broken down into several pieces for explanation: plant configuration, data
    handling, error handling, relationship to detachable UI, scheduling, and
    relationship to models. Each of these is described in detail in the
    following sections.</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="../veimages/compengTri.jpg" />
      </imageobject>
    </mediaobject>

    <section id="vece_plant_configuration">
      <title>Plant Configuration</title>

      <para>The configuration of the plant, provided by a detachable UI, is
      the primary data structure used by the computational engine. Nearly all
      algorithms utilized, such as proper data flow, scheduling, and resource
      allocation depend on this topology.</para>
    </section>

    <section id="vece_data_handling">
      <title>Data Handling</title>

      <para>Since there is an unlimited number of possible models capable of
      being integrated into the framework (with each model having a different
      input/output set), the computational engine operates with generalized
      datatypes. To address this requirement, we have designed the CORBA IDL
      interfaces between the computational engine and the component models to
      use mapped string blocks in combination with common dimensions of array
      data.</para>
    </section>

    <section id="vece_error_handling">
      <title>Error Handling</title>

      <para>With the computational engine being the centralized intelligence
      behind a simulation run, all errors that occur while performing this
      task (whether originating within its own structure or on an attached
      model) must be properly handled within the context of this overriding
      structure. Thus, the computational engine has sophisticated error
      handling routines and messaging facilities to alert attached users. To
      fit into the detached UI paradigm, any errors that occur on an attached
      UI are handled locally.</para>
    </section>

    <section id="vece_relationship_to_detachable_ui">
      <title>Relationship to Detachable UI</title>

      <para>The computational engine is a CORBA server into which a detachable
      UI client can connect. This detachable UI is where the user is able to
      create a plant configuration, set model inputs, start and stop execution
      of simulation, and view simulation results. Once a client-server
      connection is made, the engine is able to send results, messages,
      updates, and communications from other attached UIs in real time. The
      computational engine does not require a connection to a UI during a
      simulation run. Users can connect/disconnect at will to configure,
      modify, or monitor the simulation of a given plant configuration.</para>
    </section>

    <section id="vece_scheduling">
      <title>Scheduling</title>

      <para>The computational engine makes use of advanced scheduling
      algorithms. The scheduler, at minimum, will be capable of handling
      single and embedded feedback loops, iterative solves and, eventually,
      transient simulation runs.</para>
    </section>

    <section id="vece_relationship_to_models">
      <title>Relationship to Models</title>

      <para>The computational engine, with its CORBA interface, is able to
      connect to the various component models available for a simulation.
      Information passed through this connection includes inputs (user
      supplied and stream data), outputs, results, and general messages. The
      importance of the CORBA interface being used for this purpose is
      discussed in detail in the Model Integration section below.</para>
    </section>
  </section>

  <section id="graphical_engine_vexplorer">
    <title>Graphical Engine (VE-Xplorer)</title>

    <para>The graphical engine (VE-Xplorer) provides the core functionality
    for the virtual engineering aspect of the framework. VE-Xplorer enables
    the engineering analysis and design process to take place in a virtual
    environment. For maximum graphical performance on multiple operating
    systems, it is built upon <ulink
    url="www.vrjuggler.org">VRJuggler</ulink>, <ulink url="www.sgi.com">OpenGL
    Performer</ulink>, and <ulink url="www.kitware.com">Kitwareâ€™s
    Visualization ToolKit</ulink>. This visual interface, controlled by the UI
    and the computational engine, is a graphical representation of the
    simulation under review.</para>

    <para>The graphical engine is generalized to load data not only from
    comprehensive models, but also from other engineering sources, including
    results generated from the CMU Vision 21 planner software and other
    generalized datasets (e.g., experimental data from a test rig). The engine
    is also being modified to make use of the high level CORBA interface
    specifications used throughout the software framework. This interface
    allows the visualization engine to communicate directly with the component
    models, computational engine, and UI. To communicate with the graphical
    engine there is an external socket connection that is made between
    individual component models and the respective graphical objects. This
    connection allows large high fidelity datasets to be transferred to the
    graphical environment without interrupting the overall communication
    network.</para>

    <para>The graphical engine is also designed to allow graphics objects to
    be added to the virtual environment just like the objects are added in the
    GUI. This allows the graphical environment to be a direct representation
    of the system being designed by the engineer. In much the same way that
    the GUI auto-discovers the plugins for use by the engineer, the graphical
    engine also dynamically discovers plugins. Unlike the GUI, the graphical
    engine is controlled by the network string that is created by the GUI.
    This represents a significant capability since the graphical engine has no
    a priori knowledge of the system under interrogation.</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="../veimages/xplorerTri.jpg" />
      </imageobject>
    </mediaobject>
  </section>
</chapter>
