<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book id="vesuite_documentation">
  <title>VE-Suite Documentation</title>

  <preface id="vesuite_intro">
    <title>Introduction to VE-Suite</title>

    <para>VE-Suite is an open source toolkit that enables virtual engineering
    analysis and design. This open source framework includes distributed
    computing, platform independence, extensibility for component models,
    support for a hierarchy of component models, and comprehensive graphics
    capabilities, including support for immersive facilities.</para>

    <para>VE-Suite is a software package built upon <ulink
    url="http://www.vrjuggler.org">VRJuggler</ulink>, <ulink
    url="www.openscenegraph.org"><ulink
    url="http://www.openscenegraph.org/">Open Scene Graph</ulink></ulink>,
    <ulink url="http://www.vtk.org/">Kitware’s Visualization ToolKit
    (VTK)</ulink>, CORBA compliant libraries (<ulink
    url="http://www.cs.wustl.edu/%7Eschmidt/TAO.html">ACE/TAO</ulink>), and
    <ulink url="http://www.wxwidgets.org/">wxWidgets</ulink>. Initially
    developed as a CFD visualization package, VE-Suite has matured into a
    software toolset that enhances engineers' decision-making capabilities. By
    integrating computational results from multiple disciplines into a common
    framework, VE-Suite helps engineers analyze problems and make more
    complete solutions.</para>
  </preface>

  <part id="vesuite_users_guide">
    <title>Users Guide</title>

    <chapter id="vesuiteinstallsetup">
      <title>Installation and Setup</title>

      <para>Support is provided at the following locations: </para>

      <itemizedlist>
        <listitem>
          <para><ulink url="http://www.vesuite.org/forum/">VE-Suite
          Forums</ulink> - Users/developers can go here to access
          forums.</para>
        </listitem>

        <listitem>
          <para><ulink
          url="https://subversion.vrac.iastate.edu/Subversion/TSVEG/Bugzilla/">VE-Suite
          Bugzilla</ulink> - VE-Suite's interface for bug tracking. Users and
          developers can view and submit bugs.</para>
        </listitem>
      </itemizedlist>

      <para>Installation of VE-Suite is fairly straightforward. Visit the
      <ulink url="http://www.vesuite.org/download.php">Downloads</ulink>
      section and locate your operating system. Two installers, which guide
      you through the process of selecting various options, are provided for
      Windows. One installer, vesuite.x.x.x.exe, contains the core VE-Suite
      binaries and .dll files, while vesuite_deps.x.x.x.exe contains the
      binaries and .dll files of the dependencies for the current release of
      VE-Suite.</para>

      <para>On UNIX/Linux, two tar.gz files are provided for the core VE-Suite
      files and its dependencies. In either case, extracting the files creates
      two directory structures:</para>

      <para><code> VE-Suite.x.x.x/</code></para>

      <para><code> VE_Suite.x.x.x_Dependencies/</code></para>

      <section>
        <title>Windows Installation</title>

        <para>Installing VE-Suite and its dependencies follows the same
        procedure as other installations. You'll choose which components to
        install, their locations, their Start Menu folder, and whether to have
        a desktop icon.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/windowsinstall.png" />
          </imageobject>
        </mediaobject>

        <para>Of particular note is which components to install. In large
        setups, certain computers will run the NameServer while others will
        handle the Conductor and Xplorer. If you only plan to run it on a
        single desktop, you'll want to install everything. Just leave all the
        checkboxes checked.</para>

        <para>Go through the same process for VE-Suite's dependencies.</para>
      </section>

      <section id="unix_installation">
        <title>UNIX Installation</title>

        <para>On Unix, the installers are compressed tar.gz files. You can
        open them using these commands:</para>

        <itemizedlist>
          <listitem>
            <para>Using GNU tar:</para>

            <para><code>gtar xvzf vesuite_x.x.x_RHEL_4.tar.gz </code></para>

            <para><code>gtar xvzf
            vesuite_depsx.x.x_RHEL_4.tar.gz</code></para>
          </listitem>

          <listitem>
            <para>Using gzip:</para>

            <para><code>gunzip &lt; vesuite_x.x.x_RHEL_4.tar.gz | tar xvf
            -</code></para>

            <para><code>gunzip &lt; vesuite_depsx.x.x_RHEL_4.tar.gz | tar xvf
            -</code></para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">NOTE</emphasis>: These examples use
        vesuite_x.x.x as a general placeholder for any version of VE-Suite. Be
        sure to change the version number to the specific version you are
        installing.</para>
      </section>

      <section id="setting_runtime_environment">
        <title>Setting the Runtime Environment</title>

        <para>In previous versions, VE-Suite's runtime environment was set
        through text scripts. Now it uses VE-Launcher to set up the
        environment. Most of it is automated, but you need to be aware of two
        important variables it sets: VE-Suite's directory and VE-Suite's
        Dependencies directory.</para>

        <para>VE-Launcher automatically determines VE-Suite's directory from
        the current working directory. Moving the Launcher out of VE-Suite's
        directory or starting it from a different directory will pass the
        wrong value to VE-Suite, causing errors.</para>

        <para>The Dependencies directory is the only variable you need to set
        manually. The first time you start VE-Launcher, you will be asked to
        find the Dependencies directory. On Windows, it is the
        VE_Suite.x.x.x_Dependencies folder.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/runtimeenv1.jpg" />
          </imageobject>
        </mediaobject>

        <para>On Unix/Linux, the dependencies folder holds one folder for each
        system supported. You need to choose your system's corresponding
        folder as the Dependencies folder.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/runtimeenv2.jpg" />
          </imageobject>
        </mediaobject>

        <para>If you're upgrading from an earlier version of VE-Suite, you can
        also reset the Dependencies directory by clicking the Change
        Dependencies Folder button in VE-Launcher.</para>
      </section>
    </chapter>

    <chapter id="launcher">
      <title>Launcher</title>

      <section id="launcher_intro">
        <title>Introduction</title>

        <para>Starting VE-Suite was simplified with the release of version
        1.0.0 via VE-Launcher. VE-Launcher is a quick, easy way to launch any
        configuration of VE-Suite. It helps you save your configuration,
        choose which programs to run, and launch them without entering text
        commands. Even with all of the options and configurations available,
        choosing the one you need can still take some work. Here, we explain
        how to use the Launcher and provide an example of setting it
        up.</para>
      </section>

      <section id="launcher_basics">
        <title>The Basics</title>

        <para>VE-Launcher is started by double-clicking VE-Suite's desktop
        icon, double-clicking the velauncher program in VE-Suite's folder, or
        typing <code>python velauncher.py</code> into a Unix terminal. The
        first time you run VE-Launcher, you will be asked to choose VE-Suite's
        Dependencies folder. On Windows, this folder is named
        VE_Suite.x.x.x_Dependencies.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics1.jpg" />
          </imageobject>
        </mediaobject>

        <para>On Unix, the Dependencies folder contains folders for each
        system; you need to choose the one corresponding to your
        system.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Once VE-Launcher confirms that you have chosen the dependencies
        folder, you will be shown the main window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics3.jpg" />
          </imageobject>
        </mediaobject>

        <itemizedlist>
          <listitem>
            <para>Working Directory: Ensure that the location of the directory
            containing the files you want to load is entered. </para>
          </listitem>

          <listitem>
            <para>Computation Engine (CE) Name and Port: Enter the computer
            and port you want to connect to.</para>
          </listitem>

          <listitem>
            <para>Launch Mode: Select which mode you would like to launch
            VE-Suite in. You have six options, including custom mode:</para>

            <orderedlist>
              <listitem>
                <para>Desktop mode launches Conductor, Name Server, and
                Xplorer on your machine in Desktop mode.</para>
              </listitem>

              <listitem>
                <para>Tablet mode launches Conductor. It is designed for use
                on tablets.</para>
              </listitem>

              <listitem>
                <para>Computation mode launches the Name Server. It is
                designed for use on computational engines.</para>
              </listitem>

              <listitem>
                <para>Visualization mode launches Xplorer. It is designed for
                viewing projects. It uses Custom's settings to choose VR
                Juggler's configuration and which type of Xplorer to
                run.</para>
              </listitem>

              <listitem>
                <para>As of 1.0.2: Shell mode lets the user work in a new
                shell with the VE-Suite environment set up. If you choose to
                launch in Shell mode, it will ask you whether you want to set
                up this shell for VE-Builder. If you do, it will add the
                VE-Builder directory you choose to the path. On Windows,
                launching Shell creates the shell in a window; simply close it
                to exit. On Unix, launching Shell makes the shell a child of
                your current terminal; type in "exit" to return to your
                original shell.</para>
              </listitem>

              <listitem>
                <para>Custom mode lets the user choose their own
                settings.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </itemizedlist>

        <para>The settings for every mode can be viewed and changed by
        clicking the Mode Settings button. Once you finish choosing the
        settings, click <guibutton>Launch VE-Suite</guibutton> to close
        VE-Launcher and start VE-Suite.</para>

        <para>As of 1.0.2, the main window has a menu bar with the following
        menus:</para>

        <itemizedlist>
          <listitem>
            <para>File menu:</para>

            <itemizedlist>
              <listitem>
                <para>Open...: Pick a .ves or script shell file for
                launch.</para>
              </listitem>

              <listitem>
                <para>Close Files: Remove any .ves or script shell files from
                the launch.</para>
              </listitem>

              <listitem>
                <para>Quit.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Configurations menu:</para>

            <itemizedlist>
              <listitem>
                <para>Load: Load a previously-saved configuration.</para>
              </listitem>

              <listitem>
                <para>Save: Save the current configuration.</para>
              </listitem>

              <listitem>
                <para>Delete: Delete a previously-saved configuration.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics4.jpg" />
          </imageobject>
        </mediaobject>

        <itemizedlist>
          <listitem>
            <para>Options menu:</para>

            <itemizedlist>
              <listitem>
                <para>Choose Dependencies: Change the Dependencies
                directory.</para>
              </listitem>

              <listitem>
                <para>Choose Builder Folder: Change the Builder
                directory.</para>
              </listitem>

              <listitem>
                <para>Debug Level: Choose the debug levels passed to
                VE-Suite.</para>
              </listitem>

              <listitem>
                <para>Cluster Wait Times: Customize the time VE-Suite waits
                between starting the master node and its slaves.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section id="launcher_mode_settings">
        <title>Mode Settings</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchermodesettings1.jpg" />
          </imageobject>
        </mediaobject>

        <para>You use the Mode Settings window to view and change settings.
        The Desktop, Tablet, and Computation modes only let you view their
        settings, while Visualization and Custom modes let you change some of
        them. Choices are faded out if you can't change them or if changing
        them wouldn't do anything. (For example, you can't choose which type
        of Xplorer to run if you're not running Xplorer.)</para>

        <para>Options you can set include:</para>

        <itemizedlist>
          <listitem>
            <para>Which VR Juggler configuration to use from the pulldown
            list. You can edit the list by clicking Edit Configuration List.
            We will go into the List in more detail below.</para>
          </listitem>

          <listitem>
            <para>Which programs to run. You can choose to run Name Server,
            Conductor, and Xplorer. If you don't select any of them, VE-Suite
            won't launch because it won't do anything without a program to
            launch.</para>
          </listitem>

          <listitem>
            <para>Whether to run Conductor and Xplorer in Desktop Mode. This
            checkbox is disabled if you're launching neither Conductor nor
            Xplorer.</para>
          </listitem>

          <listitem>
            <para>Which type of Xplorer to run. OpenSceneGraph and OSG
            Patented will work for most projects, while OSG Patented Cluster
            is made for use on clustered computers. This radio list is
            disabled if you aren't launching Xplorer.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">Edit Configuration List</emphasis></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchermodesettings2.jpg" />
          </imageobject>
        </mediaobject>

        <para>VE-Suite has over two dozen configuration files available. To
        help you keep track of them, VE-Launcher provides you with a
        configuration list that allows you to add, rename, and delete entries.
        The path to the currently selected entry is listed below, so you can
        tell which name stands for which file.</para>

        <para>When you add a new configuration to the list, its initial name
        is its file name. You'll want to rename it to something more
        descriptive.</para>
      </section>

      <section id="launcher_unix_clusters">
        <title>UNIX Clusters</title>

        <para>VE-Launcher versions 1.0.2+ have extra features for
        automatically starting up VE-Xplorer on other computers in a
        cluster.</para>

        <para>To use the cluster functions of VE-Launcher on Unix, your
        cluster must satisfy these requirements:</para>

        <orderedlist>
          <listitem>
            <para>The path to VE-Suite, its dependencies, and the working
            directory are the same on every cluster node.</para>
          </listitem>

          <listitem>
            <para>VE-Launcher's user has permission to <ulink
            url="http://www.employees.org/%7Esatch/ssh/faq/ssh-faq.html">ssh</ulink>
            to each node.</para>
          </listitem>

          <listitem>
            <para>The user has manually sshed into each node and authenticated
            its name.</para>
          </listitem>
        </orderedlist>

        <para>The last requirement needs some explanation. The first time you
        ssh into an unknown host, you need to manually authenticate its name.
        If it isn't authenticated and VE-Launcher tries to connect to it, it
        will hang the program. Therefore, you must manually ssh into each node
        on the cluster (including your current computer) and authenticate it
        before you can start the cluster using VE-Launcher. You must use the
        exact name you'll use in VE-Launcher; ssh treats partially-qualified
        (e.g., francis) and fully-qualified (e.g., francis.iastate.edu) names
        as separate users. Once you authenticate the other nodes, the
        authentication stays in your user profile permentantly.</para>

        <para>Once you have authenticated all nodes, you can run the cluster
        from VE-Launcher:</para>

        <orderedlist>
          <listitem>
            <para>If you're running NameServer or Conductor on a certain node,
            open VE-Launcher from that node. (VE-Launcher runs NameServer and
            Conductor from the current computer.)</para>
          </listitem>

          <listitem>
            <para>Set the settings. When you select the Xplorer type OSG
            Patented Cluster, the <guibutton>Set Cluster Computers</guibutton>
            button will be enabled.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/unixcluster1.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Click <guibutton>Set Cluster Computers</guibutton>. A window
            will pop up showing the master and slaves listed. Put the master's
            name in, then add each slave's name to the list. Click
            <guibutton>OK</guibutton> when you're done.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/unixcluster2.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Launch VE-Suite by clicking <guibutton>Launch</guibutton>.
            The cluster computers will start up VE-Suite.</para>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">NOTE:</emphasis> There is a slight delay
        between each node launched because simultaneous launching caused
        erratic behavior in the cluster. The delay can be changed through the
        Options-&gt;Cluster Wait Times menu. If you encounter problems with
        sync or unconnected nodes using VE-Launcher, try lengthening the
        delays. If launching the cluster is taking too long, try shortening
        them.</para>
      </section>

      <section id="launcher_windows_clusters">
        <title>Windows Clusters</title>

        <para>VE-Launcher versions 1.0.2+ can start VE-Suite across a Windows
        cluster through <ulink
        url="http://www.sysinternals.com/Utilities/PsExec.html">PsExec</ulink>.</para>

        <para>To use the cluster functions of VE-Launcher on Unix, your
        cluster must satisfy these requirements:</para>

        <orderedlist>
          <listitem>
            <para>The path to VE-Suite, its dependencies, and the working
            directory are the same on every cluster node.</para>
          </listitem>

          <listitem>
            <para><ulink
            url="http://www.sysinternals.com/Utilities/PsExec.html">PsExec</ulink>
            is installed on the computer you're running VE-Launcher on.</para>
          </listitem>
        </orderedlist>

        <para>To launch the cluster:</para>

        <orderedlist>
          <listitem>
            <para>If you're running NameServer or Conductor on a certain
            computer, open VE-Launcher from that computer. (VE-Launcher runs
            NameServer and Conductor from the current computer.)</para>
          </listitem>

          <listitem>
            <para>Select Custom mode and set your settings as usual. When you
            choose which Xplorer Type to run, select OSG Patented Cluster.
            This enables the <guibutton>Set Cluster Computers</guibutton>
            button.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/windowscluster1.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Click <emphasis role="bold">Set Cluster
            Computers</emphasis>. A window will pop up showing the master and
            slaves listed, plus an optional username field. Put the master's
            name in, then add each slave's name to the list.</para>

            <para>Some clusters might require you to connect as a certain
            user; if so, just enter your username into the User Name field.
            The username's domain may need to be included as well, depending
            on your cluster's setup. If you pass your username, you will have
            to manually enter your password in each Psexec window when it
            launches; VE-Launcher doesn't send passwords for security
            reasons.</para>

            <para>Click <guibutton>OK</guibutton> when you're done.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/windowscluster2.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Launch VE-Suite by clicking <guibutton>Launch</guibutton>.
            The cluster computers will start up VE-Suite.</para>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">NOTE:</emphasis> There is a slight delay
        between each node launched because simultaneous launching can cause
        erratic behavior in the cluster. The delay can be changed through the
        Options-&gt;Cluster Wait Times menu. If you encounter problems with
        sync or unconnected nodes using VE-Launcher, try lengthening the
        delays. If it's taking too long to launch the cluster, try shortening
        them.</para>

        <para><emphasis role="bold">The cluster template: </emphasis>If your
        cluster needs extra code to launch (for example, a net use command to
        set up a remote drive), you can enter the code into the
        clusterTemplate.txt file. Any terminal code in the clusterTemplate.txt
        file will run on the cluster's other computers before Xplorer is
        launched. Please read the comments in clusterTemplate.txt for more
        details.</para>

        <para><emphasis role="bold">NOTE: </emphasis>There is a bug in
        VE-Launcher 1.0.2 where the cluster template code isn't separated from
        the standard code by a line break. Be sure to insert a line break
        after the last line of code in the template to avoid errors from a
        merged line.</para>
      </section>

      <section id="launcher_example">
        <title>Example</title>

        <para>John Doe wants to set up VE-Suite to look at a virtual power
        plant design. He needs to set it in Visualization mode, using the VR
        Juggler configuration "standalone" and the Open Scene Graph Xplorer.
        It also has to connect to computer kiwi on port 1239.</para>

        <para>When he starts VE-Launcher, he sees this:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample1.jpg" />
          </imageobject>
        </mediaobject>

        <para>First he types the path to the plant design data folder in the
        Working Directory field. (He could also use the <guibutton>Choose
        Working Directory </guibutton>button to find it.)</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample2.jpg" />
          </imageobject>
        </mediaobject>

        <para>He needs to change the computational engine (CE) name, but he
        can't because the Launcher is currently in Desktop mode, which
        automatically sets the CE name to "localhost". To unlock the CE name,
        he switches to Visualization mode. (Any mode besides Desktop will let
        you change the CE name.)</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample3.jpg" />
          </imageobject>
        </mediaobject>

        <para>Switching modes unlocks the CE name and sets it to the last
        user-inputted value. Now John can change the CE name and port.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample4.jpg" />
          </imageobject>
        </mediaobject>

        <para>To finish setting up the Launcher, John must change the mode's
        settings. He clicks the <guibutton>Mode Settings</guibutton> button to
        bring up the Settings window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample5.jpg" />
          </imageobject>
        </mediaobject>

        <para>Visualization mode sets most of the options, and Open Scene
        Graph is already selected. That leaves changing the Xplorer
        configuration. However, the configuration he needs isn't on the list
        yet. John clicks <guibutton>Edit Configuration
        List</guibutton>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample6.jpg" />
          </imageobject>
        </mediaobject>

        <para>Because it isn't on the list, he adds it.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample7.jpg" />
          </imageobject>
        </mediaobject>

        <para>It is automatically added to the list as standalone. John
        renames it "Plant Design" so he can remember which project it is
        for.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample8.jpg" />
          </imageobject>
        </mediaobject>

        <para>Now that he's done editing the list, John exits the Xplorer
        Configuration window. Because he had Plant Design selected when he
        left, it is automatically set as his current configuration file. With
        everything set as he wanted, John can now click <guibutton>Launch
        VE-Suite</guibutton> to look at the design.</para>
      </section>
    </chapter>

    <chapter id="running_vesuite">
      <title>Running VE-Suite</title>

      <para>VE-Suite contains three programs you can run: the Naming Service,
      which allows you to connect to VE-CE; VE-Conductor, which provides the
      controls; and VE-Xplorer, which displays the scene. All three can be
      launched from VE-Launcher. The final step is connecting VE-Conductor to
      the naming server. This lets you process and manipulate the chosen
      dataset.</para>

      <section id="starting_vesuite">
        <title>Starting VE-Suite</title>

        <para>VE-Launcher is the gateway to VE-Suite. To open VE-Launcher,
        Windows users should double-click the VE-Suite desktop icon or
        velauncher.exe in the VE_Suite folder. Unix/Linux users should go into
        the VE_Suite folder and enter:</para>

        <para><code> python velauncher.py</code></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/startingvesuite1.jpg" />
          </imageobject>
        </mediaobject>

        <para>If this is your first time running VE-Launcher, you will be
        asked for the Dependencies folder (see <link
        linkend="setting_runtime_environment">Setting the Runtime
        Environment</link>) before being shown the main window.</para>

        <para>Launcher has some advanced commands, but we can ignore them for
        now. Make sure Desktop mode is selected and click
        <guibutton>Launch</guibutton>. VE-Launcher will launch the Naming
        Service, VE-Conductor, and VE-Xplorer in Desktop mode.</para>

        <para>If you want to learn more about how to use VE-Launcher, read the
        <link linkend="launcher">VE-Launcher section</link> of this
        guide.</para>
      </section>

      <section id="loading_data_and_connecting">
        <title>Loading Data and Connecting</title>

        <para>VE-Suite loads objects through plugins. Here we will show you
        how to load a geometry file through a plugin; other data files may be
        loaded in the same manner.</para>

        <para>You set up plugins through the "Available Objects" window on the
        right side of the screen. To create a new plugin, double-click the red
        "Available Modules" folder, then double-click "DefaultPlugin". A gray
        box will appear. Right-click on this box to access the plugin's menu.
        Select the "Geometry Config" option as shown.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata1.jpg" />
          </imageobject>
        </mediaobject>

        <para>A new window will open on the design canvas, the CADTree
        Manager. This holds the objects you insert into your plugin. To select
        a geometry file, right-click on the "Model_Geometry" folder in the
        canvas and select Add Node-&gt;Load CAD file.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Another window will appear. Choose the file's type, select the
        file, then click <guibutton>Open</guibutton>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata3.jpg" />
          </imageobject>
        </mediaobject>

        <para>The program will ask you to name the object you loaded, then
        insert it into the plugin. Add any other objects you want to include
        in the same way. Once this is completed, click
        <guibutton>Close</guibutton> on the design canvas.</para>

        <para>The information for the plugin's node needs to be loaded to the
        rest of VE-Suite. This is done by choosing "Submit Job" from the
        Connection menu.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata4.jpg" />
          </imageobject>
        </mediaobject>

        <para>The starting logo in VE-Xplorer should be replaced by the
        objects in the plugins you submitted.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata5.jpg" />
          </imageobject>
        </mediaobject>

        <para>If the object is not initially found in the VE-Xplorer window,
        it may be outside the viewing region. If so, hold down the right mouse
        button and drag down in the VE-Xplorer window to pull back the camera;
        continue doing so until you can see the scene.</para>
      </section>

      <section id="navigation">
        <title>Navigation</title>

        <para>There are two ways to manipulate VE-Suite's view using just the
        mouse: dragging in the Xplorer window itself or using the Navigation
        Pane.</para>

        <section id="xplorerwindow">
          <title>Xplorer Window</title>

          <para>If you have a 3-button mouse, you can do every translation and
          rotation within the Xplorer window itself.</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/navigation1.gif" />
            </imageobject>
          </mediaobject>

          <para>To rotate the scene, drag along the screen while holding the
          left button. To rotate along the X- and Z-axes, drag in the center
          of the screen. To rotate along the Y-axis, drag along the border of
          the screen.</para>

          <para>The right mouse button handles Y-axis translations. Hold the
          right button and drag the mouse up or down to push the scene away or
          pull it closer.</para>

          <para>The mouse wheel button handles the other translations. Hold it
          down to drag the scene left, right, up, or down across the
          screen.</para>
        </section>

        <section id="navigatio_npane">
          <title>Navigation Pane</title>

          <para>To open the Navigation pane, select "Navigation Pane" from the
          VE-Xplorer menu:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/navigation2.jpg" />
            </imageobject>
          </mediaobject>

          <para>The Navigation Pane will appear below:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/navigation3.jpg" />
            </imageobject>
          </mediaobject>

          <para>Experiment with the movement buttons (the ones with arrows on
          them) to see how they change the scene. Note that they move the
          camera, not the object; clicking the left X-axis button, for
          example, will move the camera left, making the object shift
          right.</para>

          <para>Most of the other controls modify how the movement buttons
          act:</para>

          <itemizedlist>
            <listitem>
              <para>The <emphasis role="bold">Step Size sliders</emphasis>
              control the speed of translations and rotations. The farther to
              the right they are, the faster translations and rotations
              occur.</para>
            </listitem>

            <listitem>
              <para><emphasis role="bold">Rotate About Users Head
              </emphasis>controls how the camera reacts to Yaw Rotation
              commands. If it is checked, the camera rotates in place. If it
              is not, the camera rotates around the environment center, like
              the roll and pitch rotations.</para>
            </listitem>

            <listitem>
              <para><guibutton>Reset Nav Position</guibutton> resets the
              camera to its initial position.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section id="quitting_vesuite">
        <title>Quitting VE-Suite</title>

        <para>Ending your VE-Suite session takes two steps:</para>

        <orderedlist>
          <listitem>
            <para>Select "Quit" from VE-Conductor's File menu. This quits
            Conductor and Xplorer.</para>
          </listitem>

          <listitem>
            <para>Select the shell window running the Name Server. Close it or
            press Ctrl-C to break the program.</para>
          </listitem>
        </orderedlist>
      </section>
    </chapter>

    <chapter id="visualizations">
      <title>Visualizations</title>

      <para>This chapter describes how to make visualizations using the
      VE-Suite toolkit and a sample dataset. If you want to follow this
      example, download and unzip the sample PrISUm car dataset: <ulink
      url="http://www.vesuite.org/File/PrISUm.zip">PrISUm.zip</ulink>
      (138MB)</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="veimages/visualization1.jpg" />
        </imageobject>
      </mediaobject>

      <section id="visualization_setup">
        <title>Setup</title>

        <para>Visualizations require two files: a geometry config file and a
        dataset file. Both have properties, such as scale and translation,
        that can be modified to ensure they line up.</para>

        <para>First, open VE-Launcher and set the working directory to the
        PrISUm folder. Next, open VE-Suite in Desktop mode from VE-Launcher.
        Load the PrISUmblend.obj CAD file, but don't close the CADTree Manager
        window yet. (See Chapter 2.2)</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Right-click on the Model_Geometry folder again and choose
        Properties. A CAD Properties window will pop up. This can be used to
        change PrISUm's properties, but you must know what to change them
        to.</para>

        <para>Open the PrISUm folder from the desktop and look for the
        vrxpr.param file. This file contains parameter information for PrISUm,
        which we'll enter into the Properties window. Open vrxpr.param using a
        text editor, look for the 3x3 block underneath the number 9, and enter
        the values into the Properties window. <emphasis
        role="bold">NOTE:</emphasis> The rows go in a different order in the
        Properties window than in the .param file:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Once the parameters are entered, close the CAD Properties and
        CADTree Manager window. Now right-click on the gray plugin box again
        and chose Data Set Config. Add the dataset to it.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup3.jpg" />
          </imageobject>
        </mediaobject>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup4.jpg" />
          </imageobject>
        </mediaobject>

        <para>First, click <guibutton>Add Dataset </guibutton>to name your
        dataset configuration. Then click <emphasis
        role="bold">Open</emphasis> under DataSet Filename and choose
        outFile3.vtk file as your dataset. You don't need to change any other
        setting for PrISUm, so just click <guibutton>Load</guibutton> to load
        the dataset and exit the window.</para>

        <para>Once that is done, choose Submit Job from the Connection menu to
        display the PrISUm car. Use the navigation pane to adjust the view
        until you get a good view of it.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup5.jpg" />
          </imageobject>
        </mediaobject>
      </section>

      <section id="visualization_scalar_planes">
        <title>Scalar Planes</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Now that the plugin is set up, we can use the Visualization
        interface to show scalar planes like the one pictured above.
        Visualization not only lets you access scalar contours, but vector
        planes, isosurfaces, and more.</para>

        <para>To bring up the Visualization interface, right-click on the
        plugin to access the menu and select Visualization. This window will
        appear:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Click on the <guibutton>Scalar Contours</guibutton> button (the
        leftmost icon) to bring up the Scalar Contours interface.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes3.jpg" />
          </imageobject>
        </mediaobject>

        <para>Notice that you can choose the plane's orientation and position.
        For now, set the Direction to Y and the plane's position to 50 and
        click <guibutton>Add Plane</guibutton>. This should appear on your
        screen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes4.jpg" />
          </imageobject>
        </mediaobject>

        <para>Once you're done looking at the contour planes, you can remove
        them from the screen by clicking <guibutton>Clear All </guibutton>on
        the Visualization interface. This will clear any Visualization
        features from VE-Xplorer.</para>
      </section>

      <section id="visualization_vector_planes">
        <title>Vector Planes</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Showing vector planes is almost exactly like showing scalar
        planes. First, open up the Visualization interface again by
        right-clicking on the plugin and selecting Visualization.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes2.jpg" />
          </imageobject>
        </mediaobject>

        <para>This time, click on the <guibutton>Vector</guibutton> button
        (the 2nd-to-left icon) to open the Vector Contour window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes3.jpg" />
          </imageobject>
        </mediaobject>

        <para>The Vector Contour window is very similar to the Scalar Contour
        window. This time, set the Direction to Z and the plane's position to
        20 and click <guibutton>Add Plane</guibutton>. This should appear on
        your screen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes4.jpg" />
          </imageobject>
        </mediaobject>

        <para>Just like the scalar plane, you can remove the vector plane by
        clicking <guibutton>Clear All</guibutton> on the Visualization
        interface.</para>
      </section>

      <section id="visualization_isosurfaces">
        <title>Isosurfaces</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces1.jpg" />
          </imageobject>
        </mediaobject>

        <para>To generate an isosurface, go back to the Visualization
        interface (right-click on the plugin, select Visualization).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Before you can open the Isosurfaces window, you'll also need to
        choose a scalar or vector file. Choose scalars under Scalars and click
        the <guibutton>Isosurfaces</guibutton> button (the 3rd-from-right
        icon) to open the Isosurfaces window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces3.jpg" />
          </imageobject>
        </mediaobject>

        <para>The Isosurfaces window only has one setting. Set the Isosurface
        pressure to 50 and click <guibutton>Compute Isosurface</guibutton>.
        This should appear on your screen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces4.jpg" />
          </imageobject>
        </mediaobject>

        <para>Exit Visualization and examine the isosurface by using the mouse
        or the Navigation pane. Once you're done, reenter Visualization and
        click <guibutton>Clear All</guibutton>.</para>
      </section>
    </chapter>

    <chapter id="vebuilder">
      <title>VE-Builder</title>

      <section id="vebuilder_intro">
        <title>Introduction</title>

        <para>VE-Builder is a set of tools for modifying three-dimensional
        data files for VE-Suite. Here is a list of functions we provide
        documentation for:</para>

        <para><link linkend="???"><link linkend="importing_files">Importing
        Files</link></link> </para>

        <para><link linkend="importing_from_starcd">Importing from
        StarCD</link> </para>

        <para><link linkend="importing_from_fluent">Importing from Fluent
        (.avs)</link></para>

        <para><link linkend="creating_preprocess_data">Creating Preprocessed
        Data</link></para>

        <para><link linkend="creating_texture_based_datasets">Creating
        Texture-Based Datasets</link></para>
      </section>

      <section id="launching_vebuilder">
        <title>Launching VE-Builder</title>

        <para>To run VE-Builder, you need a VE-Suite shell environment.
        Therefore, to run VE-Builder tools from VE-Launcher, select the Shell
        mode. A popup will appear, asking if you want to configure this shell
        for VE-Builder:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchingbuilder1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Select <guibutton>Yes</guibutton>. If you haven't chosen the
        VE-Builder directory before, you will be asked to choose it.
        Otherwise, a shell with the VE-Builder environment will be shown. If
        you want to change the VE-Builder directory, choose Change Builder
        Folder from under the Options menu and select the VE_BuilderTolls
        directory.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchingbuilder2.jpg" />
          </imageobject>
        </mediaobject>
      </section>

      <section id="importing_files">
        <title>Importing Files</title>

        <para>The loaderToVtkd program transforms prepared three-dimensional
        data files from other programs into VE-Suite files. First, prepare the
        environment for it by launching a Builder Shell from <link
        linkend="launching_vebuilder">VE-Launcher</link>. Then you can use
        loaderToVtkd to import files into VE-Suite formats. The general syntax
        of the program is:</para>

        <para><code> loaderToVtkd -singleFile [input filename] -loader [loader
        type]</code></para>

        <para><code> -o [full path to the output directory] -w file
        </code></para>

        <para>(The name of the output file isn't set in the command line
        because there is currently a bug renaming the file. This will be fixed
        later.)</para>

        <para>To see loaderToVtkd's options, type in:</para>

        <para><code> loaderToVtkd</code></para>

        <para>loaderToVtkd supports the following loader types:</para>

        <para><itemizedlist>
            <listitem>
              <para>REI (BANFDB)</para>
            </listitem>

            <listitem>
              <para>AVS (avs)</para>
            </listitem>

            <listitem>
              <para>Dicom (dcm)</para>
            </listitem>

            <listitem>
              <para>EnSight (ens)</para>
            </listitem>

            <listitem>
              <para>MFIX (mfix)</para>
            </listitem>

            <listitem>
              <para>StarCD (star)</para>
            </listitem>
          </itemizedlist>It also supports Plot3D, but with this syntax:</para>

        <para><code> loaderToVtkd -geometryFileXYZ [input filename] -dataFileQ
        [input filename2] </code></para>

        <para><code> -o [full path to the output directory] -multiGrid Flag
        [0:1] -iblankFlag [0:1] -numberofDimensions [0:1] </code></para>

        <para><code> -outFileName [output file] -loader xyz -w file
        </code></para>

        <para>We also have detailed instructions for preparing and importing
        data files from these programs:</para>

        <para><link linkend="importing_from_starcd">StarCD</link></para>

        <para><link linkend="importing_from_fluent">Fluent (AVS)</link></para>
      </section>

      <section id="importing_from_starcd">
        <title>Importing from StarCD</title>

        <section id="preparing_starcd_files">
          <title>Preparing the StarCD Files</title>

          <para>First, you need star.cel, star.vrt, and a star.usr files from
          StarCD. If you need help getting them from StarCD, look at the
          instructions <link
          linkend="building_files_from_starcd">here</link>.</para>

          <para>Next, you need to make a star.param file to point to the
          star.cel, star.vrt, and star.usr files. Save our template (<ulink
          url="http://www.vesuite.org/File/star.param">star.param</ulink>) to
          your working directory and follow the instructions below to modify
          it for your data:</para>

          <para><code> STARCEL=/your_directory/star.cel // a *.cel file is
          required </code></para>

          <para><code> STARVRT=/your_directory/star.vrt // a *.vrt file is
          required </code></para>

          <para><code> STARUSR=/your_directory/star.usr // a *.usr file is
          required</code></para>

          <para>Set these to point to your .cel, .vrt, and .usr files.</para>

          <para><code> VECTORNAME=Velocity // the columns of the *.usr file
          must be labeled </code></para>

          <para><code> SCALARNAME=scalar1 // the columns of the *.usr file
          must be labeled </code></para>

          <para><code> SCALARNAME=scalar2 // the columns of the *.usr file
          must be labeled </code></para>

          <para><code> SCALARNAME=scalar3 // the columns of the *.usr file
          must be labeled</code></para>

          <para>Change these lines to their respective scalars.</para>

          <para><code> SCALEINDEX=1 // optional: uses integer indices defined
          in translateToVtk.cpp to set scale factor </code></para>

          <para>Enter an integer option on the SCALEINDEX:</para>

          <itemizedlist>
            <listitem>
              <para>0: No scale, corresponding to a scale of 1.0</para>
            </listitem>

            <listitem>
              <para>1: Custom scale, indicating that the SCALEFACTOR tag will
              be used to specify a scale factor</para>
            </listitem>

            <listitem>
              <para>2: Meters to feet, corresponding to a scale factor of
              3.28</para>
            </listitem>

            <listitem>
              <para>3: Millimeters to feet, corresponding to a scale factor of
              3.28e-3</para>
            </listitem>

            <listitem>
              <para>4: Inches to feet, corresponding to a scale factor of
              1.0/12.0</para>
            </listitem>

            <listitem>
              <para>5: Meters (1:12) scale to feet, corresponding to a scale
              factor of 12.0*3.28</para>
            </listitem>
          </itemizedlist>

          <para><code> SCALEFACTOR=.083333333 // optional: the scale factor
          (default = 1, unless SCALEINDEX &gt;1)</code></para>

          <para>VR space is always in feet, so the scale factor tag must be in
          feet. If you chose a SCALEINDEX of 0 or 1, comment out this
          line.</para>

          <para><code> WRITEOPTION=1 // optional: 0=let vtk write the
          file(default), 1=directly write ascii to disk </code></para>

          <para>The Writeoption is no longer needed. Set it to 0 or remove
          it.</para>
        </section>

        <section id="conversion_to_vtu">
          <title>Conversion to a .VTU File</title>

          <para>Start up a Builder Shell from <link
          linkend="launching_vebuilder">VE-Launcher</link>. Be sure to set the
          working directory to the star.param's directory. Then enter the
          following code:</para>

          <para><code> loaderToVtkd -singleFile star.param -loader star -o
          [full path to the output directory] -w file</code></para>

          <para><emphasis role="bold">NOTE: </emphasis>There is currently a
          bug for renaming the file, so don't set it in the command line or
          the star.param file. This will be fixed later. After the code
          executes, it will dump a .vtu file of the data in the directory you
          specified.</para>
        </section>
      </section>

      <section id="importing_from_fluent">
        <title>Importing from Fluent (AVS)</title>

        <para>You will need to write out an .avs file for the post-processed
        data from Fluent. Place it into your working directory. Open a Builder
        Shell from <link linkend="launching_vebuilder">VE-Launcher</link>. Be
        sure to set the working directory to the avs file's directory. You can
        then convert it with this command:</para>

        <para><code> loaderToVtkd –singleFile [AVS filename] –loader avs –o
        [working directory] –w file</code></para>
      </section>

      <section id="creating_preprocess_data">
        <title>Creating Preprocessed Data</title>

        <para>You will need a .vtu file to create preprocessed data. Start a
        Builder Shell from <link
        linkend="launching_vebuilder">VE-Launcher</link>. Be sure to set the
        working directory to the .vtu file's directory. Verify that there is a
        directory called POST_DATA in the .vtu file's directory. If there is
        not, create one. Once it's ready, type in:</para>

        <para><code> preprocessor </code></para>

        <para>The first prompt will ask for a filename. Type in the .vtu's
        filename. The second prompt will ask for a directory to dump the data
        into. Type in the full path to the directory you want the preprocessed
        data in. The program will then ask you what you want to extract; once
        you finish making your choices, it will execute and produce your
        preprocessed data.</para>
      </section>

      <section id="creating_texture_based_datasets">
        <title>Creating Texture-Based Datasets</title>

        <para>Launch a Builder Shell from <link
        linkend="launching_vebuilder">VE-Launcher</link> and enter the
        following:</para>

        <para><code> vtkTo3DTexture</code></para>

        <para>This will launch the translator interface:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/creatingtexturebased1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Select the desired parameters from the GUI and click
        <guibutton>Translate</guibutton>. Input parameters include:</para>

        <para><itemizedlist>
            <listitem>
              <para>Input directory: Directory containing the input vtk
              dataset files.</para>
            </listitem>

            <listitem>
              <para>Output directory: Directory to write out the texture data
              and the texture description files.</para>
            </listitem>

            <listitem>
              <para>Texture Dimension: The resolution (~sampling rate) of the
              output textures.</para>
            </listitem>

            <listitem>
              <para>Grid type: Input vtk datasets' grid structure.</para>
            </listitem>
          </itemizedlist>A progress dialog will appear as the input vtk files
        are translated to three-dimensional texture data files that are
        useable in VE-Suite.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/creatingtexturebased2.jpg" />
          </imageobject>
        </mediaobject>

        <para><emphasis role="bold">Batch Mode</emphasis></para>

        <para>The translator can also be run in a "batch" mode. To run in
        batch mode, enter this on the command line:</para>

        <para><code> vtkTo3DTexture -o
        /home/users/mcdoe/LTN/3D_Jets_Test/jets_vti </code></para>

        <para><code> -x 32 -y 64 -z 32
        /home/users/mcdoe/LTN/3D_Jets_Test/Jets_Data</code></para>

        <para>where:</para>

        <itemizedlist>
          <listitem>
            <para>-o specifies the output directory for the 3d vti texture
            files</para>
          </listitem>

          <listitem>
            <para>-x is the x resolution for the texture</para>
          </listitem>

          <listitem>
            <para>-y is the y resolution for the texture</para>
          </listitem>

          <listitem>
            <para>-z is the z resolution for the texture</para>
          </listitem>

          <listitem>
            <para>The last argument is the data input directory for vt(u,k,s)
            files.</para>
          </listitem>
        </itemizedlist>

        <para>The batch mode also supports parallel processing (MPI), which is
        convenient for large transient datasets. To run in batch mode with MPI
        you must first install the MPI library. We recommend <ulink
        url="http://www.lam-mpi.org/7.1/download.php">LAM/MPI</ulink>. This is
        available for most linux platforms. To run with LAM/MPI, a script
        should be created similar to:</para>

        <para><code> #!/bin/tcsh</code></para>

        <para><code> setenv VE_SUITE_HOME
        /home/users/mcdoe/svn_VE_Suite/VE_Suite &amp;&amp; source
        $VE_SUITE_HOME/VE_Installer/setup.tsh </code></para>

        <para><code> vtkTo3DTextureMPI -o
        /home/users/mcdoe/LTN/3D_Jets_Test/jets_vti -x 32 -y 64 -z 32
        /home/users/mcdoe/LTN/3D_Jets_Test/Jets_Data </code></para>

        <para>Which should then be executed as follows:</para>

        <para><code> mpirun –np 2 ./ </code></para>
      </section>

      <section id="building_files_from_starcd">
        <title>Building Files from StarCD</title>

        <para>If you need to write out star.cel, star.vrt, and star.usr files
        from StarCD, follow these instructions:</para>

        <orderedlist>
          <listitem>
            <para>Launch StarCD</para>
          </listitem>

          <listitem>
            <para>Ensure that a *.vrt and *.cel file is written of the region
            of interest. This region can either be a complete CFD model or a
            subsection of the model.</para>
          </listitem>

          <listitem>
            <para>Analyze data</para>
          </listitem>

          <listitem>
            <para>Post-processing -&gt;Load data</para>

            <orderedlist>
              <listitem>
                <para>In "File(s)" tab, click "open post file"</para>
              </listitem>

              <listitem>
                <para>In "Data" tab:</para>

                <orderedlist>
                  <listitem>
                    <para>Scalar Data -&gt;Turb Kinetic Energy</para>
                  </listitem>

                  <listitem>
                    <para>Vector Data -&gt;Velocity Components UVW</para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Click <guibutton>Get Data</guibutton></para>
          </listitem>

          <listitem>
            <para>Click <guibutton>View Post Registers</guibutton></para>
          </listitem>

          <listitem>
            <para>To add other scalar values to store:</para>

            <orderedlist>
              <listitem>
                <para>Click <guibutton>Operate</guibutton> at the bottom of
                the Post Registers window</para>
              </listitem>

              <listitem>
                <para>Function -&gt; Load vertex data -&gt; turbulent energy
                (Registers 1-3 must contain vector data. Registers 4-6 must
                contain scalar data.)</para>
              </listitem>

              <listitem>
                <para>Select register</para>
              </listitem>

              <listitem>
                <para><emphasis role="bold">NOTE:</emphasis> Although it is
                necessary to use vertex data rather than cell data, using
                vertex data might return an error. To solve this problem, copy
                the previous command line and add the register number, e.g.
                "enter oper, getv, te, 5,"</para>
              </listitem>

              <listitem>
                <para>Ensure that "using relative values" is selected</para>
              </listitem>

              <listitem>
                <para>Click <guibutton>Apply</guibutton> to put data in an
                empty register</para>
              </listitem>

              <listitem>
                <para>Click <guibutton>Update list</guibutton></para>
              </listitem>

              <listitem>
                <para>Repeat steps 7.1-7.6 to add data to registers 5 and 6
                (pressure and viscosity)</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>The data is now stored.</para>
          </listitem>

          <listitem>
            <para>In pro-STAR window:</para>

            <orderedlist>
              <listitem>
                <para>Post -&gt; save user data</para>
              </listitem>

              <listitem>
                <para>Registers: all</para>
              </listitem>

              <listitem>
                <para>File type: coded</para>
              </listitem>

              <listitem>
                <para>Range: all vertices</para>
              </listitem>

              <listitem>
                <para>Click <guibutton>Apply</guibutton></para>
              </listitem>

              <listitem>
                <para>Click <guibutton>Close</guibutton></para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Manually close file (enter "close *.usr")</para>
          </listitem>

          <listitem>
            <para>File -&gt; save as coded</para>
          </listitem>

          <listitem>
            <para>Unclick boundary file</para>
          </listitem>

          <listitem>
            <para>Click <guibutton>Apply</guibutton></para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">NOTE:</emphasis> Checked files are
            written out</para>
          </listitem>

          <listitem>
            <para>Enter "Close All"</para>
          </listitem>
        </orderedlist>
      </section>
    </chapter>
  </part>

  <part id="developer_info">
    <title>Developer Information</title>

    <chapter id="code_guidelines">
      <title>Code Guidelines</title>

      <section id="class_structure_guidelines">
        <title>Class Structure</title>

        <para>Only one public class is allowed per file. Every class name,
        macro, etc. starts with either "cfd" or "CFD" to avoid name clashes
        with other libraries. Classes should all start with "cfd" and macros
        or constants can start with either. Class names and file names are the
        same (e.g., cfdContours class is declared in cfdContours.h and
        implemented in cfdContours.cpp). This makes it easier to find the
        correct file for a specific class. All instance variables are declared
        as protected. The user and application developer should access
        instance variables through Set/Get methods.</para>

        <para><emphasis role="bold">Always</emphasis> initialize member
        variables in the constructor.</para>
      </section>

      <section id="names_guidelines">
        <title>Names</title>

        <para>Make names clear. Try to spell out a name and not use
        abbreviations. This leads to longer names but it makes using the
        software easier because you know that the SetRasterFontRange method
        will always be called that, not SetRFRange or SetRFontRange or SetRFR.
        When the name includes a natural abbreviation such as OpenGL, keep the
        abbreviation and capitalize the abbreviated letters. Only use
        alphanumeric characters in names, [a-zA-z0-9]. Do not use underscores
        ("_"). For example, use exteriorSurface rather than exterior_Surface
        or _exteriorSurface. Use capitalization to indicate words within a
        name. For example, a class could be called cfdVectorTopologyFilter.
        Use "this" inside of methods even though C++ does not require you to.
        This really seems to make the code more readable because it
        disambiguates between instance variables and local or global
        variables. It also disambiguates between member functions and other
        functions.</para>
      </section>

      <section id="class_names_guidelines">
        <title>Class Names</title>

        <para>Class names are nouns and usually start with "cfd".</para>
      </section>

      <section id="variable_names_guidelines">
        <title>Variable Names</title>

        <para>Variable names are nouns and should begin with a lower case
        character.</para>
      </section>

      <section id="function_names_guidelines">
        <title>Function Names</title>

        <para>Function names are verbs (e.g., SetRasterFontRange) and start
        with an upper case letter.</para>
      </section>

      <section id="functions_and_arguments_guidelines">
        <title>Functions and Function Arguments</title>

        <para>Use "const" on any member function that does not change any
        data. It enforces the purpose of a function and allows for better
        compiler optimizations.</para>
      </section>

      <section id="variable_usage_guidelines">
        <title>C++ Style Variable Usage</title>

        <para>Declare variables where they are first used. C++ lifted this
        restriction from C for a reason. It makes code more modular and easier
        to understand, modify, and debug.</para>
      </section>

      <section id="braces_guidelines">
        <title>Braces</title>

        <para>Place brace under and inline with keywords:</para>

        <para><code> if ( condition ) while ( condition ) </code></para>

        <para><code> { { </code></para>

        <para><code> ... ... </code></para>

        <para><code> } }</code></para>

        <para>Use braces for all if, while, and do statements even if there is
        only a single statement within the braces.</para>
      </section>

      <section id="header_files_guidelines">
        <title>Header Files</title>

        <para>Header files are for declarations only. It is difficult to read
        and find code if source is in the declarations.</para>

        <para>The header file of the class should include only the superclass
        header file. If you need any other includes, include comment at each
        one describing why it should be included.</para>

        <para>Forward declare classes when possible in header files.</para>

        <para>Header files should use guards to prevent multiple inclusion.
        These guards should be defined in the style FILENAME_H, which is the
        filename written in all upper case with punctuation such as dots (".")
        replaced by underscores ("_").</para>

        <para><code> #ifdef CFDHEADER_H </code></para>

        <para><code> #define CFDHEADER_H </code></para>

        <para><code> ... </code></para>

        <para><code> #endif // CFDHEADER_H</code></para>

        <para>Comment the end of every <code>#endif</code>, as shown above.
        Nested <code>#ifdef</code> can be difficult to follow.</para>

        <para>A new line after the last <code>#endif</code> is required by
        some compilers.</para>
      </section>

      <section id="text_formatting_guidelines">
        <title>Text Formatting</title>

        <para>Limit lines to 80 characters.</para>

        <para>Three (3) space indentation – Set your editor to insert three
        spaces every time you hit the tab key.</para>

        <para>Insert whitespace for readability. This means that one blank
        line should occur between function definitions or between different
        blocks of code.</para>
      </section>

      <section id="namespaces_guidelines">
        <title>Namespaces</title>

        <para>Do not place the "using namespace" directive at global scope in
        a header file. This can cause lots of invisible conflicts that are
        hard to track. Keep "using" statements to implementation files (if at
        all).</para>

        <para>For standard namespace keywords (cout, cin, cerr, endl, vector,
        string), you must use "std::cout," etc.</para>
      </section>

      <section id="comments_guidelines">
        <title>Comments</title>

        <para>Comments must tell "why", not "what is happening." At every
        point where you had a choice of what to do, place a comment describing
        which choice you made and why.</para>
      </section>

      <section id="parens_guidelines">
        <title>Parens () with Key Words and Functions Policy</title>

        <para>Do not put parens next to keywords. Put a space between keywords
        and parens.</para>

        <para>Do not use parens in return statements when it is not
        necessary.</para>

        <para>Do put parens next to function names.</para>

        <para>Example:</para>

        <para><code> if ( condition ) while ( condition ) </code></para>

        <para><code> { { </code></para>

        <para><code> ... ... </code></para>

        <para><code> } } </code></para>

        <para><code> strcpy( s, s1 ); return 1;</code></para>
      </section>

      <section id="array_indexing_guidelines">
        <title>Array Indexing</title>

        <para>Single-character variable names can easily be mistaken for
        numbers ("i"s can sometimes look a lot like ones). Make the array
        index stand out with whitespace:</para>

        <para><code> array[ i ] = 0.0; </code></para>

        <para><code> array[ 1 ] = 0.0; </code></para>

        <para><code> array[ 2 ] = 0.0;</code></para>
      </section>
    </chapter>

    <chapter id="building_vesuite">
      <title>Building VE-Suite</title>

      <para>Before attempting to build VE-Suite, be sure to build/install the
      <link linkend="dependencies">dependencies</link> and <link
      linkend="setting_the_environment">set the environment</link>.</para>

      <section id="unix_build_instructions">
        <title>UNIX/Linux Build Instructions</title>

        <para>VE-Suite, as well as its dependencies, is currently being tested
        on a broad range of unix/linux platforms including: IRIX 6.5, SuSE,
        and RedHat Enterprise.</para>

        <para><link linkend="setting_the_environment">Set the environment
        variables</link> and source the setup file included with the VE-Suite
        project: $(VE_SUITE_HOME)/VE_Installer/setup.{.sh,tsh}. Once this file
        has been properly edited, type <code>gmake</code>. The unix build
        system is based on Doozer which is included with VR Juggler.</para>

        <para>Supported base configurations available:</para>

        <orderedlist>
          <listitem>
            <para>tao_pf_dbg - OpenGL Performer based application supporting
            released features.</para>
          </listitem>

          <listitem>
            <para>tao_osg_dbg - OpenSceneGraph based application supporting
            released features.</para>
          </listitem>

          <listitem>
            <para>tao_osg_vep_dbg - OpenSceneGraph based application
            supporting released and new features from current research.</para>
          </listitem>
        </orderedlist>

        <para>There are also cluster variants of each of the above
        configurations:</para>

        <orderedlist>
          <listitem>
            <para>tao_pf_cluster_dbg</para>
          </listitem>

          <listitem>
            <para>tao_osg_cluster_dbg</para>
          </listitem>

          <listitem>
            <para>tao_osg_vep_cluster_dbg</para>
          </listitem>
        </orderedlist>

        <para>To change any of the configurations described above, open the
        setup file and set SCENE_GRAPH, CLUSTER_APP, VE_PATENTED
        accordingly.</para>
      </section>

      <section id="windows_build_instructions">
        <title>Windows Build Instructions</title>

        <para>VE_Suite, as well as its dependencies, is currently built and
        tested using Visual Studio 7.1(2003).</para>

        <section id="building_vesuite_section">
          <title>Building VE-Suite</title>

          <para><link linkend="setting_the_environment">Set the environment
          variables</link> and launch a session of Visual Studio with the
          VE-Suite project loaded, run the batch file:</para>

          <para><code> $(VE_SUITE_HOME)VE_Installerbuild.bat </code></para>

          <para>Supported base configurations available:</para>

          <orderedlist>
            <listitem>
              <para>tao_pf_dbg - OpenGL Performer based application supporting
              released features</para>
            </listitem>

            <listitem>
              <para>tao_osg_dbg - OpenSceneGraph based application supporting
              released features</para>
            </listitem>

            <listitem>
              <para>tao_osg_vep_dbg - OpenSceneGraph based application
              supporting released and new features from current
              research</para>
            </listitem>
          </orderedlist>

          <para>There are also cluster variants of each of the above
          configurations:</para>

          <orderedlist>
            <listitem>
              <para>tao_pf_cluster_dbg</para>
            </listitem>

            <listitem>
              <para>tao_osg_cluster_dbg</para>
            </listitem>

            <listitem>
              <para>tao_osg_vep_cluster_dbg</para>
            </listitem>
          </orderedlist>
        </section>

        <section id="debugging_vexplorer">
          <title>Debugging VE_Xplorer</title>

          <para>To run VE_Xplorer from within the Visual Studio debugger,
          change the working directory in the Configuration Properties tab to
          point to the directory where your VE-Suite parameter file is located
          (for example, change the working directory to
          $(VE_SUITE_HOME)VE_TestSuite).</para>

          <para>You will also need to pass in your VR juggler config files as
          command arguments on the configuration properties tab. With the two
          projects still open, right-click on the VE_Xplorer project file, and
          select properties. For simulation mode, you add the following to
          your command arguments section:</para>

          <para><code> $(VJ_BASE_DIR)sharevrjugglerdataconfigFiles
          sim.base.jconf </code></para>

          <para><code> $(VJ_BASE_DIR)sharevrjugglerdataconfigFiles
          sim.wand.mixin.jconf </code></para>

          <para>After you enter a parameter file name and the scene loads,
          double click on $(VE_SUITE_HOME)bin runWinClient.bat to bring up the
          gui.</para>
        </section>
      </section>
    </chapter>

    <chapter id="dependencies">
      <title>Dependencies</title>

      <para>The following is a list of links for the VE-Suite dependencies .
      Dependencies can be downloaded and built by the user from the following
      links or the pre-compiled binaries can be installed from the download
      page.</para>

      <para>&lt;OpenSceneGraph image&gt;</para>

      <para><ulink url="http://www.openscenegraph.org/">OpenSceneGraph
      (OSG)</ulink> can be used to manage the scenegraph instead of OpenGL
      Performer.</para>

      <para>&lt;VTK image&gt;</para>

      <para><ulink url="http://vtk.org/get-software.php#interim">VTK</ulink>
      is used to render the visualization objects.</para>

      <para>&lt;CMake image&gt;</para>

      <para><ulink url="http://www.cmake.org/HTML/Index.html">CMake</ulink> is
      needed to build the VTK.</para>

      <para>&lt;VRJuggler image&gt;</para>

      <para><ulink
      url="http://sourceforge.net/project/showfiles.php?group_id=8041">VRJuggler</ulink>
      is used for management of the virtual environment.</para>

      <para><ulink
      url="http://sourceforge.net/project/showfiles.php?group_id=8041">VRJuggler
      dependencies zip file</ulink></para>

      <para><ulink url="http://java.sun.com/j2se/1.4.2/download.html">Java 2
      SDK</ulink> is needed for Juggler's java-based VRJconfig program.</para>

      <para>&lt;wxWidgets image&gt;</para>

      <para><ulink url="http://www.wxwidgets.org/">wxWidgets</ulink> is used
      to compile and run the gui. (Click "download" on the left side menu to
      get to the files.)</para>

      <para><ulink
      url="http://xml.apache.org/xerces-c/download.cgi">Xerces</ulink> is used
      to read and write XML. (Download <ulink
      url="http://xml.apache.org/xerces-c/download.cgi">xerces-c-current</ulink>)</para>

      <para>&lt;ACE/TAO image&gt;</para>

      <para><ulink
      url="http://deuce.doc.wustl.edu/Download.html">ACE/TAO</ulink> is used
      for cross-platform communications.</para>

      <para>&lt;python image&gt;</para>

      <para>VE-Launcher was coded using <ulink
      url="http://www.python.org/">Python</ulink>. It can run in Python2.3 or
      higher. If you are running it from Python, you need to install these
      extensions for Python as well:</para>

      <para>Windows: VE-Launcher requires these <ulink
      url="https://sourceforge.net/project/showfiles.php?group_id=78018">Win32
      extensions</ulink> if you're running it in Python for Windows.</para>

      <para>&lt;wxPython image&gt;</para>

      <para>VE-Launcher requires <ulink
      url="http://wxpython.org/">wxPython</ulink> 2.6.3.3 if you're running it
      in Python.</para>

      <section id="building_dependencies_on_windows">
        <title>Building Dependencies on Windows</title>

        <para>It is best to read the specific installation/build instructions
        for each dependency before attempting to build. The information
        provided is for specific details to allow VE-Suite to build/run
        correctly.</para>

        <para>VE-Suite and its dependencies are currently built and tested
        using Visual Studio 7.1(2003).</para>

        <para><emphasis role="bold">Notes on installation of
        dependencies</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><ulink
            url="http://tortoisesvn.tigris.org/">TortoiseSVN</ulink> - Used to
            check out and update VE-Suite from ISU's code repository.</para>
          </listitem>

          <listitem>
            <para>After TortoiseSVN is installed, you can check out the code
            if you have an account registered with ISU's repository. Create a
            VE-Suite folder. Right-click on the VE-Suite folder and choose
            "Checkout...". For URL, enter <ulink
            url="https://subversion.vrac.iastate.edu/svn/TSVEG/VE_Suite">https://subversion.vrac.iastate.edu/svn/TSVEG/VE_Suite</ulink>.</para>
          </listitem>

          <listitem>
            <para>Alternately, if you get the VE-Suite source code as a
            compressed tarball, some unzip utilities may not maintain the
            correct directory structure. This can be fixed by unzipping the
            files on a Unix-based system and then moving the files to the
            Windows machine.</para>
          </listitem>

          <listitem>
            <para>While the default locations for installations will work, we
            recommend creating a directory in the root (C:) directory to
            minimize the path lengths and the accompanying potential for typos
            when configuring environment settings.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">vtk-specific notes</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>After downloading the compressed vtk source code and the
            CMake installer, unzip the vtk source to C:VTK-4.4-LatestRelease
            and run the CMake setup program (e.g., CMSetup205.exe) to install
            CMakeSetup.</para>
          </listitem>

          <listitem>
            <para>Go to C:VTK-4.4-LatestRelease. You will have a "VTK" folder
            containing the vtk source code. Create two additional folders:
            "build" and "install".</para>
          </listitem>

          <listitem>
            <para>Run CMakeSetup, and enter C:VTK-4.4-LatestReleaseVTK as
            source code location and C:VTK-4.4-LatestReleasebuild as the place
            to build the binaries. Check the box "Show Advanced Values" and
            press <guibutton>Configure</guibutton>.</para>
          </listitem>

          <listitem>
            <para>Change some options from their default values:</para>

            <orderedlist>
              <listitem>
                <para>BUILD_SHARED_LIBS to ON</para>
              </listitem>

              <listitem>
                <para>BUILD_TESTING to OFF</para>
              </listitem>

              <listitem>
                <para>CMAKE_INSTALL_PREFIX to
                C:VTK-4.4-LatestReleaseinstall</para>
              </listitem>

              <listitem>
                <para>VTK_USE_HYBRID to ON</para>
              </listitem>

              <listitem>
                <para>VTK_USE_PARALLEL to ON</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Press <emphasis role="bold">Configure</emphasis> (you may
            need to do it twice), then <guibutton>OK</guibutton>.</para>
          </listitem>

          <listitem>
            <para>Go to C:VTK-4.4-LatestReleasebuild. Double click on
            "VTK.sln". </para>
          </listitem>

          <listitem>
            <para>Left-click on ALL_BUILD, then right-click and select
            "Build".</para>
          </listitem>

          <listitem>
            <para>When the build is finished, go to
            C:VTK-4.4-LatestReleasebuildCMakedebug and move the .dll files up
            one level.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">When building ACE and
        TAO</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>You need to create a file called "config.h" in the
            ACE_wrappersace directory, with the line '#include
            "ace/config-win32.h"' in the file. </para>
          </listitem>

          <listitem>
            <para>The workspace file ACE_wrappersTAOTAOACE.dsw will need to be
            converted to solution (.sln) files.</para>
          </listitem>

          <listitem>
            <para>ACE_ROOT and TAO_ROOT must be established and ACE_ROOTbin
            placed in your $PATH before building ACE and TAO. This can be done
            using a batch file (.BAT) with these lines:</para>

            <para><code> set ACE_ROOT=C:ACE_wrappers </code></para>

            <para><code> set TAO_ROOT=%ACE_ROOT%TAO </code></para>

            <para><code> set Path=%Path%;%ACE_ROOT%bin </code></para>

            <para><code> "C:Program FilesMicrosoft Visual Studio .NET
            2003Common7IDEdevenv.exe" ./TAOACE.sln</code></para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">Other dependency notes</emphasis></para>

        <para>For wxWidgets, load the .dsw file build/msw/wx_dll.dsw and build
        using the DLL Debug configuration. </para>

        <para><emphasis role="bold">NOTE:</emphasis> For openGL support change
        this flag, wxUSE_GLCANVAS, to 1 in the file include/wx/msw/setup.h.
        For Xerces, the .sln file is
        Projects/Win32/VC7.1/xerces-all/xerces-all.sln.</para>

        <para><emphasis role="bold">NOTE:</emphasis> Xerces 2.7 has the Run
        Time Type Information (RTTI) configuration off by default. Therefore,
        right-click on the XercesLib project, select
        properties-&gt;C/C++-&gt;Language and change the "Enable Run-Time Type
        Info" setting to "Yes(/GR)" Then proceed building the solution.</para>
      </section>

      <section id="building_dependencies_on_unix">
        <title>Building Dependencies on UNIX/Linux</title>

        <para>It is best to read the specific installation/build instructions
        for each dependency before attempting to build. The information here
        is provided for specific details to allow VE-Suite to build/run
        correctly.</para>

        <section id="wxwidgets_build_instructions_on_unix">
          <title>wxWidgets Build Instructions on UNIX</title>

          <para>To build wxWidgets on a UNIX style platform, the library must
          be configured before it can be built. This is platform specific. To
          do this first read the INSTALL.txt file in the wxWidgets directory.
          When downloading wxWdigets download the wxGTK package. <emphasis
          role="bold">NOTE:</emphasis> VE-Suite should now build against most
          distributed versions of wxGTK. Also, be sure to have gtk2-devel
          packages installed on your system before trying to build
          wxGTK.</para>

          <para>To configure wxWidgets properly for a VE-Suite build the
          following options should be specified w/ the configure
          command:</para>

          <itemizedlist>
            <listitem>
              <para><code>enable-shared</code> creates shared libraries</para>
            </listitem>

            <listitem>
              <para><code>enable-log</code> enables logging support within
              wxWidgets</para>
            </listitem>

            <listitem>
              <para><code>with-opengl </code>enables opengl support within
              wxWidgets</para>
            </listitem>

            <listitem>
              <para><code>prefix=/myInstallDirectory/wxGTK </code>specifies
              the install directory</para>
            </listitem>
          </itemizedlist>

          <para>Following the instructions in INSTALL.txt, the configure
          command would be:</para>

          <para><code> ../configure --enable-shared --with-opengl --enable-log
          --prefix=/</code></para>

          <para>This will set up wx properly for building with VE-Suite. When
          the configuration is complete, type:</para>

          <para><code> gmake </code></para>

          <para>After the build finishes type:</para>

          <para><code> gmake install</code></para>

          <para>This will install the libraries and includes in the directory
          specified by --prefix option.</para>
        </section>

        <section id="ace_tao_build_instructions_on_unix">
          <title>ACE/TAO Build Instructions on UNIX</title>

          <para>Download the lastest beta release of ACE+TAO. With this
          particular version of ACE+TAO it is possible to use configure. To
          build ACE+TAO create a build dir (e.g. build-linux-rhel3).
          Then:</para>

          <para><code> &gt; cd &lt;build-dir&gt; </code></para>

          <para><code> &gt; ../configure --prefix=&lt;location where ace+tao
          will be installed&gt; </code></para>

          <para><code> &gt; gmake </code></para>

          <para><code> &gt; gmake install</code></para>

          <para>This will create an dir with the appropriate include, lib, and
          bin dir for ACE+TAO.</para>
        </section>

        <section id="osg_buid_instructions_on_unix">
          <title>OpenSceneGraph Build Instructions on UNIX</title>

          <para>For OpenSceneGraph, download the latest release version.
          OpenSceneGraph is dependent on Producer and OpenThreads. Producer is
          dependent on OpenThreads, therefore OpenThreads must be built first.
          To build OpenThreads, go into the OpenThreads directory. The
          following environment variables should be set either on the command
          line (or through a setup script):</para>

          <para><code> OSG_HOME:</code> the location of the OpenSceneGraph
          directory </para>

          <para><code> OPENTHREADS_INC_DIR:</code> the location of
          OpenThreads/include </para>

          <para><code> OPENTHREADS_LIB_DIR:</code> the location of
          OpenThreads/lib </para>

          <para><code> PRODUCER_INC_DIR:</code> the location of
          Producer/include </para>

          <para><code> PRODUCER_LIB_DIR:</code> the location of Producer/lib
          </para>

          <para><code> INST_LOCATION:</code> this is where to install the
          libraries.</para>

          <para>These will all be specific to where you downloaded and
          extracted each dependency directory. </para>

          <para>To set these environment variables from the command line type
          something like: </para>

          <para><code> &gt;setenv OSG_HOME
          /home/users/myaccount/ve_depends/OSG/OpenSceneGraph </code></para>

          <para>After setting the environment variables are set, go into the
          OpenThreads directory and type:</para>

          <para><code> &gt;make</code> or &gt;<code>gmake </code></para>

          <para>This will compile OpenThreads. </para>

          <para>Once it is built, install the libraries using: </para>

          <para><code> &gt; make INST_LOCATION=/home/myInstallDirectory/OSG
          install</code></para>

          <para>Where /home/myInstallDirectory is the desired directory to
          create the install. </para>

          <para>Next go into the Producer directory: </para>

          <para><code> &gt;cd Producer </code></para>

          <para><code> &gt;gmake </code></para>

          <para><code> &gt;gmake INST_LOCATION=/home/myInstallDirectory/OSG
          install</code></para>

          <para>And finally: </para>

          <para><code> &gt;cd OpenSceneGraph </code></para>

          <para><code> &gt;gmake </code></para>

          <para><code> &gt;gmake INST_LOCATION=/home/myInstallDirectory/OSG
          install </code></para>

          <para>Check to see that libraries and headers are created in
          INST_LOCATION properly.</para>
        </section>

        <section id="vtk_build_instructions_on_unix_cmake">
          <title>Visualization Toolkit (VTK) Build Instructions on UNIX (CMAKE
          Settings)</title>

          <para>To build vtk, CMake must be used to set the following values.
          To best utilize CMake it is suggested that ccmake be used. To begin,
          create a build dir in the VTK directory (e.g. build-linux-rhel3).
          Then do the following: </para>

          <para><code> &gt; cd &lt;build dir&gt; </code></para>

          <para><code> &gt; ccmake ../. </code></para>

          <para><code> &gt; gmake </code></para>

          <para><code> &gt; gmake install</code></para>

          <para>Please change these default settings for your CMake build
          setup: </para>

          <orderedlist>
            <listitem>
              <para><code>CMAKE_INSTALL_DIR</code> to <code>&lt;location where
              vtk is to be installed&gt;</code></para>
            </listitem>

            <listitem>
              <para><code>BUILD_SHARED_LIBS</code> to <code>ON</code></para>
            </listitem>

            <listitem>
              <para><code>BUILD_TESTING</code> to <code>OFF</code></para>
            </listitem>

            <listitem>
              <para><code>VTK_USE_HYBRID</code> to <code>ON</code></para>
            </listitem>

            <listitem>
              <para><code>VTK_USE_PARALLEL</code> to <code>ON</code></para>
            </listitem>
          </orderedlist>

          <para><emphasis role="bold">NOTE: </emphasis>Be sure that vtk is
          using the proper gl drivers as well.</para>
        </section>
      </section>

      <section id="vesuite_component_dependencies">
        <title>VE-Suite Component Dependencies</title>

        <para>If you are installing individual components of VE-Suite on
        different desktops, it is only necessary to install the dependencies
        for that specific component. Below is a table listing the individual
        components and their specific dependencies.</para>

        <informaltable>
          <tgroup cols="2">
            <tbody>
              <row>
                <entry>Name/Service</entry>

                <entry>ACE/TAO, xerces-c</entry>
              </row>

              <row>
                <entry>VE-Conductor (GUI)</entry>

                <entry>ACE/TAO, xerces-c, wxWidgets</entry>
              </row>

              <row>
                <entry>VE-Xplorer</entry>

                <entry>ACE/TAO, OpenSceneGraph* or Performer*, VTK,
                VRJuggler</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>*depends on the desired scenegraph management</para>
      </section>
    </chapter>

    <chapter id="setting_the_environment">
      <title>Setting the Environment</title>

      <para>To specify the build/run environment, perform a one-time edit of
      the environment variables that are defined in the setup file, setup.bat
      on Windows and setup.tsh/setup.sh on UNIX/Linux platforms. If the paths
      of your environment variables contain spaces, you need to put the
      directory containing the spaces in quotation marks.</para>

      <para>Example: </para>

      <para><code> set VTK_HOME=C:"Documents and
      Settings"userDesktopvtk</code></para>

      <para><emphasis role="bold">Important variables for UNIX/Linux platforms
      only:</emphasis> </para>

      <para><code> SCENE_GRAPH Set to PF or OSG to define which scene graph to
      build for VE-Xplorer. </code></para>

      <para><code> TAO_BUILD Always set to TRUE. In the future this flag can
      be used to support other CORBA ORBs as well. </code></para>

      <para><code> CLUSTER_APP Set to TRUE if VE-Xplorer will be used on a
      graphics cluster.</code></para>

      <para><emphasis role="bold">Important variables include:</emphasis>
      </para>

      <para><code> VE_SUITE_HOME</code> The location of the top level VE_Suite
      directory. </para>

      <para><code> VJ_BASE_DIR</code> The location of VR Juggler. </para>

      <para><code> VJ_DEPS_DIR</code> The location of VR Juggler dependencies.
      </para>

      <para><code> VTK_HOME</code> Visualization ToolKit (VTK) directory.
      </para>

      <para><code> WX_HOME</code> The wxWidgets install. </para>

      <para><code> XERCESCROOT</code> The location of the xerces build.
      </para>

      <para><code> WX_ROOT</code> The location of wxWidgets install (should be
      same as <code>WX_HOME</code>). </para>

      <para><code> OSGHOME</code> The location of OpenSceneGraph (if OSG
      version is built). </para>

      <para><code> ACE_HOME</code> The location of the ACE_wrappers directory.
      </para>

      <para><code> TAO_HOME</code> TAO location within ACE/TAO. </para>
    </chapter>

    <chapter id="description_of_the_engines">
      <title>Description of the Engines</title>

      <para>VE-Suite is composed of three main software engines that
      coordinate the flow of data from the engineer to the virtual components
      being designed. The following sections will detail the design of each of
      these engines and describe how they contribute to the overall framework
      functionality.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="veimages/descriptionofengines1.JPG" />
        </imageobject>
      </mediaobject>

      <section id="gui_veconductor">
        <title>Graphical User Interface (VE-Conductor)</title>

        <para>To achieve the goals outlined for the project, a powerful and
        flexible user interface (UI) was implemented. Key features of the
        VE-Suite two-dimensional UI (VE-Conductor) are described in the
        following sections.</para>

        <section id="conductor_multiplatform_support">
          <title>Multi-Platform Support</title>

          <para>The UI makes use of platform independent libraries to enable
          the software to run on a wide range of computer hardware and
          operating systems. These platforms range from Unix workstations to
          Pocket PCs and PDAs. This functionality is ideal for the virtual
          engineering-based system since users will frequently make use of
          handheld computing devices inside of immersive environments (e.g.,
          cave-like systems at ISU-VRAC and NETL).</para>

          <para>After reviewing a number of different UI libraries, <ulink
          url="www.wxwidgets.org">WxWidgets</ulink> was chosen. WxWidgets is
          one of the best cross-platform GUI packages available. It is
          well-maintained, has a large user base, and has ports for Windows,
          Unix/X11, Unix/Motif, OS2, Mac, and GTK. It also has an alpha
          version of a Windows CE port, which is under active development.
          This ensures that the user interface will run on all major platforms
          and even on Pocket PC-based PDAs.</para>
        </section>

        <section id="conductor_detachable_location_transparency">
          <title>Detachable/Location Transparency</title>

          <para>The UI exists independently from the computational engine as a
          separate CORBA component. This functionality allows the UI to be
          attached and detached from an active simulation from any compatible
          computer on the network. As an example, this would allow a user to
          build and start a simulation and then detach from the computational
          engine. The user could then go to a different location, re-attach to
          the simulation, and regain monitoring and control functions.</para>

          <para>To accomplish this functionality a CORBA IDL interface between
          the UI and the computational engine was defined. This CORBA
          interface provides all the necessary communication mechanisms
          between these components. The communication link is bidirectional
          and handles items such as model parameters passed to the
          computational engine and receives items such as execution status and
          results from the computational engine.</para>

          <para>Another advantage of this design is the ability for multiple
          UIs to be attached to the same computational engine, allowing
          multiple users to monitor a simulation from different locations. A
          locking mechanism is used so that only one UI (controller) can
          change the design and inputs of the simulation. The UI also has the
          ability to connect to the graphical environment and control what
          graphical representations are shown for high fidelity data (i.e.,
          contour planes, vector planes, streamlines, iso-surfaces) or for low
          fidelity data (i.e., gauges showing scalar information about plant
          performance, costing data, or emissions data).</para>
        </section>

        <section id="conductor_extensibility">
          <title>Extensibility</title>

          <para>Another important consideration for the UI design is
          extensibility. The UI is able to dynamically discover, identify, and
          load UI elements for new component models. This capability keeps the
          level of difficulty involved in integrating new component models to
          a minimum since it eliminates the need for modifications to the core
          interface when new models are added.</para>

          <para>The dynamic discover and load capability is accomplished by
          loading user developed module UIs from dynamic link libraries (DLL
          in Windows) or shared libraries (SO lib in Linux/Unix). A plugin C++
          base class defining this UI-module interface is provided to all
          module developers. Developers can inherit from this class to create
          their own module UIs and then compile the resulting code into a
          DLL/shared library. The UI framework’s plug loader code will
          recognize the new module and bring that into its user-module
          library. By this mechanism, the core UI can plug in the third-party
          module-specific UI directly from binaries.</para>
        </section>

        <section id="conductor_unified_control">
          <title>Unified Control</title>

          <para>Another feature of the UI is unified control for all user
          interaction. This ensures that the user is not burdened with moving
          between different UIs to perform operations. There is a single UI
          with the ability to: 1) construct, specify, execute and monitor
          simulations; and 2) provide complete control of the
          three-dimensional virtual environment.</para>

          <para>To provide this functionality, the UI is designed to
          communicate via CORBA to not only the computational engine, but also
          to the graphical engine. As was discussed for the
          UI-to-computational engine link, the use of CORBA with an
          appropriate IDL provides a flexible, detachable, and platform
          independent communication mechanism for this link as well.</para>

          <para>The following figure shows the two-dimensional GUI. A list of
          available modules is maintained in a tree structure on the left side
          of the window, while the main canvas area shows the current
          simulation network.</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/descriptionofengines2.JPG" />
            </imageobject>
          </mediaobject>
        </section>
      </section>

      <section id="computational_engine_vece">
        <title>Computational Engine (VE-CE)</title>

        <para>The computational engine (VE-CE) is the core of the framework.
        Its duties are to construct, coordinate, schedule, and monitor plant
        simulation runs. It is capable of running a simulation containing a
        multitude of different types of models, each accepting and generating
        a myriad of data types. The computational engine is able to analyze a
        plant configuration, determine execution order, marshal system
        resources to create model instances, and coordinate the flow of data
        through the simulation framework. Tasks that require specific
        knowledge about a data type or model are relegated to either a
        detachable UI or to a specific model, thus keeping the computational
        engine generalized at a high level.</para>

        <para>Important functions that the computational engine controls can
        be broken down into several pieces for explanation: plant
        configuration, data handling, error handling, relationship to
        detachable UI, scheduling, and relationship to models. Each of these
        is described in detail in the following sections.</para>

        <section id="vece_plant_configuration">
          <title>Plant Configuration</title>

          <para>The configuration of the plant, provided by a detachable UI,
          is the primary data structure used by the computational engine.
          Nearly all algorithms utilized, such as proper data flow,
          scheduling, and resource allocation depend on this topology.</para>
        </section>

        <section id="vece_data_handling">
          <title>Data Handling</title>

          <para>Since there is an unlimited number of possible models capable
          of being integrated into the framework (with each model having a
          different input/output set), the computational engine operates with
          generalized datatypes. To address this requirement, we have designed
          the CORBA IDL interfaces between the computational engine and the
          component models to use mapped string blocks in combination with
          common dimensions of array data.</para>
        </section>

        <section id="vece_error_handling">
          <title>Error Handling</title>

          <para>With the computational engine being the centralized
          intelligence behind a simulation run, all errors that occur while
          performing this task (whether originating within its own structure
          or on an attached model) must be properly handled within the context
          of this overriding structure. Thus, the computational engine has
          sophisticated error handling routines and messaging facilities to
          alert attached users. To fit into the detached UI paradigm, any
          errors that occur on an attached UI are handled locally.</para>
        </section>

        <section id="vece_relationship_to_detachable_ui">
          <title>Relationship to Detachable UI</title>

          <para>The computational engine is a CORBA server into which a
          detachable UI client can connect. This detachable UI is where the
          user is able to create a plant configuration, set model inputs,
          start and stop execution of simulation, and view simulation results.
          Once a client-server connection is made, the engine is able to send
          results, messages, updates, and communications from other attached
          UIs in real time. The computational engine does not require a
          connection to a UI during a simulation run. Users can
          connect/disconnect at will to configure, modify, or monitor the
          simulation of a given plant configuration.</para>
        </section>

        <section id="vece_scheduling">
          <title>Scheduling</title>

          <para>The computational engine makes use of advanced scheduling
          algorithms. The scheduler, at minimum, will be capable of handling
          single and embedded feedback loops, iterative solves and,
          eventually, transient simulation runs.</para>
        </section>

        <section id="vece_relationship_to_models">
          <title>Relationship to Models</title>

          <para>The computational engine, with its CORBA interface, is able to
          connect to the various component models available for a simulation.
          Information passed through this connection includes inputs (user
          supplied and stream data), outputs, results, and general messages.
          The importance of the CORBA interface being used for this purpose is
          discussed in detail in the Model Integration section below.</para>
        </section>
      </section>

      <section id="graphical_engine_vexplorer">
        <title>Graphical Engine (VE-Xplorer)</title>

        <para>The graphical engine (VE-Xplorer) provides the core
        functionality for the virtual engineering aspect of the framework.
        VE-Xplorer enables the engineering analysis and design process to take
        place in a virtual environment. For maximum graphical performance on
        multiple operating systems, it is built upon <ulink
        url="www.vrjuggler.org">VRJuggler</ulink>, <ulink
        url="www.sgi.com">OpenGL Performer</ulink>, and <ulink
        url="www.kitware.com">Kitware’s Visualization ToolKit</ulink>. This
        visual interface, controlled by the UI and the computational engine,
        is a graphical representation of the simulation under review. </para>

        <para>The graphical engine is generalized to load data not only from
        comprehensive models, but also from other engineering sources,
        including results generated from the CMU Vision 21 planner software
        and other generalized datasets (e.g., experimental data from a test
        rig). The engine is also being modified to make use of the high level
        CORBA interface specifications used throughout the software framework.
        This interface allows the visualization engine to communicate directly
        with the component models, computational engine, and UI. To
        communicate with the graphical engine there is an external socket
        connection that is made between individual component models and the
        respective graphical objects. This connection allows large high
        fidelity datasets to be transferred to the graphical environment
        without interrupting the overall communication network.</para>

        <para>The graphical engine is also designed to allow graphics objects
        to be added to the virtual environment just like the objects are added
        in the GUI. This allows the graphical environment to be a direct
        representation of the system being designed by the engineer. In much
        the same way that the GUI auto-discovers the plugins for use by the
        engineer, the graphical engine also dynamically discovers plugins.
        Unlike the GUI, the graphical engine is controlled by the network
        string that is created by the GUI. This represents a significant
        capability since the graphical engine has no a priori knowledge of the
        system under interrogation.</para>
      </section>
    </chapter>

    <chapter id="software_development_documents">
      <title>Software Development Documents</title>

      <para>The Department of Energy is funding a collaborative effort to
      develop new computer simulation tools that are capable of modeling
      advanced, next-generation power plants. As part of this effort, Reaction
      Engineering International, Iowa State University, and Carnegie Mellon
      University have begun development of a virtual engineering-based
      computational framework to facilitate these demanding modeling
      efforts.</para>

      <para>This new, open source framework provides significant features and
      capabilities including:</para>

      <itemizedlist>
        <listitem>
          <para>Distributed computing capabilities</para>
        </listitem>

        <listitem>
          <para>Platform independence</para>
        </listitem>

        <listitem>
          <para>Extensibility for component models</para>
        </listitem>

        <listitem>
          <para>Modern user interface</para>
        </listitem>

        <listitem>
          <para>Support for a hierarchy of component models (from detailed to
          simple)</para>
        </listitem>

        <listitem>
          <para>Comprehensive graphics capabilities including support for
          immersive facilities </para>
        </listitem>

        <listitem>
          <para>Component architecture software design</para>
        </listitem>
      </itemizedlist>

      <para>The VE-Suite framework provides capabilities to fundamentally
      alter the traditional simulation process. Instead of engineers working
      with a number of disparate computational models, it is now possible to
      have a tightly integrated modeling environment where models interact in
      a seamless manner. A sophisticated user interface provides easy user
      interaction, and comprehensive two-dimensional and three-dimensional
      graphics capabilities exist for viewing plant configurations and
      simulation results.</para>

      <para>VE-Suite’s extensible software design allows users to easily
      incorporate component models and corresponding two-dimensional and
      three-dimensional graphical representations to create new, plug-and-play
      framework components. By design, the framework components can be
      distributed across computational resources (different computers
      connected to the internet or a local area network) to make the most
      efficient use of resources. </para>

      <para>Additional details about VE-Suite are available in:</para>

      <para>Swensen, D.A., Maguire, M., Yang, C., and Bockelie, M.J.,
      “Computational Frameworks for Practical, Engineering Applications,”
      presented at the SIAM Computational Sciences and Engineering Conference
      2005, Orlando, Florida, USA, February 12-15, 2005.</para>

      <para>Bockelie, M., Swensen, D.A., Denison, M.K., Maguire, M., Yang, C.,
      Chen, Z., Sadler, B., Senior, C.L., Sarofim, A.F. “A Computational
      Workbench Environment for Virtual Power Plant Simulation”, Contract
      DE-FC26-00NT41047, Final Report, December, 2004.</para>

      <para>Huang, G., Bryden, K. M., and McCorkle, D. S., “Interactive Design
      using CFD and Virtual Engineering,” In the Proceedings of the 10th
      AIAA/ISSMO Multidisciplinary Analysis and Optimization Conference,
      AIAA-2004-4364, September 2004.</para>

      <para>Bryden, K. M., Ashlock, D. A., Corns, S. M.. Graph based
      evolutionary algorithms. submitted to the IEEE Trans Evol Comput.</para>

      <para>Bryden, K. M., and McCorkle, D. S., “Virtual Engineering,” in
      preparation to submit to the Journal of Computing and Information
      Science in Engineering,.</para>

      <para>Bryden, K. M. and McCorkle, D. S., “VE-Suite: A Foundation for
      Building Virtual Engineering Models of High Performance, Low Emission
      Power Plants,” 29th International Technical Conference on Coal
      Utilization &amp; Fuel Systems, Clearwater, Florida, 38-46
      (2004).</para>

      <para>McCorkle, D. S., Bryden, K. M., and Kirstukas, S. J.., “Building a
      Foundation for Power Plant Virtual Engineering,” 28th International
      Technical Conference on Coal Utilization &amp; Fuel Systems, Clearwater,
      Florida, 63-71 (2003).</para>

      <para>McCorkle, D. S., Bryden, K. M., and Ashlock, D. A., “Planned
      Tournament Selection,” Intelligent Engineering Systems Through
      Artificial Neural Networks - Proceedings of the Artificial Neural
      Networks in Engineering Conference, 13: pp 385-390 (2003).</para>

      <para>McCorkle, D. S., Bryden, K. M., and Swensen, D. A., “Using Virtual
      Engineering Tools to Reduce NOx Emissions,” in the Proceedings of ASME
      Power 2004, POWER2004-52021, pp 441-446, March 2004.</para>
    </chapter>

    <chapter id="software_development_tools">
      <title>Software Development Tools</title>

      <para>subversion</para>

      <para>svn tortoise</para>

      <para>trac</para>

      <para>bugzilla</para>

      <para>phpBB</para>

      <para>docbook</para>

      <para>visual studio</para>

      <para>gnu tools</para>

      <para>ddd</para>

      <para>DialogBlocks</para>

      <para>Valgrind</para>

      <para>openGL debuggers</para>

      <para>py2exe</para>

      <para>freeze</para>

      <para>inno setup</para>

      <para>rpm</para>

      <para>dmg builder</para>
    </chapter>
  </part>
</book>