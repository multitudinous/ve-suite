<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Code Guidelines</title>

  <section>
    <title>Introduction</title>

    <para>There is an inherent trade-off between robust, readable code and
    optimum performance. These coding conventions are designed to maximize
    code robustness and readability, possibly at the expense of optimal
    performance.</para>
  </section>

  <section>
    <title>Names</title>

    <para>This section contains general rules that apply to class, variable,
    function, and namespace names.</para>

    <para>Select names that are clear and easy to understand. Keep in mind
    that your code will likely be viewed and maintained by several developers
    after you leave the project.</para>

    <para>Use standard or commonplace acronyms. For example, <emphasis
    role="bold">CreateOSGCamera()</emphasis> is an acceptable name for a
    function that creates an OpenSceneGraph Camera object. Using highly
    descriptive names can help tremendously. Names like <emphasis
    role="bold">CheckForErrors</emphasis> and <emphasis
    role="bold">DumpDataToFile</emphasis> are much more descriptive than
    <emphasis role="bold">ErrorCheck</emphasis> or <emphasis
    role="bold">DataFile</emphasis>. In the second case one may need to check
    the implementation of the function to be confident in knowing exactly what
    it means.</para>

    <para>When the name includes a natural abbreviation such as OpenGL, keep
    the abbreviation and capitalize the abbreviated letters. Never create new
    acronyms or abbreviations. For example, name a function <emphasis
    role="bold">SetRasterFontRange()</emphasis> instead of <emphasis
    role="bold">SetRFR()</emphasis>.</para>

    <para>Use only alphanumeric characters in names, [a-zA-z0-9]. For example,
    name a variable <emphasis role="bold">exteriorSurface</emphasis> rather
    than <emphasis role="bold">exterior_Surface</emphasis>.</para>

    <para>Use underscores (‘_’) only as follows:</para>

    <itemizedlist>
      <listitem>
        <para>As part of any local variable names <emphasis
        role="bold">my_var</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Embedded in C Preprocessor macro and identifier names (example:
        <emphasis role="bold">DEGREES_TO_RADIANS()</emphasis>).</para>
      </listitem>
    </itemizedlist>

    <para>Use capitalization to indicate words within a name (CamelCase). For
    example, you could call a class <emphasis
    role="bold">VectorTopologyFilter</emphasis>.</para>

    <para>Use the keyword "this" inside of methods even though C++ does not
    require you to. This really seems to make the code more readable because
    it disambiguates between instance variables and local or global variables.
    It also disambiguates between member functions and other functions.</para>

    <section>
      <title>Class Names</title>

      <para>Class names are nouns and usually start with "cfd" and follow the
      CamelCase convention.</para>

      <para>A class name should reflect what the class is. Do not tag the
      derived type onto the class. It should be able to stand on its own or be
      properly reflected in the namespace it resides. All classes should be
      declared (and defined) within an appropriate namespace. Never place
      publicly accessible classes in the global namespace.</para>
    </section>

    <section>
      <title>Function Names</title>

      <para>Function names are verbs (e.g., SetRasterFontRange), start with a
      capital letter, and follow the CamelCase convention.</para>

      <para>Use common suffixes and prefixes to make the project's code more
      cohesive. For example, some common prefixes may be Is, Get, or Set. When
      overriding a base class member function declared as virtual, declare the
      derived class member function virtual as well to avoid confusion.</para>
    </section>

    <section>
      <title>Variable names</title>

      <para>Variable names are nouns and should begin with a lower case
      character with multiple words separated by an '_' (underscore).
      Variables should be declared where they are first used.</para>

      <para>Member variable names should use the prefix 'm' (lower-case m). An
      upper-case letter should follow the prefix. An example of a valid member
      variable name is <emphasis role="bold">mViewMatrix</emphasis>. If it is
      a static variable then use the prefix 's' (lower-case s).</para>

      <para>Never use single character variable names. A lower-case I variable
      (<emphasis role="bold">i</emphasis>) is often mistaken for the numeral
      one (<emphasis role="bold">1</emphasis>) or the lower-case letter L
      (<emphasis role="bold">l</emphasis>). Single-character variable names
      also inhibit quick text searches. Consider using a more descriptive name
      for array index variables, such as <emphasis
      role="bold">index</emphasis> rather than <emphasis
      role="bold">i</emphasis>.</para>
    </section>
  </section>

  <section>
    <title>Classes</title>

    <para>Only one public class is allowed per file. Every class name, macro,
    etc. starts with either "cfd" or "CFD" to avoid name clashes with other
    libraries. Classes should all start with "cfd" and macros or constants can
    start with either. Class names and file names are the same (e.g.,
    cfdContours class is declared in cfdContours.h and implemented in
    cfdContours.cpp). This makes it easier to find the correct file for a
    specific class. Similarly, .cxx and .h file pairs should declare and
    define only one public class.</para>

    <para>Declare classes in header (.h) files. Define all member functions in
    source (.cxx) files. Never place source code in header files, which
    prevents other developers from easily finding the source code.</para>

    <para>Do not nest classes within other classes. It is difficult to move a
    nested class out of the owning class at a future date because all code
    using the fully qualified nested class name must be fixed. Nesting classes
    also causes them to be more difficult to locate.</para>

    <para>Each class must support a copy constructor and an operator=() member
    function.</para>

    <para>When declaring a class intended for use as a base class, declare the
    destructor as virtual to ensure that derived class destructors execute.
    This helps guard against memory leaks in derived classes.</para>

    <para>When the base class has a virtual destructor, derived classes should
    also declare their destructors as virtual.</para>
  </section>

  <section>
    <title>Functions</title>

    <para>Always declare a function return type. Never allow the compiler to
    default to type int.</para>

    <para>Use "const" on any member function that does not change any data. It
    enforces the purpose of a function and allows for better compiler
    optimizations.</para>

    <para>When overriding a base class member function declared as virtual,
    declare the derived class member function virtual as well to avoid
    confusion.</para>

    <para>If a class implementation needs a local function, include that
    function in the class declaration as protected or private. Avoid declaring
    the function locally in the implementation, which limits code reusability.
    If the local function could be generalized consider making or adding it to
    a small utility library.</para>

    <section>
      <title>Function Arguments</title>

      <para>Function argument names are nouns and should begin with a lower
      case character and then follow the CamelCase convention. Try to always
      use two words to describe the argument. Ex: <emphasis
      role="bold">tmpValue</emphasis>.</para>

      <para>Always declare function arguments as const if the function does
      not change their value.</para>

      <para>If a function does not take arguments, place the left and right
      parenthesis adjacent to each other in both the function declaration and
      definition. Do not use the keyword void to indicate that there are no
      parameters.</para>

      <para>Always name a parameter. For example:</para>

      <para>// Use this:</para>

      <para>void SetFoo( int tmpValue )</para>

      <para>// Do not use this:</para>

      <para>//void SetFoo( int )</para>
    </section>
  </section>

  <section>
    <title>Variables</title>

    <para><emphasis role="bold">Always</emphasis> initialize member variables
    in the constructor. All instance variables are declared as protected. The
    user and application developer should access instance variables through
    Set/Get methods.</para>

    <para>Declare variables where they are first used. C++ lifted this
    restriction from C for a reason. It makes code more modular and easier to
    understand, modify, and debug.</para>

    <para>Always declare member variables as protected or private. (Add public
    accessor methods to allow external access to the member variable.)
    Initialize all member variables in the class constructor. Make sure to
    include the unit the variable represents as a suffix.</para>
  </section>

  <section>
    <title>Namespace</title>

    <para>Never place a 'using' statement at global scope in a header file.
    This pollutes the namespace of any code that includes that header, and can
    cause runtime issues and invisible conflicts that are difficult to debug
    and hard to track. Restrict 'using' statements to implementation files (if
    at all).</para>

    <para>Always use the fully qualified name for methods outside of the
    class, so for standard namespace keywords (cout, cin, cerr, endl, vector,
    string), you must use "std::cout," etc. Alternately, use 'using' for
    specific functions or variables rather than global namespace inclusion.
    For example, if you only require the string class from the std namespace
    and it will appear frequently, use <emphasis role="bold">using
    std::string;</emphasis> instead of <emphasis role="bold">using
    std;</emphasis>.</para>
  </section>

  <section>
    <title>Headers</title>

    <para>Header files are for declarations only. It is difficult to read and
    find code if source is in the declarations.</para>

    <para>The header file of the class should include only the superclass
    header file. If you need any other includes statements, include comments
    at each one describing why it should be included.</para>

    <para>Forward declare classes when possible to avoid including unnecessary
    header files in a class header file.</para>

    <para>Never place a using statement in a header file. This pollutes the
    namespace of any code that includes that header, and can cause runtime
    issues that are difficult to debug. Restrict using statements to
    implementation files.</para>

    <para>Header files should use guards to prevent multiple inclusion. These
    guards should be defined in the style FILENAME_H, which is the filename
    written in all upper case with punctuation such as dots (".") replaced by
    underscores ("_").</para>

    <para><code> #ifdef CFDHEADER_H </code></para>

    <para><code> #define CFDHEADER_H </code></para>

    <para><code> ... </code></para>

    <para><code> #endif // CFDHEADER_H</code></para>

    <para>You can also use the C Preprocessor to protect against multiple
    inclusions. Create a unique C Preprocessor identifier using the namespace,
    module, subdirectory, and file name. For example, given a file named
    Contours.h in the ves namespace in the Framework subdirectory of the
    Conductor module</para>

    <para><code>#ifdef VES_CONDUCTOR_FRAMEWORK_CONTOURS_H</code></para>

    <para><code>#define VES_CONDUCTOR_FRAMEWORK_CONTOURS_H</code></para>

    <para><code>...</code></para>

    <para><code>#endif // VES_CONDUCTOR_FRAMEWORK_CONTOURS_H</code></para>

    <para>Comment the end of every <code>#endif</code>, as shown above. Nested
    <code>#ifdef</code> can be difficult to follow.</para>

    <para>A new line after the last <code>#endif</code> is required by some
    compilers.</para>
  </section>

  <section>
    <title>Logic Style</title>

    <section>
      <title>Const</title>

      <para>Use const on any member function that does not change any data. It
      enforces the purpose of a function and allows for better compiler
      optimizations.</para>

      <para>Always pass strings by const reference unless you are
      INTENTIONALLY modifying it for use by the calling function.</para>

      <para>void setName( const std::string&amp; name )</para>

      <para>{</para>

      <para>mName = name;</para>

      <para>}</para>

      <para>Always pass an object by const reference if you are not
      INTENTIONALLY modifying any part of it. Always mark the function const
      if it does not change any internal state of the class.</para>

      <para>void printComparison( const NameObject&amp; name ) const</para>

      <para>{</para>

      <para>std::cout &lt;&lt; mOurNameObject-&gt;getFoo() &lt;&lt; " : "
      &lt;&lt; name-&gt;getFoo() &lt;&lt; std::endl;</para>

      <para>}</para>

      <para>When following the above statements, do not pass plain old data
      types (POD) like float, int, or double by reference. Just mark them
      const.</para>

      <para>void printDouble( const double myDouble )</para>

      <para>{</para>

      <para>std::cout &lt;&lt; myDouble &lt;&lt; std::endl;</para>

      <para>}</para>
    </section>

    <section>
      <title>#include organization</title>

      <para>Place all #include statements at the start of the file following
      the standard copyright/disclaimer comment block. Never use #include
      statements midway through a file following other source code.</para>

      <para>Organize #include statements at the top of each file by module,
      third party and then system includes.</para>
    </section>

    <section>
      <title>Conditionals</title>

      <para>Never use the shorthand ?/: conditional syntax, which inhibits
      readability. Always use the more verbose if/else syntax. Example:</para>

      <para>// Use this:</para>

      <para>int clamped_value;</para>

      <para>if( newValue &gt; mMaxValue )</para>

      <para>{</para>

      <para>clamped_value = mMaxValue;</para>

      <para>}</para>

      <para>else</para>

      <para>{</para>

      <para>clamped_value = newValue;</para>

      <para>}</para>

      <para>// Don’t use this:</para>

      <para>//int clamped_value = newValue &gt; mMaxValue ? mMaxValue :
      newValue;</para>

      <para>Don’t use single-line conditions. For example:</para>

      <para>// Use this:</para>

      <para>if( tmp_value == 0 )</para>

      <para>{</para>

      <para>return;</para>

      <para>}</para>

      <para>// Don’t use this:</para>

      <para>//if( tmp_value == 0 ) return;</para>
    </section>

    <section>
      <title>Type Casting</title>

      <para>Always use the C++-style static_cast syntax rather than C-style
      type casting. This improves robustness by forcing you to place
      parentheses around the source data. Example:</para>

      <para>void Resize( int canvasWidth, int canvasHeight )</para>

      <para>{</para>

      <para>double aspect_ratio = static_cast&lt; double &gt;( canvasWidth )
      /</para>

      <para>static_cast&lt; double &gt;( canvasHeight );</para>

      <para>}</para>
    </section>

    <section>
      <title>Assertions</title>

      <para>Place assertions before code segments that would fail
      catastrophically if the assertion condition is false. Calls to assert()
      are only executed in unoptimized builds, so there is no performance risk
      in production builds with liberal assertion usage. If the assertion is
      potentially confusing, precede it with a comment explaining why the
      assertion must be true. Include &lt;cassert&gt; rather than
      &lt;assert.h&gt;. Example:</para>

      <para>#include &lt;cassert&gt;</para>

      <para>void FunctionName( int* indexAddress )</para>

      <para>{</para>

      <para>assert( indexAddress != NULL );</para>

      <para>int index = *indexAddress;</para>

      <para>...</para>
    </section>

    <section>
      <title>Switch Statements</title>

      <para>Wrap each case section with curly braces.</para>

      <para>If you intend one case to fall through to the next, place a
      plainly visible comment at the end of the first case stating that the
      fall through is intentional and explain why. Otherwise, always use a
      break statement at the end of each case section.</para>

      <para>Include a default section at the end of each switch
      statement.</para>
    </section>

    <section>
      <title>goto Statements</title>

      <para>Never use goto statements or labels.</para>
    </section>

    <section>
      <title>Globals and Statics</title>

      <para>Never use global variables. Consider using a singleton design
      pattern instead of a global variable.</para>

      <para>Avoid using static variables. An obvious exception is the instance
      pointer in a singleton object.</para>
    </section>

    <section>
      <title>Preprocessor Macros</title>

      <para>Overuse of the C Preprocessor can inhibit debugging. Avoid using
      the C Preprocessor where possible. Always use a standard function
      definition instead of a C Preprocessor macro for complex code segments.
      Never use a C Preprocessor macro as a shorthand mechanism for repeating
      code blocks. Here are some examples of appropriate use of the C
      Preprocessor:</para>

      <para>#define PI_OVER_4 0.7853981633974483096156</para>

      <para>#define DEGREES_TO_RADIANS(DEGREES)( DEGREES *
      0.01745329251994329576923 )</para>

      <para>Use the C Preprocessor to protect against multiple inclusions of
      header files.</para>

      <para>Also, use the C Preprocessor to embed multiple implementations,
      such as in a stack-based factory design pattern implementation. For
      example:</para>

      <para>float maximum( float input0, float input1 )</para>

      <para>{</para>

      <para>#ifdef WINDOWS</para>

      <para>return __max( input0, input 1 )</para>

      <para>#else</para>

      <para>return std::max&lt;float&gt;( input0, input1 );</para>

      <para>#endif</para>

      <para>}</para>
    </section>

    <section>
      <title>Compiler and Linker Warnings</title>

      <para>All code should compile cleanly at the maximum warning level. This
      eliminates clutter in the compiler output stream and improves the
      visibility of any new warnings inadvertently introduced in the
      development process.</para>

      <para>As an exception, third party code is allowed to generate compiler
      warnings.</para>

      <para>During development, compile code with the -pedantic or -Wall
      compiler options to maximize warning verbosity.</para>

      <para>Compilers generate different warnings for 32- versus 64-bit
      compilations and debuggable versus optimized compilations. Test all
      compilation configurations to ensure your code does not introduce new
      warnings under any conditions.</para>
    </section>

    <section>
      <title>Array Indexing</title>

      <para>Single-character variable names can easily be mistaken for numbers
      ("i"s can sometimes look a lot like ones). Make the array index stand
      out with whitespace:</para>

      <para><code> array[ i ] = 0.0; </code></para>

      <para><code> array[ 1 ] = 0.0; </code></para>

      <para><code> array[ 2 ] = 0.0;</code></para>
    </section>

    <section>
      <title>Parens () with Keywords and Function Policy</title>

      <para>Do not put parens next to keywords. Put a space between keywords
      and parens.</para>

      <para>Do not use parens in return statements when it is not
      necessary.</para>

      <para>Do put parens next to function names.</para>

      <para>Example:</para>

      <para><code> if ( condition ) while ( condition ) </code></para>

      <para><code> { { </code></para>

      <para><code> ... ... </code></para>

      <para><code> } } </code></para>

      <para><code> strcpy( s, s1 ); return 1;</code></para>

      <para>Overuse parenthesis to clarify and clearly denote operator
      precedence in Boolean and algebraic formulas. For example:</para>

      <para>// Use this:</para>

      <para>if( ( x_index == 0 ) &amp;&amp; ( y_index == 0 ) )</para>

      <para>// Don’t use this:</para>

      <para>// if( x_index == 0 &amp;&amp; y_index == 0 )</para>
    </section>
  </section>

  <section>
    <title>Comment Format</title>

    <section>
      <title>Braces</title>

      <para>Use braces for all if, while, switch, case, for, and do statements
      even if there is only a single statement within the braces.</para>

      <para>Place braces under and inline with keywords, for example:</para>

      <para><code>if ( condition ) while ( condition )</code></para>

      <para><code>{ // Note: curly brace is under and aligned with the
      ‘if’</code></para>

      <para><code>...</code></para>

      <para><code>}</code></para>

      <para>Use curly braces to limit variable scope. This improves
      readability by clearly defining the section of code that is affected by
      a given variable, and allows the compiler to more efficiently allocate
      hardware registers to variables. This is especially important when
      dealing with scoped locks. Put braces around the part where you need to
      hold on to the lock so the lock can go out of scope and release the
      lock</para>
    </section>

    <section>
      <title>Text Formatting</title>

      <para>Limit lines to 80 characters.</para>

      <para>Three (3) space indentation – Set your editor to insert three
      spaces every time you hit the tab key.</para>

      <para>Insert whitespace for readability. This means that one blank line
      should occur between function definitions or between different blocks of
      code.</para>

      <para>For specific details on writing doxygen-compliant and standardized
      comments, see Chapter 16, <ulink
      url="chapter_16_documentation_notes.xml">Documentation
      Notes</ulink>.</para>
    </section>

    <section>
      <title>Comments</title>

      <para>Comments must tell "why", not "what is happening." At every point
      where you had a choice of what to do, place a comment describing which
      choice you made and why. Comments need to be formatted for compatibility
      with doxygen. See Chapter 11 for further detail.</para>

      <para>Use a standard copyright/disclaimer comment block at the top of
      each source file.</para>
    </section>

    <section>
      <title>Docbook Documentation</title>

      <para>The following sections provide guidelines for editing the VE-Suite
      documentation using Docbook.</para>

      <section>
        <title>GUI Buttons</title>

        <para>When referring to GUI buttons, use the Docbook "guibutton" tag,
        i.e., enter this:</para>

        <para>Click &lt;guibutton&gt;Launch VE-Suite&lt;/guibutton&gt; to
        close VE-Launcher and start VE-Suite.</para>

        <para>to yield this:</para>

        <para>Click <guibutton>Launch VE-Suite</guibutton> to close
        VE-Launcher and start VE-Suite.</para>
      </section>

      <section>
        <title>Notes</title>

        <para>When including an important note that you want to draw users'
        attention to, type “NOTE:” and tag it with Docbook emphasis
        role=‘bold’ tag, i.e., enter this:</para>

        <para>&lt;emphasis role="bold"&gt;NOTE:&lt;/emphasis&gt;</para>

        <para>to yield this:</para>

        <para><emphasis role="bold">NOTE:</emphasis></para>
      </section>

      <section>
        <title>Referring to VE-Suite Versions</title>

        <para>When referring to a general version of VE-Suite or any
        application within VE-Suite, such as in a command, use “x.x.x” to
        refer to the version number rather than a number so the reference does
        not become outdated with future release versions. For example, in the
        following sentence, “vesuite.x.x.x.exe” and “vesuite_deps.x.x.x.exe”
        refer to the version of VE-Suite being used, and the user would change
        "x.x.x" to the appropriate version number. In addition, be sure to
        include the build number in the version as well. The build number is
        available in VE-Conductor under the "About" menu option.</para>

        <para>One installer, vesuite.x.x.x.exe, contains the core VE-Suite
        binaries and .dll files, while vesuite_deps.x.x.x.exe contains the
        binaries and .dll files of the dependencies for the current release of
        VE-Suite.</para>

        <para>In some cases, you might need to refer to a specific version of
        VE-Suite as the following example shows:</para>

        <para>Starting VE-Suite was simplified with the release of version
        1.0.0 via VE-Launcher.</para>
      </section>
    </section>
  </section>
</chapter>