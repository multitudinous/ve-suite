<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Code Guidelines</title>

  <section>
    <title>Introduction</title>

    <para>There is an inherent trade-off between robust, readable code and
    optimum performance. These coding conventions are designed to maximize
    code robustness and readability, possibly at the expense of optimal
    performance.</para>
  </section>

  <section>
    <title>Names</title>

    <para>This section contains general rules that apply to class, variable,
    function, and namespace names.</para>

    <para>Select names that are clear and easy to understand. Keep in mind
    that your code will likely be viewed and maintained by several developers
    after you leave the project.</para>

    <para>Use standard or commonplace acronyms. For example,
    <code>CreateOSGCamera()</code> is an acceptable name for a function that
    creates an OpenSceneGraph Camera object. Using highly descriptive names
    can help tremendously. Names like <code>CheckForErrors</code> and
    <code>DumpDataToFile</code> are much more descriptive than
    <code>ErrorCheck</code> or <code>DataFile</code>. In the second case one
    may need to check the implementation of the function to be confident in
    knowing exactly what it means.</para>

    <para>When the name includes a natural abbreviation such as OpenGL, keep
    the abbreviation and capitalize the abbreviated letters. Never create new
    acronyms or abbreviations. For example, name a function
    <code>SetRasterFontRange()</code> instead of <code>SetRFR()</code>.</para>

    <para>Use only alphanumeric characters in names (<code>A-Z, a-z,
    0-9</code>). For example, name a variable <code>exteriorSurface</code>
    rather than <code>exterior_Surface</code>.</para>

    <para>Use underscores only as follows:</para>

    <itemizedlist>
      <listitem>
        <para>As part of any local variable names (e.g.,
        <code>my_var</code>)</para>
      </listitem>

      <listitem>
        <para>Embedded in C Preprocessor macro and identifier names (e.g.,
        <code>DEGREES_TO_RADIANS()</code>)</para>
      </listitem>
    </itemizedlist>

    <para>Use capitalization to indicate words within a name (CamelCase). For
    example, you could call a class <code>VectorTopologyFilter</code>.</para>

    <para>Use the keyword "this" inside of methods even though C++ does not
    require you to. This really seems to make the code more readable because
    it disambiguates between instance variables and local or global variables.
    It also disambiguates between member functions and other functions.</para>

    <section>
      <title>Class Names</title>

      <para>Class names are nouns and usually start with "cfd" and follow the
      CamelCase convention.</para>

      <para>A class name should reflect what the class is. Do not tag the
      derived type onto the class. It should be able to stand on its own or be
      properly reflected in the namespace it resides. All classes should be
      declared (and defined) within an appropriate namespace. Never place
      publicly accessible classes in the global namespace.</para>
    </section>

    <section>
      <title>Function Names</title>

      <para>Function names are verbs (e.g., <code>SetRasterFontRange</code>),
      start with a capital letter, and follow the CamelCase convention.</para>

      <para>Use common suffixes and prefixes to make the project's code more
      cohesive. For example, some common prefixes may be Is, Get, or Set. When
      overriding a base class member function declared as virtual, declare the
      derived class member function virtual as well to avoid confusion.</para>
    </section>

    <section>
      <title>Variable Names</title>

      <para>Variable names are nouns and should begin iwth a lower case
      character. Words should be separated by an underscore. Variables should
      be declared where they are first used.</para>

      <para>Member variable names should use the prefix <code>m</code>
      (lower-case m). An upper-case letter should follow the prefix. An
      example of a valid member variable name is <code>mViewMatrix</code>. If
      it is a static variable then use the prefix <code>s</code> (lower-case
      s).</para>

      <para>Never use single character variable names. A lower-case I variable
      (i.e., <code>i</code>) is often mistaken for the numeral one
      (<code>1</code>) or the lower-case letter L (<code>l</code>).
      Single-character variable names also inhibit quick text searches.
      Consider using a more descriptive name for array index variables, such
      as <code>index</code> rather than <code>i</code>.</para>
    </section>
  </section>

  <section>
    <title>Classes</title>

    <para>Only one public class is allowed per file. Every class name, macro,
    etc. starts with either <code>cfd</code> or <code>CFD</code> to avoid name
    clashes with other libraries. Classes should all start with
    <code>cfd</code> and macros. Constants can start with either. Class names
    and file names are the same (e.g., <code>cfdContours</code> class is
    declared in <code>cfdContours.h</code> and implemented in
    <code>cfdContours.cpp</code>). This makes it easier to find the correct
    file for a specific class. Similarly, <code>.cxx</code> and
    <code>.h</code> file pairs should declare and define only one public
    class.</para>

    <para>Declare classes in header (<code>.h</code>) files. Define all member
    functions in source (<code>.cxx</code>) files. Never place source code in
    header files, which prevents other developers from easily finding the
    source code.</para>

    <para>Do not nest classes within other classes. It is difficult to move a
    nested class out of the owning class at a future date because all code
    using the fully qualified nested class name must be fixed. Nesting classes
    also causes them to be more difficult to locate.</para>

    <para>Each class must support a copy constructor and an
    <code>operator=()</code> member function.</para>

    <para>When declaring a class intended for use as a base class, declare the
    destructor as virtual to ensure that derived class destructors execute.
    This helps guard against memory leaks in derived classes.</para>

    <para>When the base class has a virtual destructor, derived classes should
    also declare their destructors as virtual.</para>
  </section>

  <section>
    <title>Functions</title>

    <para>Always declare a function return type. Never allow the computer to
    default to type <code>int</code>.</para>

    <para>Use <code>const</code> on any member function that does not change
    any data. It enforces the purpose of a function and allows for better
    compiler optimizations.</para>

    <para>When overriding a base class member function declared as virtual,
    declare the derived class member function virtual as well to avoid
    confusion.</para>

    <para>If a class implementation needs a local function, include that
    function in the class declaration as protected or private. Avoid declaring
    the function locally in the implementation, which limits code reusability.
    If the local function could be generalized consider making or adding it to
    a small utility library.</para>

    <section>
      <title>Function Arguments</title>

      <para>Function argument names are nouns and should begin with a lower
      case character and then follow the CamelCase convention. Try to always
      use two words to describe the argument (e.g.,
      <code>tmpValue</code>).</para>

      <para>Always declare function arguments as <code>const</code> if the
      function does not change their value.</para>

      <para>If a function does not take arguments, place the left and right
      parentheses adjacent to each other in both the function declaration and
      definition. Do not use the keyword void to indicate that there are no
      parameters.</para>

      <para>Always name a parameter. For example:</para>

      <para><code>// Use this: </code></para>

      <para><code>void SetFoo( int tmpValue ) </code></para>

      <para><code>// Do not use this: </code></para>

      <para><code>//void SetFoo( int )</code></para>
    </section>
  </section>

  <section>
    <title>Variables</title>

    <para>Always initialize member variables in the constructor. All instance
    variables are declared as protected. The user and application developer
    should access instance variables through Set/Get methods.</para>

    <para>Declare variables where they are first used. C++ lifted this
    restriction from C for a reason. It makes code more modular and easier to
    understand, modify, and debug.</para>

    <para>Always declare member variables as protected or private. Add public
    accessor methods to allow external access to the member variable.
    Initialize all member variables in the class constructor. Make sure to
    include the unit the variable represents as a suffix.</para>
  </section>

  <section>
    <title>Namespace</title>

    <para>Never place a <code>using</code> statement at global scope in a
    header file. This pollutes the namespace of any code that includes that
    header, and can cause runtime issues and invisible conflicts that are
    difficult to debug and hard to track. Restrict <code>using</code>
    statements to implementation files (if at all).</para>

    <para>Always use the fully qualified name for methods outside of the
    class, so for standard namespace keywords (<code>cout</code>,
    <code>cin</code>, <code>cerr</code>, <code>endl</code>,
    <code>vector</code>, <code>string</code>), you must
    <code>std::cout</code>, etc. Alternately, use <code>using</code> for
    specific functions or variables rather than global namespace inclusion.
    For example, if you only require the string class from the std namespace
    and it will appear frequently, use using <code>std::string;</code> instead
    of using <code>std;</code></para>
  </section>

  <section>
    <title>Headers</title>

    <para>Header files are for declarations only. It is difficult to read and
    find code if source is in the declarations.</para>

    <para>The header file of the class should include only the superclass
    header file. If you need any other include statements, add comments at
    each one describing why it should be included.</para>

    <para>Forward declare classes when possible to avoid including unnecessary
    header files in a class header file.</para>

    <para>Never place a <code>using</code> statement in a header file. This
    pollutes the namespace of any code that includes that header, and can
    cause runtime issues that are difficult to debug. Restrict
    <code>using</code> statements to implementation files.</para>

    <para>Header files should use guards to prevent multiple inclusion. These
    guards should be defined in the style <code>FILENAME_H</code>, which is
    the filename written in all upper case with punctuation such as dots
    (<code>.</code>) replaced by underscores.</para>

    <para><code>#ifdef CFDHEADER_H</code></para>

    <para><code>#define CFDHEADER_H</code></para>

    <para><code>...</code></para>

    <para><code>#endif // CFDHEADER_H</code></para>

    <para>You can also use the C Preprocessor to protect against multiple
    inclusions. Create a unique C Preprocessor identifier using the namespace,
    module, subdirectory, and file name. For example, given a file named
    <code>Contours.h</code> in the VE-Suite namespace in the Framework
    subdirectory of the Conductor module</para>

    <para><code>#ifdef VES_CONDUCTOR_FRAMEWORK_CONTOURS_H</code></para>

    <para><code>#define VES_CONDUCTOR_FRAMEWORK_CONTOURS_H</code></para>

    <para><code>...</code></para>

    <para><code>#endif // VES_CONDUCTOR_FRAMEWORK_CONTOURS_H</code></para>

    <para>Comment the end of every <code>#endif</code>, as shown above. Nested
    <code>#ifdef</code> can be difficult to follow.</para>

    <para>A new line after the last <code>#endif</code> is required by some
    compilers.</para>
  </section>

  <section>
    <title>Logic Style</title>

    <section>
      <title>Const</title>

      <para>Use <code>const</code> on any member function that does not change
      any data. It enforces the purpose of a function and allows for better
      compiler optimizations.</para>

      <para>Always pass strings by <code>const</code> reference unless you are
      intentionally modifying it for use by the calling function.</para>

      <para><code>void setName ( const std::string&amp; name )</code></para>

      <para><code>{</code></para>

      <para><code>mName = name;</code></para>

      <para><code>}</code></para>

      <para>Always pass an object by <code>const</code> reference if you are
      not intentionally modifying any part of it. Always mark the function
      <code>const</code> if it does not change any intentional state of the
      class.</para>

      <para><code>void printComparison( const NameObject&amp; name ) const
      </code></para>

      <para><code>{ </code></para>

      <para><code>std::cout &lt;&lt; mOurNameObject-&gt;getFoo() &lt;&lt; " :
      " &lt;&lt; name-&gt;getFoo() &lt;&lt; std::endl; </code></para>

      <para><code>}</code></para>

      <para>When following the above statements, do not pass plain old data
      types (POD) like <code>float</code>, <code>int</code>, or
      <code>double</code> by reference. Just mark them
      <code>const</code>.</para>

      <para><code>void printDouble ( const double myDouble )</code></para>

      <para><code>{</code></para>

      <para><code>std::cout &lt;&lt; myDouble &lt;&lt;
      std::endl;</code></para>

      <para><code>}</code></para>
    </section>

    <section>
      <title>#include organization</title>

      <para>Place all <code>#include</code> statements at the start of the
      file following the standard copyright/disclaimer comment block. Never
      use <code>#include</code> statements midway through a file following
      other source code.</para>

      <para>Organize <code>#include</code> statements at the top of each file
      by module, third party, and then system includes.</para>
    </section>

    <section>
      <title>Conditionals</title>

      <para>Never use the shorthand <code>?/:</code> conditional syntax, which
      inhibits readability. Always use the <code>if/else</code> syntax.
      Example:</para>

      <para>// Use this:</para>

      <para><code>int clamped_value;</code></para>

      <para><code>if( newValue &gt; mMaxValue )</code></para>

      <para><code>{</code></para>

      <para><code>clamped_value=mMaxValue;</code></para>

      <para><code>}</code></para>

      <para><code>else</code></para>

      <para><code>{</code></para>

      <para><code>clamped_value=newValue;</code></para>

      <para><code>}</code></para>

      <para>// Don't use this:</para>

      <para><code>//int clamped_value=newValue &gt; mMaxValue ? mMaxValue :
      newValue;</code></para>

      <para>Don't use single-line conditions. For example:</para>

      <para>// Use this:</para>

      <para><code>if( tmp_value == 0 ) </code></para>

      <para><code>{</code></para>

      <para><code>return;</code></para>

      <para><code>}</code></para>

      <para>// Don’t use this:</para>

      <para><code>//if( tmp_value == 0 ) return;</code></para>
    </section>

    <section>
      <title>Type Casting</title>

      <para>Always use the C++-style static_cast syntax rather than C-style
      type casting. This improves robustness by forcing you to place
      parentheses around the source data. Example:</para>

      <para><code>void Resize( int canvasWidth, int canvasHeight )
      </code></para>

      <para><code>{</code></para>

      <para><code>double aspect_ratio = static_cast&lt; double &gt;(
      canvasWidth ) / </code></para>

      <para><code>static_cast&lt; double &gt;( canvasHeight ); </code></para>

      <para><code>}</code></para>
    </section>

    <section>
      <title>Assertions</title>

      <para>Place assertions before code segments that would fail
      catastrophically if the assertion condition is false. Calls to assert()
      are only executed in unoptimized builds, so there is no performance risk
      in production builds with liberal assertion usage. If the assertion is
      potentially confusing, precede it with a comment explaining why the
      assertion must be true. Include &lt;cassert&gt; rather than
      &lt;assert.h&gt;. Example:</para>

      <para><code>#include &lt;cassert&gt; </code></para>

      <para><code>void FunctionName( int* indexAddress ) </code></para>

      <para><code>{</code></para>

      <para><code>assert( indexAddress != NULL ); </code></para>

      <para><code>int index = *indexAddress; </code></para>

      <para><code>...</code></para>
    </section>

    <section>
      <title>Switch Statements</title>

      <para>Wrap each case section with curly braces.</para>

      <para>If you intend one case to fall through to the next, place a
      plainly visible comment at the end of the first case stating that the
      fall through is intentional and explain why. Otherwise, always use a
      break statement at the end of each case section.</para>

      <para>Include a default section at the end of each switch
      statement.</para>
    </section>

    <section>
      <title>goto Statements</title>

      <para>Never use goto statements or labels.</para>
    </section>

    <section>
      <title>Globals and Statics</title>

      <para>Never use global variables. Consider using a singleton design
      pattern instead of a global variable.</para>

      <para>Avoid using static variables. An obvious exception is the instance
      pointer in a singleton object.</para>
    </section>

    <section>
      <title>Preprocessor Macros</title>

      <para>Overuse of the C Preprocessor can inhibit debugging. Avoid using
      the C Preprocessor where possible. Always use a standard function
      definition instead of a C Preprocessor macro for complex code segments.
      Never use a C Preprocessor macro as a shorthand mechanism for repeating
      code blocks. Here are some examples of appropriate use of the C
      Preprocessor:</para>

      <para><code>#define PI_OVER_4 0.7853981633974483096156 </code></para>

      <para><code>#define DEGREES_TO_RADIANS(DEGREES)( DEGREES *
      0.01745329251994329576923 )</code></para>

      <para>Use the C Preprocessor to protect against multiple inclusions of
      header files.</para>

      <para>Also, use the C Preprocessor to embed multiple implementations,
      such as in a stack-based factory design pattern implementation. For
      example:</para>

      <para><code>float maximum( float input0, float input1 ) </code></para>

      <para><code>{</code></para>

      <para><code>#ifdef WINDOWS </code></para>

      <para><code>return __max( input0, input 1 ) </code></para>

      <para><code>#else </code></para>

      <para><code>return std::max&lt;float&gt;( input0, input1 );
      </code></para>

      <para><code>#endif </code></para>

      <para><code>}</code></para>
    </section>

    <section>
      <title>Compiler and Linker Warnings</title>

      <para>All code should compile cleanly at the maximum warning level. This
      eliminates clutter in the compiler output stream and improves the
      visibility of any new warnings inadvertently introduced in the
      development process.</para>

      <para>As an exception, third party code is allowed to generate compiler
      warnings.</para>

      <para>During development, compile code with the <code>-pedantic</code>
      or <code>-Wall</code> compiler options to maximize warning
      verbosity.</para>

      <para>Compilers generate different warnings for 32- versus 64-bit
      compilations and debuggable versus optimized compilations. Test all
      compilation configurations to ensure your code does not introduce new
      warnings under any conditions.</para>
    </section>

    <section>
      <title>Array Indexing</title>

      <para>Single-character variable names can be easily mistaken for numbers
      ("I", for example, can sometimes look a lot like "1"). Make the array
      stand out with whitespace:</para>

      <para><code>array[ i ] = 0.0;</code></para>

      <para><code>array[ 1 ] = 0.0;</code></para>

      <para><code>array[ 2 ] = 0.0;</code></para>
    </section>

    <section>
      <title>Parens () with Keywords and Function Policy</title>

      <para>Do not put parens next to keywords. Put a space between keywords
      and parens.</para>

      <para>Do not use parens in return statements when it is not
      necessary.</para>

      <para>Do put parens next to function names.</para>

      <para>Example:</para>

      <para><code>if ( condition ) while ( condition ) </code></para>

      <para><code>{ { </code></para>

      <para><code>... ...</code></para>

      <para><code>} }</code></para>

      <para><code>strcpy( s, s1 ); return 1;</code></para>

      <para>Overuse parenthesis to clarify and clearly denote operator
      precedence in Boolean and algebraic formulas. For example:</para>

      <para>// Use this:</para>

      <para><code>if( ( x_index == 0 ) &amp;&amp; ( y_index == 0 )
      )</code></para>

      <para>// Don’t use this:</para>

      <para>// <code>if( x_index == 0 &amp;&amp; y_index == 0 )</code></para>
    </section>
  </section>

  <section>
    <title>Comment Format</title>

    <section>
      <title>Braces</title>

      <para>Use braces for all <code>if</code>, <code>while</code>,
      <code>switch</code>, <code>case</code>, <code>for</code>, and
      <code>do</code> statements even if there is only a single statement
      within the braces.</para>

      <para>Place braces under and inline with keywords. For example:</para>

      <para><code>if ( condition ) while ( condition ) </code></para>

      <para><code>{ // Note: curly brace is under and aligned with the ‘if’
      </code></para>

      <para><code>...</code></para>

      <para><code>}</code></para>

      <para>Use curly braces to limit variable scope. This improves
      readability by clearly defining the section of code that is affected by
      a given variable, and allows the compiler to more efficiently allocate
      hardware registers to variables. This is especially important when
      dealing with scoped locks. Put braces around the part where you need to
      hold on to the lock so the lock can go out of scope and release the
      lock.</para>
    </section>

    <section>
      <title>Text Formatting</title>

      <para>Limit lines to 80 characters.</para>

      <para>Three-space indentation: Set your editor to insert three spaces
      every time you hit the tab key.</para>

      <para>Insert white space for readability. This means that one blank line
      should occur between function definitions or between different blocks of
      code.</para>

      <para>For specific details on writing Doxygen-compliant and standardized
      comments, see Chapter 21, Documentation Notes.</para>

      <!-- TODO: Add olink to Chapter 16, Documentation Notes -->
    </section>

    <section>
      <title>Comments</title>

      <para>Comments should tell why something is coded the way it is. At
      every point where you choose between different options, insert a comment
      describing which choice you made and why. Comments need to be formatted
      for compatibility with Doxygen. See Chapter 10, Troubleshooting Guide,
      for further detail.</para>

      <!-- TODO: Add olink to Chapter 11, Trouble Shooting Guide -->

      <para>Use a standard copyright/disclaimer comment block at the top of
      each source file.</para>
    </section>
  </section>

  <section>
    <title>Docbook Documentation</title>

    <para>The following sections provide guidelines for editing the VE-Suite
    documentation using Docbook.</para>

    <section>
      <title>Typefaces</title>

      <para>When referring to filenames, file extensions, directory names,
      commands, or strings of code, use the code tag to differentiate the
      typeface from the text around it.</para>

      <para>Entering this:</para>

      <para><literal>Go to VE-Suite's &lt;code&gt;bin&lt;/code&gt; directory
      and type &lt;code&gt;python velauncher.py&lt;/code&gt;.</literal></para>

      <para>yields this in the docbook output:</para>

      <para>Go to VE-Suite's <code>bin</code> directory and type <code>python
      velauncher.py</code>.</para>

      <para>To draw users' attention to an important piece of information,
      type NOTE: and tag it with the Docbook emphasis role bold. That is,
      enter this:</para>

      <para><literal>&lt;emphasis
      role="bold"&gt;NOTE:&lt;/emphasis&gt;</literal></para>

      <para>to yield this:</para>

      <para><emphasis role="bold">NOTE:</emphasis></para>
    </section>

    <section>
      <title>Referring to VE-Suite's Versions</title>

      <para>When referring to a general version of VE-Suite or any application
      within VE-Suite, such as in a command, use <code>x.x.x</code> to refer
      to the version number rather than a number so the reference does not
      become outdated with future release versions. For example, in the
      following sentence, <code>vesuite.x.x.x.exe</code> and
      <code>vesuite_deps.x.x.x.exe</code> refer to the version of VE-Suite
      being used, and the user would change <code>x.x.x</code> to the
      appropriate version number. In addition, be sure to include the build
      number in the version as well. The build number is available in
      VE-Conductor under the About menu option.</para>

      <para>One installer, <code>vesuite.x.x.x.exe</code>, contains the core
      VE-Suite binaries and <code>.dll</code> files, while
      <code>vesuite_deps.x.x.x.exe</code> contains the binaries and .dll files
      of the dependencies for the current release of VE-Suite.</para>

      <para>In some cases, you might need to refer to a specific version of
      VE-Suite as the following example shows:</para>

      <para>Starting VE-Suite was simplified with the release of version 1.0.0
      via VE-Launcher.</para>
    </section>
  </section>
</chapter>
