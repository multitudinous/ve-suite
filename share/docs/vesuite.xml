<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book id="vesuite_documentation">
  <title>VE-Suite Documentation</title>

  <preface id="vesuite_intro">
    <title>Introduction to VE-Suite</title>

    <para>VE-Suite is an open source toolkit that enables virtual engineering
    analysis and design. This open source framework includes distributed
    computing, platform independence, extensibility for component models,
    support for a hierarchy of component models, and comprehensive graphics
    capabilities, including support for immersive facilities.</para>

    <para>VE-Suite is a software package built upon <ulink
    url="http://www.vrjuggler.org">VRJuggler</ulink>, <ulink
    url="www.openscenegraph.org"><ulink
    url="http://www.openscenegraph.org/">Open Scene Graph</ulink></ulink>,
    <ulink url="http://www.vtk.org/">Kitwareâ€™s Visualization ToolKit
    (VTK)</ulink>, CORBA compliant libraries (<ulink
    url="http://www.cs.wustl.edu/%7Eschmidt/TAO.html">ACE/TAO</ulink>), and
    <ulink url="http://www.wxwidgets.org/">wxWidgets</ulink>. Initially
    developed as a CFD visualization package, VE-Suite has matured into a
    software toolset which enhances engineers decision making capabilities. By
    integrating computational results from multiple disciplines into a common
    framework, VE-Suite helps the engineer analyze problems and make more
    complete solutions.</para>
  </preface>

  <part id="vesuite_users_guide">
    <title>Users Guide</title>

    <chapter id="vesuiteinstallsetup">
      <title>Installation and Setup</title>

      <para>Support is provided at the following locations: <ulink
      url="http://www.vesuite.org/forum/">VE-Suite Forums</ulink> -
      Users/developers can go here to access forums..</para>

      <para><ulink
      url="https://subversion.vrac.iastate.edu/Subversion/TSVEG/Bugzilla/">VE-Suite
      Bugzilla</ulink> - VE-Suite's interface for bug tracking.
      Users/developers can submit/view bugs.</para>

      <para>Installation of VE-Suite is fairly straight forward. Visit the
      <ulink url="http://www.vesuite.org/download.php">Downloads</ulink>
      section and locate your OS. Two installers are provided for Windows
      which guide you through the process of selecting various options. One
      installer (vesuite.1.0.0.exe) contains the core VE-Suite binaries and
      .dll files. The other (vesuite_deps.1.0.0.exe) contains the binaries and
      .dll files of the dependencies for the current release of
      VE-Suite.</para>

      <para>On UNIX/Linux, two tar.gz files are provided for the core VE-Suite
      files and its dependencies.</para>

      <para>In either case, extracting the files creates two directory
      structures:</para>

      <para><code>VE-Suite.x.x.x/</code></para>

      <para><code>VE_Suite.x.x.x_Dependencies/</code></para>

      <section>
        <title>Windows Installation</title>

        <para>Installing VE-Suite and its dependencies follows the same
        procedure as other installations. You'll choose their locations, which
        components to install, their Start Menu folder, and whether to have a
        desktop icon.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/windowsinstall.png" />
          </imageobject>
        </mediaobject>

        <para>Of particular note is which components to install. In large
        setups, certain computers will run the NameServer while others handle
        the Conductor and Xplorer. Since you're only running it on a single
        desktop, you'll want to install everything. Just leave all the
        checkboxes checked.</para>

        <para>Go through the same process for VE-Suite's dependencies.</para>
      </section>

      <section id="unix_installation">
        <title>UNIX Installation</title>

        <para>On Unix, the installers are compressed tar.gz files. You can
        open them using these commands:</para>

        <itemizedlist>
          <listitem>
            <para>Using GNU tar:</para>

            <para><code>gtar xvzf vesuite_1.0.1_RHEL_4.tar.gz </code></para>

            <para><code>gtar xvzf
            vesuite_deps1.0.1_RHEL_4.tar.gz</code></para>
          </listitem>

          <listitem>
            <para>Using gzip:</para>

            <para><code>gunzip &lt; vesuite_1.0.1_RHEL_4.tar.gz | tar xvf
            -</code></para>

            <para><code>gunzip &lt; vesuite_deps1.0.1_RHEL_4.tar.gz | tar xvf
            -</code></para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">Note</emphasis>: These examples use
        VE-Suite 1.0.1. Be sure to change the version number in the commands
        for later versions.</para>
      </section>

      <section id="setting_runtime_environment">
        <title>Setting the Runtime Environment</title>

        <para>In previous versions, VE-Suite's runtime environment was set
        through text scripts. Now it uses VE-Launcher to set up the
        environment. Most of it is automated, but you need to be aware of two
        important variables it sets: VE-Suite's directory and VE-Suite's
        Dependencies' directory.</para>

        <para>VE-Launcher automatically determines VE-Suite's directory from
        the current working directory. Moving the Launcher out of VE-Suite's
        directory or starting it from a different directory will pass the
        wrong value to VE-Suite, causing errors.</para>

        <para>The Dependencies directory is the only variable you need to set
        manually. The first time you start VE-Launcher, it will ask you to
        find the Dependencies directory. On Windows, it's simply the
        VE_Suite.1.#.#_Dependencies folder.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/runtimeenv1.jpg" />
          </imageobject>
        </mediaobject>

        <para>On Unix/Linux, the dependencies folder holds one folder for each
        system supported. You need to choose your system's corresponding
        folder as the Dependencies folder.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/runtimeenv2.jpg" />
          </imageobject>
        </mediaobject>

        <para>If you're upgrading from an earlier version of VE-Suite, you can
        also reset the Dependencies directory by clicking the Change
        Dependencies Folder button in VE-Launcher.</para>
      </section>
    </chapter>

    <chapter id="launcher">
      <title>Launcher</title>

      <section id="launcher_intro">
        <title>Introduction</title>

        <para>Starting VE-Suite has been simplified with the release of
        version 1.0.0 via VE-Launcher. VE-Launcher is a quick, easy way to
        launch any configuration of VE-Suite. It helps you save your
        configuration, choose which programs to run, and launch them without
        entering text commands. Even with all of the options and
        configurations available, choosing the one you need can still take
        some work. Here, we explain how to use the Launcher and provide an
        example of setting it up.</para>
      </section>

      <section id="launcher_basics">
        <title>The Basics</title>

        <para>You start VE Launcher by double-clicking VE-Suite's desktop
        icon, double-clicking the velauncher program in VE-Suite's folder, or
        typing "python velauncher.py" into an Unix terminal. On your first
        time running VE-Launcher, it will ask you to choose the VE-Suite's
        Dependencies folder. On Windows, this folder is named
        VE_Suite.#.#.#_Dependencies.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics1.jpg" />
          </imageobject>
        </mediaobject>

        <para>On Unix, the Dependencies folder contains folders for each
        system; you need to choose the one corresponding to your
        system.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Once VE-Launcher confirms it's a dependencies folder, it will
        show you the main window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics3.jpg" />
          </imageobject>
        </mediaobject>

        <itemizedlist>
          <listitem>
            <para>The Working Directory contains the fies you want to load.
            Set it to the files' directory.</para>
          </listitem>

          <listitem>
            <para>The Computation Engine Name and Port tell VE-Suite which
            computer and port to connect to.</para>
          </listitem>

          <listitem>
            <para>The Launch Mode lists five modes you can launch VE-Suite
            in:</para>

            <orderedlist>
              <listitem>
                <para>Desktop mode launches Conductor, Name Server, and
                Xplorer on your machine in Desktop mode.</para>
              </listitem>

              <listitem>
                <para>Tablet mode launches Conductor. It's made for use on
                tablets.</para>
              </listitem>

              <listitem>
                <para>Computation mode launches the Name Server. It's made for
                use on computational engines.</para>
              </listitem>

              <listitem>
                <para>Visualization mode launches Xplorer. It's made for
                viewing projects. It uses Custom's settings to choose VR
                Juggler's configuration and which type of Xplorer to
                run.</para>
              </listitem>

              <listitem>
                <para>As of 1.0.2: Shell mode lets the user work in a new
                shell with the VE-Suite environment set up. If you choose to
                launch in Shell mode, it will ask you whether you want to set
                up this shell for VE-Builder or not. If you do, it will add
                the VE-Builder directory you choose to the path. On Windows,
                launching Shell creates the shell in a window; simply close it
                to exit. On Unix, launching Shell makes the shell a child of
                your current terminal; type in "exit" to return to your
                original shell.</para>
              </listitem>

              <listitem>
                <para>Custom mode lets the user choose their own
                settings.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </itemizedlist>

        <para>The settings for every mode can be viewed and changed by
        clicking the Mode Settings button. Once you're done setting those,
        click the Launch VE-Suite button to close VE-Launcher and start
        VE-Suite.</para>

        <para>As of 1.0.2, the main window has a menu bar with the following
        menus:</para>

        <itemizedlist>
          <listitem>
            <para>File menu:</para>

            <itemizedlist>
              <listitem>
                <para>Open...: Pick a .ves or script shell file for
                launch.</para>
              </listitem>

              <listitem>
                <para>Close Files: Remove any .ves or script shell files from
                the launch.</para>
              </listitem>

              <listitem>
                <para>Quit.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Configurations menu:</para>

            <itemizedlist>
              <listitem>
                <para>Load: Load a previously-saved configuration.</para>
              </listitem>

              <listitem>
                <para>Save: Save the current configuration.</para>
              </listitem>

              <listitem>
                <para>Delete: Delete a previously-saved configuration.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherbasics4.jpg" />
          </imageobject>
        </mediaobject>

        <itemizedlist>
          <listitem>
            <para>Options menu:</para>

            <itemizedlist>
              <listitem>
                <para>Choose Dependencies: Change the Dependencies
                directory.</para>
              </listitem>

              <listitem>
                <para>Choose Builder Folder: Change the Builder
                directory.</para>
              </listitem>

              <listitem>
                <para>Debug Level: Choose the debug levels passed to
                VE-Suite.</para>
              </listitem>

              <listitem>
                <para>Cluster Wait Times: Customize the time VE-Suite waits
                between starting the master node and its slaves.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section id="launcher_mode_settings">
        <title>Mode Settings</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchermodesettings1.jpg" />
          </imageobject>
        </mediaobject>

        <para>You use the Mode Settings window to view and change settings.
        The Desktop, Tablet, and Computation modes only let you view their
        settings, while Visualization and Custom modes let you change some of
        them. Choices are faded out if you can't change them or if they
        wouldn't do anything. (For example, you can't choose which type of
        Xplorer to run if you're not running Xplorer.)</para>

        <para>Options you can set include:</para>

        <itemizedlist>
          <listitem>
            <para>Which VR Juggler configuration to use from the pulldown
            list. You can edit the list by clicking Edit Configuration List.
            We go into the List in more detail below.</para>
          </listitem>

          <listitem>
            <para>Which programs to run. You can choose to run Name Server,
            Conductor, and Xplorer. If you don't select any of them, VE-Suite
            won't launch (since it won't do anything without a program to
            launch.)</para>
          </listitem>

          <listitem>
            <para>Whether to run Conductor and Xplorer in Desktop Mode. This
            checkbox is disabled if you're launching neither Conductor nor
            Xplorer.</para>
          </listitem>

          <listitem>
            <para>Which type of Xplorer to run. OpenSceneGraph and OSG
            Patented will work for most projects, while OSG Patented Cluster
            is made for use on clustered computers. This radio list is
            disabled if you aren't launching Xplorer.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">Edit Configuration List</emphasis></para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchermodesettings2.jpg" />
          </imageobject>
        </mediaobject>

        <para>VE-Suite has over two dozen configuration files available. To
        help you keep track of them, VE-Launcher provides you with a
        configuration list you can add, rename, and delete entries from. The
        path to the currently selected entry is listed below, so you can tell
        which name stands for which file.</para>

        <para>When you add a new configuration to the list, its initial name
        is its file name. You'll want to rename it to something more
        descriptive.</para>
      </section>

      <section id="launcher_unix_clusters">
        <title>UNIX Clusters</title>

        <para>VE-Launcher versions 1.0.2+ have extra features for
        automatically starting up VE-Xplorer on other computers in a
        cluster.</para>

        <para>To use the cluster functions of VE-Launcher on Unix, your
        cluster must satisfy these requirements:</para>

        <orderedlist>
          <listitem>
            <para>The path to VE-Suite, its dependencies, and the working
            directory are the same on every cluster node.</para>
          </listitem>

          <listitem>
            <para>VE-Launcher's user has permission to <ulink
            url="http://www.employees.org/%7Esatch/ssh/faq/ssh-faq.html">ssh</ulink>
            to each node.</para>
          </listitem>

          <listitem>
            <para>The user has manually sshed into each node and authenticated
            its name.</para>
          </listitem>
        </orderedlist>

        <para>The last requirement needs some explanation. The first time you
        ssh into an unknown host, you need to manually authenticate its name.
        If it isn't authenticated and VE-Launcher tries to connect to it, it
        will hang the program. Therefore, you must manually ssh into each node
        on the cluster (including your current computer) and authenticate it
        before you can start the cluster using VE-Launcher. You must use the
        exact name you'll use in VE-Launcher; ssh treats partially-qualified
        (francis) and fully-qualified (francis.iastate.edu) names as separate
        users. Once you authenticate the other nodes, the authentication stays
        in your user profile permentantly.</para>

        <para>Once you have all the nodes authenticated, you can run the
        cluster from VE-Launcher:</para>

        <orderedlist>
          <listitem>
            <para>If you're running NameServer or Conductor on a certain node,
            open VE-Launcher from that node. (VE-Launcher runs NameServer and
            Conductor from the current computer.)</para>
          </listitem>

          <listitem>
            <para>Set the settings. When you select the Xplorer type OSG
            Patented Cluster, the Set Cluster Computers button will be
            enabled.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/unixcluster1.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Click Set Cluster Computers. A window will pop up showing
            the master and slaves listed. Put the master's name in, then add
            each slave's name to the list. Click OK when you're done.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/unixcluster2.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Launch VE-Suite by clicking the Launch button. The cluster
            computers will start up VE-Suite.</para>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">Note:</emphasis> There's a slight delay
        between each node launched. That's because simultaneous launching
        caused erratic behavior in the cluster. The delay can be changed
        through the Options-&gt;Cluster Wait Times menu. If you're
        encountering problems with sync or unconnected nodes using
        VE-Launcher, try lengthening the delays. If it's taking too long to
        launch the cluster, try shortening them.</para>
      </section>

      <section id="launcher_windows_clusters">
        <title>Windows Clusters</title>

        <para>VE-Launcher versions 1.0.2+ can start VE-Suite across a Windows
        cluster through <ulink
        url="http://www.sysinternals.com/Utilities/PsExec.html">PsExec</ulink>.</para>

        <para>To use the cluster functions of VE-Launcher on Unix, your
        cluster must satisfy these requirements:</para>

        <orderedlist>
          <listitem>
            <para>The path to VE-Suite, its dependencies, and the working
            directory are the same on every cluster node.</para>
          </listitem>

          <listitem>
            <para><ulink
            url="http://www.sysinternals.com/Utilities/PsExec.html">PsExec</ulink>
            is installed on the computer you're running VE-Launcher on.</para>
          </listitem>
        </orderedlist>

        <para>To launch the cluster:</para>

        <orderedlist>
          <listitem>
            <para>If you're running NameServer or Conductor on a certain
            computer, open VE-Launcher from that computer. (VE-Launcher runs
            NameServer and Conductor from the current computer.)</para>
          </listitem>

          <listitem>
            <para>Select Custom mode and set your settings as usual. When you
            choose which Xplorer Type to run, select OSG Patented Cluster.
            This enables the Set Cluster Computers button.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/windowscluster1.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Click Set Cluster Computers. A window will pop up showing
            the master and slaves listed, plus an optional username field. Put
            the master's name in, then add each slave's name to the
            list.</para>

            <para>Some clusters might require you to connect as a certain
            user; if so, just enter your username into the User Name field.
            The username's domain may need to be included as well, depending
            on your cluster's setup. If you pass your username, you will have
            to manually enter your password in each Psexec window when it
            launchers; VE-Launcher doesn't send passwords for security
            reasons.</para>

            <para>Click OK when you're done.</para>

            <mediaobject>
              <imageobject>
                <imagedata fileref="veimages/windowscluster2.jpg" />
              </imageobject>
            </mediaobject>
          </listitem>

          <listitem>
            <para>Launch VE-Suite by clicking the Launch button. The cluster
            computers will start up VE-Suite.</para>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">Note:</emphasis> There's a slight delay
        between each node launched. That's because simultaneous launching can
        cause erratic behavior in the cluster. The delay can be changed
        through the Options-&gt;Cluster Wait Times menu. If you're
        encountering problems with sync or unconnected nodes using
        VE-Launcher, try lengthening the delays. If it's taking too long to
        launch the cluster, try shortening them.</para>

        <para><emphasis role="bold">The cluster template: </emphasis>If your
        cluster needs extra code to launch (for example, a net use command to
        set up a remote drive), you can enter the code into the
        clusterTemplate.txt file. Any terminal code in the clusterTemplate.txt
        file will run on the cluster's other computers before Xplorer is
        launched. Please read the comments in clusterTemplate.txt for more
        details.</para>

        <para><emphasis role="bold">Note: </emphasis>There is a bug in
        VE-Launcher 1.0.2 where the cluster template code isn't separated from
        the standard code by a line break. Be sure to put in a line break
        after the last line of code in the template to avoid errors from a
        merged line.</para>
      </section>

      <section id="launcher_example">
        <title>Example</title>

        <para>John Doe wants to set up VE-Suite to look at a virtual power
        plant design. He needs to set it in Visualization mode, using the VR
        Juggler configuration "standalone" and the Open Scene Graph Xplorer.
        It also has to connect to computer kiwi on port 1239.</para>

        <para>When he starts VE-Launcher, he sees this:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample1.jpg" />
          </imageobject>
        </mediaobject>

        <para>First he types the path to the plant design data folder in the
        Working Directory field. (He could also use the Choose Working
        Directory button to find it.)</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample2.jpg" />
          </imageobject>
        </mediaobject>

        <para>He needs to change the CE's name, but he can't because the
        Launcher's currently in Desktop mode, which automatically sets the
        CE's name to localhost. To unlock the CE's name, he switches to
        Visualization mode. (Any mode besides Desktop will let you change the
        CE's name.)</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample3.jpg" />
          </imageobject>
        </mediaobject>

        <para>Switching modes unlocks the CE name and sets it to the last
        user-inputted value. Now John can change the CE name and port.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample4.jpg" />
          </imageobject>
        </mediaobject>

        <para>To finish setting up the Launcher, John has to change the mode's
        settings. He clicks on the Mode Settings button to bring up the
        Settings window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample5.jpg" />
          </imageobject>
        </mediaobject>

        <para>Visualization mode sets most of the options, and Open Scene
        Graph is already selected. That just leaves changing the Xplorer
        configuration. The configuration he needs isn't on the list yet,
        though. John clicks the Edit Configuration List button.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample6.jpg" />
          </imageobject>
        </mediaobject>

        <para>Since it isn't on the list, he adds it.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample7.jpg" />
          </imageobject>
        </mediaobject>

        <para>It's automatically added to the list as standalone. John renames
        it to Plant Design so he can remember which project it's for.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launcherexample8.jpg" />
          </imageobject>
        </mediaobject>

        <para>Now that he's done editing the list, John exits the Xplorer
        Configuration window. Since he had Plant Design selected when he left,
        it's automatically set as his current configuration file. With
        everything set as he wanted, John can now click Launch VE-Suite to
        look at the design.</para>
      </section>
    </chapter>

    <chapter id="running_vesuite">
      <title>Running VE-Suite</title>

      <para>VE-Suite contains three programs you can run: the Naming Service,
      which allows you to connect to VE-CE; VE-Conductor, which provides the
      controls; and VE-Xplorer, which displays the scene. All three can be
      launched from VE-Launcher. The final step is connecting VE-Conductor to
      the naming server. This lets you process and manipulate the chosen
      dataset.</para>

      <section id="starting_vesuite">
        <title>Starting VE-Suite</title>

        <para>VE-Launcher is the gateway to VE-Suite. To open VE-Launcher,
        Windows users should double-click the VE-Suite desktop icon or
        velauncher.exe in the VE_Suite folder. Unix/Linux users should go into
        the VE_Suite folder and enter:</para>

        <para>python velauncher.py</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/startingvesuite1.jpg" />
          </imageobject>
        </mediaobject>

        <para>If this is your first time running VE-Launcher, it will ask for
        the Dependencies folder (see Chapter 1.2&lt;link&gt;) before bringing
        you to the main window.</para>

        <para>The launcher has some advanced commands, but we can ignore them
        for now. Make sure Desktop mode is selected and click the Launch
        button. VE-Launcher will launch the Naming Service, VE-Conductor, and
        VE-Xplorer in Desktop mode.</para>

        <para>If you want to learn more about how to use VE-Launcher, check
        out the VE-Launcher guide here&lt;link&gt;.</para>
      </section>

      <section id="loading_data_and_connecting">
        <title>Loading Data and Connecting</title>

        <para>VE-Suite loads objects through plug-ins. Here we will show you
        how to load a geometry file through a plug-in; other data files may be
        loaded in the same manner.</para>

        <para>You set up plug-ins through the "Available Objects" window on
        the right side of the screen. To create a new plugin, double-click on
        the red "Available Modules" folder, then double-click on the
        DefaultPlugin. A gray box will appear next to it. Right click on this
        box to access the plugin's menu. Select the "Geometry Config" option
        as shown.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata1.jpg" />
          </imageobject>
        </mediaobject>

        <para>A new window will open on the design canvas, the CADTree
        Manager. This holds the objects you insert into your plugin. To select
        a geometry file, right-click on the Model_Geometry folder in the
        canvas and select Add Node-&gt;Load CAD file.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Another window will appear. Choose the file's type, select the
        file, then click Open.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata3.jpg" />
          </imageobject>
        </mediaobject>

        <para>The program will ask you to name the object you loaded, then
        insert it into the plugin. Add any other objects you want to include
        in the same way. Once this is completed, click Close on the design
        canvas.</para>

        <para>The information for the plug-in's node needs to be loaded to the
        rest of VE-Suite. This is done by choosing Submit job from the
        Connection menu.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata4.jpg" />
          </imageobject>
        </mediaobject>

        <para>The starting logo in VE-Xplorer should be replaced by the
        objects in the plugins you submitted.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/loadingdata5.jpg" />
          </imageobject>
        </mediaobject>

        <para>If the object is not initially found in the VE-Xplorer window,
        it may be outside the viewing region. If so, hold down the right mouse
        button and drag down in the VE-Xplorer window to pull back the camera;
        continue doing so until you can see the scene.</para>
      </section>

      <section id="navigation">
        <title>Navigation</title>

        <para>There are two ways to manipulate VE-Suite's view using just the
        mouse: dragging in the Xplorer window itself or using the Navigation
        Pane.</para>

        <section id="xplorerwindow">
          <title>Xplorer Window</title>

          <para>If you have a 3-button mouse, you can do every translation and
          rotation within the Xplorer window itself.</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/navigation1.gif" />
            </imageobject>
          </mediaobject>

          <para>To rotate the scene, drag along the screen while holding the
          left button. To rotate along the X- and Z-axes, drag in the center
          of the screen. To rotate along the Y-axis, drag along the border of
          the screen.</para>

          <para>The right mouse button handles Y-axis translations. Hold the
          right button and drag the mouse up or down to push the scene away or
          pull it closer.</para>

          <para>The mouse wheel button handles the other translations. Hold it
          down to drag the scene left, right, up, or down across the
          screen.</para>
        </section>

        <section id="navigatio_npane">
          <title>Navigation Pane</title>

          <para>To open the Navigation pane, select Navigation Pane from the
          VE-Xplorer menu:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/navigation2.jpg" />
            </imageobject>
          </mediaobject>

          <para>The Navigation pane will appear below:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="veimages/navigation3.jpg" />
            </imageobject>
          </mediaobject>

          <para>Experiment with the movement buttons (the ones with arrows on
          them) to see how they change the scene. Note that they move the
          camera, not the object; clicking the left X-axis button, for
          example, will move the camera left, making the object shift
          right.</para>

          <para>Most of the other controls modify how the movement buttons
          act:</para>

          <itemizedlist>
            <listitem>
              <para>The Step Size sliders control the speed of translations
              and rotations. The farther to the right they are, the faster
              translations and rotations occur.</para>
            </listitem>

            <listitem>
              <para>Rotate About Users Head controls how the camera reacts to
              Yaw Rotation commands. If it's checked, the camera rotates in
              place. If it isn't, the camera rotates around the environment
              center, like the roll and pitch rotations.</para>
            </listitem>
          </itemizedlist>

          <itemizedlist>
            <listitem>
              <para>Reset Nav Position resets the camera to its initial
              position.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section id="quitting_vesuite">
        <title>Quitting VE-Suite</title>

        <para>Ending your VE-Suite session takes two steps:</para>

        <orderedlist>
          <listitem>
            <para>Select Quit from VE-Conductor's File menu. This quits
            Conductor and Xplorer.</para>
          </listitem>

          <listitem>
            <para>Select the shell window running the Name Server. Close it or
            press Ctrl-C to break the program.</para>
          </listitem>
        </orderedlist>
      </section>
    </chapter>

    <chapter id="visualizations">
      <title>Visualizations</title>

      <para>This chapter describes how to make visualizations using the
      VE-Suite toolkit and a sample dataset. If you want to follow this
      example, download and unzip the sample PrISUm car dataset: <ulink
      url="http://www.vesuite.org/File/PrISUm.zip">PrISUm.zip</ulink>
      (138MB)</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="veimages/visualization1.jpg" />
        </imageobject>
      </mediaobject>

      <section id="visualization_setup">
        <title>Setup</title>

        <para>Visualizations requires two files: a geometry config file and a
        dataset file. Both have properties, such as scale and translation,
        that can be modified to ensure they line up.</para>

        <para>First, open VE-Launcher and set the working directory to the
        PrISUm folder. Next, open up VE-Suite in Desktop mode from
        VE-Launcher. Load the PrISUmblend.obj CAD file, but don't close the
        CADTree Manager window yet. (See Chapter 2.2)</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Right-click on the Model_Geometry folder again and choose
        Properties. A CAD Properties window will pop up. We can use this to
        change PrISUm's properties. We need to know what to change them to,
        though.</para>

        <para>Open the PrISUm folder from the desktop and look for the
        vrxpr.param file. This file contains parameter info for PrISUm, which
        we'll enter into the Properties window. Open it using a text editor,
        look for the 3x3 block underneath the number 9, and enter the values
        into the Properties window. Be sure to note the rows go in a different
        order in the Properties window than in the .param file:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Once the parameters are entered, close the CAD Properties and
        CADTree Manager window. Now right-click on our grey plugin box again
        and chose Data Set Config. We need to add the dataset to it.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup3.jpg" />
          </imageobject>
        </mediaobject>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup4.jpg" />
          </imageobject>
        </mediaobject>

        <para>First, click Add Dataset to name your dataset configuration.
        Then click Open under DataSet Filename and choose the outFile3.vtk
        file as your dataset. You don't need to change any of the other
        settings for PrISUm, so just click Load to load the dataset and exit
        the window.</para>

        <para>Once that's done, choose Submit Job from the Connection menu to
        display the PrISUm car. Use the navigation pane to adjust the view
        until you get a good view of it.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/visualizationsetup5.jpg" />
          </imageobject>
        </mediaobject>
      </section>

      <section id="visualization_scalar_planes">
        <title>Scalar Planes</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Now that the plugin is set up, we can use the Visualization
        interface to show scalar planes, like the one above. Visualization not
        only lets you access scalar contours, but vector planes, isosurfaces,
        and more.</para>

        <para>To bring up the Visualization interface, right-click on the
        plug-in to access the menu and select Visualization. This window will
        appear:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Click on the Scalar Contours button (the leftmost icon) to bring
        up the Scalar Contours interface.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes3.jpg" />
          </imageobject>
        </mediaobject>

        <para>Notice you can choose the plane's orientation and position. For
        now, set the Direction to Y and the plane's position to 50 and click
        Add Plane. This should appear on your screen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/scalarplanes4.jpg" />
          </imageobject>
        </mediaobject>

        <para>Once you're done looking at the contour planes, you can remove
        them from the screen by clicking Clear All on the Visualization
        interface. This will clear any Visualization features from
        VE-Xplorer.</para>
      </section>

      <section id="visualization_vector_planes">
        <title>Vector Planes</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Showing vector planes is almost exactly like showing scalar
        planes. First, open up the Visualization interface again by
        right-clicking on the plug-in and selecting Visualization.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes2.jpg" />
          </imageobject>
        </mediaobject>

        <para>This time, click on the Vector button (the 2nd-to-left icon) to
        open the Vector Contour window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes3.jpg" />
          </imageobject>
        </mediaobject>

        <para>The Vector Contour window is very similar to the Scalar Contour
        window. This time, set the Direction to Z and the plane's position to
        20 and click Add Plane. This should appear on your screen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/vectorplanes4.jpg" />
          </imageobject>
        </mediaobject>

        <para>Just like the scalar plane, you can remove the vector plane by
        clicking Clear All on the Visualization interface.</para>
      </section>

      <section id="visualization_isosurfaces">
        <title>Isosurfaces</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces1.jpg" />
          </imageobject>
        </mediaobject>

        <para>To generate an isosurface, go back to the Visualization
        interface (right-click on the plug-in, select Visualization).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces2.jpg" />
          </imageobject>
        </mediaobject>

        <para>Before you can open the Isosurfaces window, you'll also need to
        choose a scalar or vector file. Choose scalars under Scalars and click
        the Isosurfaces button (the 3rd-from-right icon) to open the
        Isosurfaces window.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces3.jpg" />
          </imageobject>
        </mediaobject>

        <para>The Isosurfaces window only has one setting. Set the Isosurface
        pressure to 50 and click Compute Isosurface. This should appear on
        your screen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/isosurfaces4.jpg" />
          </imageobject>
        </mediaobject>

        <para>Exit Visualization and examine the isosurface by using the mouse
        or the Navigation pane. Once you're done, reenter Visualization and
        click Clear All.</para>
      </section>
    </chapter>

    <chapter id="vebuilder">
      <title>VE-Builder</title>

      <section id="vebuilder_intro">
        <title>Introduction</title>

        <para>VE-Builder is a set of tools for modifying 3D data files for
        VE-Suite. Here is a list of functions we provide documentation
        for:</para>

        <para><link linkend="???">Importing Files</link> &lt;link&gt;</para>

        <para>Importing from StarCD &lt;link&gt;</para>

        <para>Importing from Fluent (.avs) &lt;link&gt;</para>

        <para>Creating Preprocessed Data &lt;link&gt;</para>

        <para>Creating Texture-Based Datasets &lt;link&gt;</para>
      </section>

      <section id="launching_vebuilder">
        <title>Launching VE-Builder</title>

        <para>To run VE-Builder, you need a VE-Suite shell environment.
        Therefore, to run VE-Builder tools from VE-Launcher, select the Shell
        mode. A popup will appear, asking if you want to configure this shell
        for VE-Builder:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchingbuilder1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Select Yes. If you haven't chosen the VE-Builder directory
        before, it will ask you to choose it. Otherwise, it will bring up a
        shell with the VE-Builder environment. If you want to change the
        VE-Builder directory, choose Change Builder Folder from under the
        Options menu and select the VE_BuilderTolls directory.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/launchingbuilder2.jpg" />
          </imageobject>
        </mediaobject>
      </section>

      <section id="importing_files">
        <title>Importing Files</title>

        <para>The loaderToVtkd program transforms prepared 3D data files from
        other programs into VE-Suite files. First, prepare the environment for
        it by launching a Builder Shell from <link
        linkend="launching_vebuilder">VE-Launcher</link>. Then you can use
        loaderToVtkd to import files into VE-Suite formats. The general syntax
        of the program is:</para>

        <para><code>loaderToVtkd -singleFile [input filename] -loader [loader
        type]</code></para>

        <para><code>-o [full path to the output directory] -w file
        </code></para>

        <para>(The name of the output file isn't set in the command line
        because there is currently a bug renaming the file. This will be fixed
        later.)</para>

        <para>To see loaderToVtkd's options, type in:</para>

        <para><code>loaderToVtkd</code></para>

        <para>loaderToVtkd supports the following loader types:</para>

        <para><itemizedlist>
            <listitem>
              <para>REI (BANFDB)</para>
            </listitem>

            <listitem>
              <para>AVS (avs)</para>
            </listitem>

            <listitem>
              <para>Dicom (dcm)</para>
            </listitem>

            <listitem>
              <para>EnSight (ens)</para>
            </listitem>

            <listitem>
              <para>MFIX (mfix)</para>
            </listitem>

            <listitem>
              <para>StarCD (star)</para>
            </listitem>
          </itemizedlist>It also supports Plot3D, but with this syntax:</para>

        <para><code>loaderToVtkd -geometryFileXYZ [input filename] -dataFileQ
        [input filename2] </code></para>

        <para><code>-o [full path to the output directory] -multiGrid Flag
        [0:1] -iblankFlag [0:1] -numberofDimensions [0:1] </code></para>

        <para><code>-outFileName [output file] -loader xyz -w file
        </code></para>

        <para>We also have detailed instructions for preparing and importing
        data files from these programs:</para>

        <para><link linkend="importing_from_starcd">StarCD</link></para>

        <para><link linkend="importing_from_fluent">Fluent (AVS)</link></para>
      </section>

      <section id="importing_from_starcd">
        <title>Importing from StarCD</title>

        <section id="preparing_starcd_files">
          <title>Preparing the StarCD Files</title>

          <para>First, you need star.cel. star.vrt. and a star.usr files from
          StarCD. If you need help getting them from StarCD, look at the
          instructions here &lt;link&gt;. [This file needs to be added to xml
          file]</para>

          <para>Next, you need to make a star.param file to point to the
          star.cel. star.vrt. and a star.usr files. Save our template (<ulink
          url="http://www.vesuite.org/File/star.param">star.param</ulink>) to
          your working directory and follow the instructions below to modify
          it for your data:</para>

          <para><code>STARCEL=/your_directory/star.cel // a *.cel file is
          required </code></para>

          <para><code>STARVRT=/your_directory/star.vrt // a *.vrt file is
          required </code></para>

          <para><code>STARUSR=/your_directory/star.usr // a *.usr file is
          required</code></para>

          <para>Set these to point to your .cel, .vrt, and .usr files.</para>

          <para><code>VECTORNAME=Velocity // the columns of the *.usr file
          must be labeled </code></para>

          <para><code>SCALARNAME=scalar1 // the columns of the *.usr file must
          be labeled </code></para>

          <para><code>SCALARNAME=scalar2 // the columns of the *.usr file must
          be labeled </code></para>

          <para><code>SCALARNAME=scalar3 // the columns of the *.usr file must
          be labeled</code></para>

          <para>Change these lines to their respective scalars.</para>

          <para><code>SCALEINDEX=1 // optional: uses integer indices defined
          in translateToVtk.cpp to set scale factor </code></para>

          <para>Enter an integer option on the SCALEINDEX:</para>

          <itemizedlist>
            <listitem>
              <para>0: No scale, corresponding to a scale of 1.0</para>
            </listitem>

            <listitem>
              <para>1: Custom scale, indicating that the SCALEFACTOR tag will
              be used to specify a scale factor</para>
            </listitem>

            <listitem>
              <para>2: Meters to feet, corresponding to a scale factor of
              3.28</para>
            </listitem>

            <listitem>
              <para>3: Millimeters to feet, corresponding to a scale factor of
              3.28e-3</para>
            </listitem>

            <listitem>
              <para>4: Inches to feet, corresponding to a scale factor of
              1.0/12.0</para>
            </listitem>

            <listitem>
              <para>5: Meters (1:12) scale to feet, corresponding to a scale
              factor of 12.0*3.28</para>
            </listitem>
          </itemizedlist>

          <para><code>SCALEFACTOR=.083333333 // optional: the scale factor
          (default = 1, unless SCALEINDEX &gt;1)</code></para>

          <para>VR space is always in feet, so the scale factor tag must be in
          feet. If you chose a SCALEINDEX of 0 or 1, comment out this
          line.</para>

          <para><code>WRITEOPTION=1 // optional: 0=let vtk write the
          file(default), 1=directly write ascii to disk </code></para>

          <para>The Writeoption is no longer needed. Set it to 0 or remove
          it.</para>
        </section>

        <section id="conversion_to_vtu">
          <title>Conversion to a .VTU File</title>

          <para>Start up a Builder Shell from <link
          linkend="launching_vebuilder">VE-Launcher</link>. Be sure to set the
          working directory to the star.param's directory. Then enter the
          following code:</para>

          <para><code>loaderToVtkd -singleFile star.param -loader star -o
          [full path to the output directory] -w file</code></para>

          <para><emphasis role="bold">Note: </emphasis>There is currently a
          bug for renaming the file, so don't set it in the command line or
          the star.param file. This will be fixed later. After the code
          executes, it will dump a .vtu file of the data in the directory you
          specified.</para>
        </section>
      </section>

      <section id="importing_from_fluent">
        <title>Importing from Fluent (AVS)</title>

        <para>You will need to write out an .avs file for the post-processed
        data from Fluent. Place it into your working directory. Open a Builder
        Shell from <link linkend="launching_vebuilder">VE-Launcher</link>. Be
        sure to set the working directory to the avs file's directory. You can
        then convert it with this command:</para>

        <para><code>loaderToVtkd â€“singleFile [AVS filename] â€“loader avs â€“o
        [working directory] â€“w file</code></para>
      </section>

      <section id="creating_preprocess_data">
        <title>Creating Preprocessed Data</title>

        <para>You will need a .vtu file to create preprocessed data. Start a
        Builder Shell from <link
        linkend="launching_vebuilder">VE-Launcher</link>. Be sure to set the
        working directory to the .vtu file's directory. Check if there's a
        directory called POST_DATA in it. If not, make the POST_DATA
        directory. Once it's ready, type in:</para>

        <para><code>preprocessor </code></para>

        <para>The first prompt will ask for a filename. Type in the .vtu's
        filename. The second prompt will ask for a directory to dump the data
        into. Type in the full path to the directory you want the preprocessed
        data in. The program will then ask you what you want to extract; once
        you finish making your choices, it will execute and produce your
        preprocessed data.</para>
      </section>

      <section id="creating_texture_based_datasets">
        <title>Creating Texture-Based Datasets</title>

        <para>Launch a Builder Shell from <link
        linkend="launching_vebuilder">VE-Launcher</link> and enter the
        following:</para>

        <para><code>vtkTo3DTexture</code></para>

        <para>This will launch the translator interface:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/creatingtexturebased1.jpg" />
          </imageobject>
        </mediaobject>

        <para>Select the desired parameters from the GUI and press the
        "Translate" button. Input parameters include:</para>

        <para><itemizedlist>
            <listitem>
              <para>Input directory: Directory containing the input vtk
              dataset files.</para>
            </listitem>

            <listitem>
              <para>Output directory: Directory to write out the texture data
              and the texture description files.</para>
            </listitem>

            <listitem>
              <para>Texture Dimension: The resolution (~sampling rate) of the
              output textures.</para>
            </listitem>

            <listitem>
              <para>Grid type: Input vtk datasets' grid structure.</para>
            </listitem>
          </itemizedlist>A progress dialog will appear as the input vtk files
        are translated to 3d texture data files that are useable in
        VE-Suite.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="veimages/creatingtexturebased2.jpg" />
          </imageobject>
        </mediaobject>

        <para><emphasis role="bold">Batch Mode</emphasis></para>

        <para>The translator can also be run in a â€œbatchâ€ mode. To run in
        batch mode, enter this on the command line:</para>

        <para><code>vtkTo3DTexture -o
        /home/users/mcdoe/LTN/3D_Jets_Test/jets_vti </code></para>

        <para><code>-x 32 -y 64 -z 32
        /home/users/mcdoe/LTN/3D_Jets_Test/Jets_Data</code></para>

        <para>where:</para>

        <itemizedlist>
          <listitem>
            <para>-o specifies the output directory for the 3d vti texture
            files</para>
          </listitem>

          <listitem>
            <para>-x is the x resolution for the texture</para>
          </listitem>

          <listitem>
            <para>-y is the y resolution for the texture</para>
          </listitem>

          <listitem>
            <para>-z is the z resolution for the texture</para>
          </listitem>

          <listitem>
            <para>The last argument is the data input directory for vt(u,k,s)
            files.</para>
          </listitem>
        </itemizedlist>

        <para>The batch mode also supports parallel processing (MPI) which is
        convenient for large transient datasets. To run in batch mode with MPI
        you must first install the mpi library. We recommend <ulink
        url="http://www.lam-mpi.org/7.1/download.php">LAM/MPI</ulink>. This is
        available for most linux platforms. To run with LAM/MPI a script
        should be created similar to:</para>

        <para><code>#!/bin/tcsh</code></para>

        <para><code>setenv VE_SUITE_HOME
        /home/users/mcdoe/svn_VE_Suite/VE_Suite &amp;&amp; source
        $VE_SUITE_HOME/VE_Installer/setup.tsh </code></para>

        <para><code>vtkTo3DTextureMPI -o
        /home/users/mcdoe/LTN/3D_Jets_Test/jets_vti -x 32 -y 64 -z 32
        /home/users/mcdoe/LTN/3D_Jets_Test/Jets_Data </code></para>

        <para>Which should then be executed like:</para>

        <para><code>mpirun â€“np 2 ./ </code></para>
      </section>
    </chapter>
  </part>

  <part id="developer_info">
    <title>Developer Information</title>

    <chapter id="code_guidelines">
      <title>Code Guidelines</title>

      <section id="class_structure_guidelines">
        <title>Class Structure</title>

        <para>We only put one public class per file. Every class name, macro,
        etc. starts with either "cfd" or "CFD" to avoid name clashes with
        other libraries. Classes should all start with "cfd" and macros or
        constants can start with either. Class names and file names are the
        same (e.g., cfdContours class is declared in cfdContours.h and
        implemented in cfdContours.cpp). This makes it easier to find the
        correct file for a specific class. All instance variables are delcared
        as protected. The user and application developer should access
        instance variables through Set/Get methods.</para>

        <para><emphasis role="bold">Always</emphasis> initialize member
        variables in the constructor.</para>
      </section>

      <section id="names_guidelines">
        <title>Names</title>

        <para>Make names clear. Try to spell out a name and not use
        abbreviations. This leads to longer names but it makes using the
        software easier because you know that the SetRasterFontRange method
        will always be called that, not SetRFRange or SetRFontRange or SetRFR.
        When the name includes a natural abbreviation such as OpenGL, we keep
        the abbreviation and capitalize the abbreviated letters. We only use
        alphanumeric characters in names, [a-zA-z0-9]. We do not use
        underscores ("_"), so names like exterior_Surface or _exteriorSurface
        are not welcome. We use capitalization to indicate words within a
        name. For example, a class could be called cfdVectorTopologyFilter.
        Use "this" inside of methods even though C++ does not require you to.
        This really seems to make the code more readable because it
        disambiguates between instance variables and local or global
        variables. It also disambiguates between member functions and other
        functions.</para>
      </section>

      <section id="class_names_guidelines">
        <title>Class Names</title>

        <para>Class names are nouns and usually start with "cfd".</para>
      </section>

      <section id="variable_names_guidelines">
        <title>Variable Names</title>

        <para>Variable names are nouns and should begin with a lower case
        character.</para>
      </section>

      <section id="function_names_guidelines">
        <title>Function Names</title>

        <para>Function names are verbs (e.g., SetRasterFontRange) and start
        with an upper case letter.</para>
      </section>

      <section id="functions_and_arguments_guidelines">
        <title>Functions and Function Arguments</title>

        <para>Use const on any member function that does not change any data.
        It enforces the purpose of a function and allows for better compiler
        optimizations.</para>
      </section>

      <section id="variable_usage_guidelines">
        <title>C++ Style Variable Usage</title>

        <para>Declare variables where they are first used. C++ lifted this
        restriction from C for a reason. It makes code more modular and easier
        to understand, modify, and debug.</para>
      </section>

      <section id="braces_guidelines">
        <title>Braces</title>

        <para>Place brace under and inline with keywords: </para>

        <para><code> if ( condition ) while ( condition ) </code></para>

        <para><code> { { </code></para>

        <para><code> ... ... </code></para>

        <para><code> } }</code> </para>

        <para>Use braces for all if, while and do statements even if there is
        only a single statement within the braces.</para>
      </section>

      <section id="header_files_guidelines">
        <title>Header Files</title>

        <para>Header files are for declarations only. It is difficult to read
        code and find code if source is in the declarations. </para>

        <para>The header file of the class should include only the superclass
        header file. If you need any other includes, include comment at each
        one describing why it should be included. </para>

        <para>Forward declare classes when possible in header files. </para>

        <para>Header files should use guards to prevent multiple inclusion.
        These guards should be defined in the style FILENAME_H, which is the
        filename written in all upper case with punctuation such as dots (".")
        replaced by underscores ("_"). </para>

        <para><code> #ifndef CFDHEADER_H </code></para>

        <para><code> #define CFDHEADER_H </code></para>

        <para><code> ... </code></para>

        <para><code> #endif // CFDHEADER_H</code></para>

        <para>Comment the end of every #endif, as shown above. Nested #ifdef
        can be difficult to follow. </para>

        <para>A new line after the last endif if is required by some
        compilers.</para>
      </section>

      <section id="text_formatting_guidelines">
        <title>Text Formatting</title>

        <para>Limit lines to 80 characters. </para>

        <para>Three (3) space indentation â€“ Set your editor to insert three
        spaces every time you hit the tab key. </para>

        <para>Insert whitespace for readability. This means that one blank
        line should occur between function definitions or between different
        blocks of code.</para>
      </section>

      <section id="namespaces_guidelines">
        <title>Namespaces</title>

        <para>Do not place the "using namespace" directive at global scope in
        a header file. This can cause lots of invisible conflicts that are
        hard to track. Keep "using" statements to implementation files (if at
        all). </para>

        <para>For standard namespace keywords (cout, cin, cerr, endl, vector,
        string), You must do "std::cout," etc.</para>
      </section>

      <section id="comments_guidelines">
        <title>Comments</title>

        <para>Comments must tell "why", not "what is happening." At every
        point where you had a choice of what to do, place a comment describing
        which choice you made and why.</para>
      </section>

      <section id="parens_guidelines">
        <title>Parens () with Key Words and Functions Policy</title>

        <para>Do not put parens next to keywords. Put a space between keywords
        and parens. </para>

        <para>Do not use parens in return statements when it is not necessary.
        </para>

        <para>Do put parens next to function names. </para>

        <para>Example: </para>

        <para><code> if ( condition ) while ( condition ) </code></para>

        <para><code> { { </code></para>

        <para><code> ... ... </code></para>

        <para><code> } } </code></para>

        <para><code> strcpy( s, s1 ); return 1;</code></para>
      </section>

      <section id="array_indexing_guidelines">
        <title>Array Indexing</title>

        <para>Single-character variable names can easily be mistaken for
        numbers ("i"s can sometimes look a lot like ones). Make the array
        index stand out with whitespace: </para>

        <para><code> array[ i ] = 0.0; </code></para>

        <para><code> array[ 1 ] = 0.0; </code></para>

        <para><code> array[ 2 ] = 0.0;</code></para>
      </section>
    </chapter>

    <chapter id="building_vesuite">
      <title>Building VE-Suite</title>

      <para>Before attempting to build VE-Suite, be sure to build/install the
      <link linkend="dependencies">dependencies</link> and <link
      linkend="setting_the_environment">set the environment</link>.</para>

      <section id="unix_build_instructions">
        <title>UNIX/Linux Build Instructions</title>

        <para>VE-Suite, as well as its dependencies, is currently being tested
        on a broad range of unix/linux platforms including: IRIX 6.5, SuSE,
        and RedHat Enterprise. </para>

        <para><link linkend="setting_the_environment">Set the environment
        variables</link> and source the setup file included with the VE-Suite
        project: $(VE_SUITE_HOME)/VE_Installer/setup.{.sh,tsh}. Once this file
        has been properly edited type gmake. The unix build system is based on
        Doozer which is included with VR Juggler. </para>

        <para>Supported base configurations available: </para>

        <orderedlist>
          <listitem>
            <para>tao_pf_dbg - OpenGL Performer based application supporting
            released features.</para>
          </listitem>

          <listitem>
            <para>tao_osg_dbg - OpenSceneGraph based application supporting
            released features.</para>
          </listitem>

          <listitem>
            <para>tao_osg_vep_dbg - OpenSceneGraph based application
            supporting released and new features from current research.</para>
          </listitem>
        </orderedlist>

        <para>There are also cluster variants of each of the above
        configurations:</para>

        <orderedlist>
          <listitem>
            <para>tao_pf_cluster_dbg</para>
          </listitem>

          <listitem>
            <para>tao_osg_cluster_dbg</para>
          </listitem>

          <listitem>
            <para>tao_osg_vep_cluster_dbg</para>
          </listitem>
        </orderedlist>

        <para>To change any of the configurations described above, open the
        setup file and set SCENE_GRAPH, CLUSTER_APP, VE_PATENTED
        accordingly.</para>
      </section>

      <section id="windows_build_instructions">
        <title>Windows Build Instructions</title>

        <para>VE_Suite, as well as its dependencies, is currently built and
        tested using Visual Studio 7.1(2003).</para>

        <section id="building_vesuite">
          <title>Building VE-Suite</title>

          <para><link linkend="setting_the_environment">Set the environment
          variables</link> and launch a session of Visual Studio with the
          VE-Suite project loaded, run the batch file: </para>

          <para><code>$(VE_SUITE_HOME)VE_Installerbuild.bat </code></para>

          <para>Supported base configurations available: </para>

          <orderedlist>
            <listitem>
              <para>tao_pf_dbg - OpenGL Performer based application supporting
              released features</para>
            </listitem>

            <listitem>
              <para>tao_osg_dbg - OpenSceneGraph based application supporting
              released features</para>
            </listitem>

            <listitem>
              <para>tao_osg_vep_dbg - OpenSceneGraph based application
              supporting released and new features from current
              research</para>
            </listitem>
          </orderedlist>

          <para>There are also cluster variants of each of the above
          configurations:</para>

          <orderedlist>
            <listitem>
              <para>tao_pf_cluster_dbg</para>
            </listitem>

            <listitem>
              <para>tao_osg_cluster_dbg</para>
            </listitem>

            <listitem>
              <para>tao_osg_vep_cluster_dbg</para>
            </listitem>
          </orderedlist>
        </section>

        <section id="debugging_vexplorer">
          <title>Debugging VE_Xplorer</title>

          <para>To run VE_Xplorer from within the Visual Studio debugger,
          change the working directory in the Configuration Properties tab to
          point to the directory where your VE-Suite parameter file is located
          (for example, change the working directory to
          $(VE_SUITE_HOME)VE_TestSuite). </para>

          <para>You will also need to pass in your VR juggler config files as
          command arguments on the configuration properties tab. With the two
          projects still open, right-click on the VE_Xplorer project file, and
          select properties. For simulation mode, you add the following to
          your command arguments section: </para>

          <para><code>$(VJ_BASE_DIR)sharevrjugglerdataconfigFiles
          sim.base.jconf </code></para>

          <para><code>$(VJ_BASE_DIR)sharevrjugglerdataconfigFiles
          sim.wand.mixin.jconf </code></para>

          <para>After you enter a parameter file name and the scene loads,
          double click on $(VE_SUITE_HOME)bin runWinClient.bat to bring up the
          gui.</para>
        </section>
      </section>
    </chapter>

    <chapter id="dependencies">
      <title>Dependencies</title>

      <para>The following is a list of links for the VE-Suite dependencies .
      Dependencies can be downloaded and built by the user from the following
      links or the pre-compiled binaries can be installed from the download
      page.</para>

      <para>&lt;format&gt;&lt;check dependencies page at
      http://www.vesuite.org/content.php?id=259 for graphics, links, etc. for
      dependencies&gt;</para>

      <section id="building_dependencies_on_windows">
        <title>Building Dependencies on Windows</title>

        <para>It is best to read the specific installation/build instructions
        for each dependency before attempting to build. The information
        provided is for specific details to allow VE-Suite to build/run
        correctly.</para>

        <para>VE_Suite, as well as it's dependencies, is currently built and
        tested using Visual Studio 7.1(2003).</para>

        <para><emphasis role="bold">Notes on installation of
        dependencies</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>TortoiseSVN &lt;link&gt; - Used to check out and update
            VE_Suite from ISU's code repository.</para>
          </listitem>

          <listitem>
            <para>After TortoiseSVN is installed, you can check out the code
            provided you have an account registered with ISU's repository.
            Create a VE_Suite folder. Go to VE_Suite folder and right-mouse
            click, choose "Checkout...". For URL, enter
            https://subversion.vrac.iastate.edu/svn/TSVEG/VE_Suite.
            &lt;link&gt;</para>
          </listitem>

          <listitem>
            <para>Alternately, if you get the VE-Suite source code as a
            compressed tarball, some unzip utilities may not maintain the
            correct directory structure. This can be fixed by unzipping the
            files on a Unix-based system and then moving the files to the
            Windows machine.</para>
          </listitem>

          <listitem>
            <para>While the default locations for installations will work, we
            recommend creating a directory in the root (C:) directory to
            minimize the path lengths and the accompanying potential for typos
            when configuring environment settings.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">vtk-specific notes</emphasis></para>

        <itemizedlist>
          <listitem>
            <para>After downloading the compressed vtk source code and the
            CMake installer, unzip the vtk source to C:VTK-4.4-LatestRelease
            and run the CMake setup program (e.g., CMSetup205.exe) to install
            CMakeSetup.</para>
          </listitem>

          <listitem>
            <para>Go to C:VTK-4.4-LatestRelease. You will have a "VTK" folder
            containing the vtk source code. Create two additional folders:
            "build" and "install". * Run CMakeSetup, and enter
            C:VTK-4.4-LatestReleaseVTK as source code location and
            C:VTK-4.4-LatestReleasebuild as the place to build the binaries.
            Check the box "Show Advanced Values" and press "Configure".</para>
          </listitem>

          <listitem>
            <para>Change some options from their default values:</para>

            <orderedlist>
              <listitem>
                <para>BUILD_SHARED_LIBS to ON</para>
              </listitem>

              <listitem>
                <para>BUILD_TESTING to OFF</para>
              </listitem>

              <listitem>
                <para>CMAKE_INSTALL_PREFIX to
                C:VTK-4.4-LatestReleaseinstall</para>
              </listitem>

              <listitem>
                <para>VTK_USE_HYBRID to ON</para>
              </listitem>

              <listitem>
                <para>VTK_USE_PARALLEL to ON </para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Press "Configure" (possibly need to do it twice), then "OK".
            * Go to C:VTK-4.4-LatestReleasebuild. Double click on "VTK.sln". *
            Left-click on ALL_BUILD, then right-click and select "Build".
            </para>
          </listitem>

          <listitem>
            <para>When the build is finished, go to
            C:VTK-4.4-LatestReleasebuildCMakedebug and move the .dll files up
            one level.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">When building ACE and
        TAO</emphasis></para>

        <para>* You need to create a file called "config.h" in the
        ACE_wrappersace directory, with the line '#include
        "ace/config-win32.h"' in the file. * The workspace file
        ACE_wrappersTAOTAOACE.dsw will need to be converted to solution (.sln)
        files. * ACE_ROOT and TAO_ROOT must be established and ACE_ROOTbin
        placed in your $PATH before building ACE and TAO. This can be done
        using a batch file (.BAT) with these lines: set
        ACE_ROOT=C:ACE_wrappers set TAO_ROOT=%ACE_ROOT%TAO set
        Path=%Path%;%ACE_ROOT%bin "C:Program FilesMicrosoft Visual Studio .NET
        2003Common7IDEdevenv.exe" ./TAOACE.sln &lt;format&gt;</para>

        <para><emphasis role="bold">Other dependency notes</emphasis></para>

        <para>For wxWidgets, load the .dsw file build/msw/wx_dll.dsw and build
        using the DLL Debug configuration. <emphasis
        role="bold">Note:</emphasis> For openGL support change this flag,
        wxUSE_GLCANVAS, to 1 in the file include/wx/msw/setup.h. For Xerces,
        the .sln file is Projects/Win32/VC7.1/xerces-all/xerces-all.sln.
        PLEASE NOTE!! Xerces 2.7 has the Run Time Type Information (RTTI)
        configuration off by default. Therefore, right-click on the XercesLib
        project, select properties-&gt;C/C++-&gt;Language and change the
        "Enable Run-Time Type Info" setting to "Yes(/GR)" Then proceed
        building the solution.</para>
      </section>

      <section id="building_dependencies_on_unix">
        <title>Building Dependencies on UNIX/Linux</title>

        <para>It is best to read the specific installation/build instructions
        for each dependency before attempting to build. The information here
        is provided for specific details to allow VE-Suite to build/run
        correctly.</para>

        <section id="wxwidgets_build_instructions_on_unix">
          <title>wxWidgets Build Instructions on UNIX</title>

          <para>To build wxWidgets on a UNIX style platform, the library must
          be configured before it can be built. This is platform specific. To
          do this first read the INSTALL.txt file in the wxWidgets directory.
          When downloading wxWdigets download the wxGTK package. Note:
          VE-Suite should now build against most distributed versions of
          wxGTK. Also, be sure to have gtk2-devel packages installed on your
          system before trying to build wxGTK.</para>

          <para>To configure wxWidgets properly for a VE-Suite build the
          following options should be specified w/ the configure
          command:</para>

          <para>enable-shared This creates shared libraries enable-log This
          enables logging support within wxWidgets with-opengl This enables
          opengl support within wxWidgets prefix=/myInstallDirectory/wxGTK
          This specifies the install directory &lt;format&gt;</para>

          <para>Following the instructions in INSTALL.txt, configure command
          would be:</para>

          <para>../configure --enable-shared --with-opengl --enable-log
          --prefix=/ &lt;format&gt;</para>

          <para>This will setup wx properly for building with VE-Suite. When
          the configuration is complete, type:</para>

          <para>gmake &lt;format&gt;</para>

          <para>After the build finishes type:</para>

          <para>gmake install &lt;format&gt;</para>

          <para>This will install the libraries and includes in the directory
          specified by --prefix option.</para>
        </section>

        <section id="ace_tao_build_instructions_on_unix">
          <title>ACE/TAO Build Instructions on UNIX</title>

          <para>Download the lastest beta release of ACE+TAO. With this
          particular version of ACE+TAO it is possible to use configure. To
          build ACE+TAO create a build dir (e.g. build-linux-rhel3). Then:
          &gt; cd &lt;build-dir&gt; &gt; ../configure --prefix=&lt;location
          where ace+tao will be installed&gt; &gt; gmake &gt; gmake install
          &lt;format&gt; This will create an dir with the appropriate include,
          lib, and bin dir for ACE+TAO.</para>
        </section>

        <section id="osg_buid_instructions_on_unix">
          <title>OpenSceneGraph Build Instructions on UNIX</title>

          <para>For OpenSceneGraph download the latest release version.
          OpenSceneGraph is dependent on Producer and OpenThreads. Producer is
          dependent on OpenThreads, therefore OpenThreads must be built first.
          To build OpenThreads, go into the OpenThreads directory. The
          following environment variables should be set either on the command
          line (or through a setup script):</para>

          <para>OSG_HOME ==&gt; the location of the OpenSceneGraph directory
          OPENTHREADS_INC_DIR ==&gt; the location of OpenThreads/include
          OPENTHREADS_LIB_DIR ==&gt; the location of OpenThreads/lib
          PRODUCER_INC_DIR ==&gt; the location of Producer/include
          PRODUCER_LIB_DIR ==&gt; the location of Producer/lib INST_LOCATION
          ==&gt; this is where to install the libraries. &lt;format&gt;</para>

          <para>These will all be specific to where you downloaded and
          extracted each dependency directory. To set these environment
          variables from the command line type something like: &gt;setenv
          OSG_HOME /home/users/myaccount/ve_depends/OSG/OpenSceneGraph
          &lt;format&gt;</para>

          <para>After setting the environment variables are set, go into the
          OpenThreads directory and type:</para>

          <para>&gt;make or &gt;gmake &lt;format&gt;</para>

          <para>This will compile OpenThreads. Once it is built, install the
          libraries using: &gt; make
          INST_LOCATION=/home/myInstallDirectory/OSG install
          &lt;format&gt;</para>

          <para>Where /home/myInstallDirectory is the desired directory to
          create the install. Next go into the Producer directory: &gt;cd
          Producer &gt;gmake &gt;gmake
          INST_LOCATION=/home/myInstallDirectory/OSG install
          &lt;format&gt;</para>

          <para>And finally: &gt;cd OpenSceneGraph &gt;gmake &gt;gmake
          INST_LOCATION=/home/myInstallDirectory/OSG install &lt;format&gt;
          Check to see that libraries and headers are created in INST_LOCATION
          properly.</para>
        </section>

        <section id="vtk_build_instructions_on_unix_cmake">
          <title>Visualization Toolkit (VTK) Build Instructions on UNIX (CMAKE
          Settings)</title>

          <para>To build vtk, CMake must be used to set the following values.
          To best utilize CMake it is suggested that ccmake be used. To begin,
          create a build dir in the VTK directory (e.g. build-linux-rhel3).
          Then do the following: &gt; cd &lt;build dir&gt; &gt; ccmake ../.
          &gt; gmake &gt; gmake install &lt;format&gt;</para>

          <para>Please change these default settings for your CMake build
          setup: 1. CMAKE_INSTALL_DIR to &lt;location where vtk is to be
          installed&gt; 2. BUILD_SHARED_LIBS to ON 3. BUILD_TESTING to OFF 4.
          VTK_USE_HYBRID to ON 5. VTK_USE_PARALLEL to ON &lt;format&gt;</para>

          <para><emphasis role="bold">NOTE: </emphasis>Be sure that vtk is
          using the proper gl drivers as well.</para>
        </section>
      </section>

      <section id="vesuite_component_dependencies">
        <title>VE-Suite Component Dependencies</title>

        <para>If you are installing individual components of VE-Suite on
        different desktops, it is only necessary to install the dependencies
        for that specific component. Below is a table listing the individual
        components and its specific dependencies.</para>

        <para>Name Service: ACE/TAO, xerces-c</para>

        <para>VE-Conductor (GUI): ACE/TAO, xerces-c, wxWidgets</para>

        <para>VE-Xplorer: ACE/TAO, OpenSceneGraph* or Performer*, VTK,
        VRJuggler &lt;format&gt;</para>

        <para>*depends on the desired scenegraph management</para>
      </section>
    </chapter>

    <chapter id="setting_the_environment">
      <title>Setting the Environment</title>

      <para>To specify the build/run environment, perform a one-time edit of
      the environment variables that are defined in the setup file, setup.bat
      on Windows and setup.tsh/setup.sh on UNIX/Linux platforms. If the paths
      of your environment variables contain spaces, you need to put the
      directory containing the spaces in quotation marks.</para>

      <para>Example: set VTK_HOME=C:"Documents and Settings"userDesktopvtk
      &lt;format&gt;</para>

      <para><emphasis role="bold">Important variables for UNIX/Linux platforms
      only:</emphasis> SCENE_GRAPH Set to PF or OSG to define which scene
      graph to build for VE-Xplorer. TAO_BUILD Always set to TRUE. In the
      future this flag can be used to support other CORBA ORBs as well.
      CLUSTER_APP Set to TRUE if VE-Xplorer will be used on a graphics
      cluster. &lt;format&gt;</para>

      <para><emphasis role="bold">Important variables include:</emphasis>
      VE_SUITE_HOME The location of the top level VE_Suite directory.
      VJ_BASE_DIR The location of VR Juggler. VJ_DEPS_DIR The location of VR
      Juggler dependencies. VTK_HOME Visualization ToolKit (VTK) directory.
      WX_HOME The wxWidgets install. XERCESCROOT The location of the xerces
      build. WX_ROOT The location of wxWidgets install (should be same as
      WX_HOME). OSGHOME The location of OpenSceneGraph (if OSG version is
      built). ACE_HOME The location of the ACE_wrappers directory. TAO_HOME
      TAO location within ACE/TAO. &lt;format&gt;</para>
    </chapter>

    <chapter id="description_of_the_engines">
      <title>Description of the Engines</title>

      <para>VE-Suite is composed of three main software engines that
      coordinate the flow of data from the engineer to the virtual components
      being designed. The following sections will detail the design of each of
      these engines and describe how they contribute to the overall framework
      functionality.</para>

      <para>&lt;img&gt; (from Clearwater paper)</para>

      <section id="gui_veconductor">
        <title>Graphical User Interface (VE-Conductor)</title>

        <para>To achieve the goals outlined for the project, a powerful and
        flexible user interface (UI) was implemented. Key features of the
        VE-Suite two-dimensional UI (VE-Conductor) are described in the
        following sections.</para>

        <section id="conductor_multiplatform_support">
          <title>Multi-Platform Support</title>

          <para>The UI makes use of platform independent libraries to enable
          the software to run on a wide range of computer hardware and
          operating systems. These platforms range from Unix workstations to
          Pocket PCs and PDAs. This functionality is ideal for the virtual
          engineering-based system since users will frequently make use of
          handheld computing devices inside of immersive environments (e.g.,
          cave-like systems at ISU-VRAC and NETL).</para>

          <para>After reviewing a number of different UI libraries, WxWidgets
          (www.wxwidgets.org) was chosen. WxWidgets is one of the best
          cross-platform GUI packages available. It is well-maintained, has a
          large user base, and has ports for Windows, Unix/X11, Unix/Motif,
          OS2, Mac, and GTK. It also has an alpha version of a Windows CE
          port, which is under active development. This ensures that the user
          interface will run on all major platforms and even on Pocket
          PC-based PDAs.</para>
        </section>

        <section id="conductor_detachable_location_transparency">
          <title>Detachable/Location Transparency</title>

          <para>The UI exists independently from the computational engine as a
          separate CORBA component. This functionality allows the UI to be
          attached and detached from an active simulation from any compatible
          computer on the network. As an example, this would allow a user to
          build and start a simulation and then detach from the computational
          engine. The user could then go to a different location, re-attach to
          the simulation, and regain monitoring and control functions.</para>

          <para>To accomplish this functionality a CORBA IDL interface between
          the UI and the computational engine (See Figure 1) was defined. This
          CORBA interface provides all the necessary communication mechanisms
          between these components. The communication link is bidirectional
          and handles items such as model parameters passed to the
          computational engine and receives items such as execution status and
          results from the computational engine.</para>

          <para>Another advantage of this design is the ability for multiple
          UIs to be attached to the same computational engine, allowing
          multiple users to monitor a simulation from different locations. A
          locking mechanism is used so that only one UI (controller) can
          change the design and inputs of the simulation. The UI also has the
          ability to connect to the graphical environment and control what
          graphical representations are shown for high fidelity data (i.e.,
          contour planes, vector planes, streamlines, iso-surfaces) or for low
          fidelity data (i.e., gauges showing scalar information about plant
          performance, costing data, or emissions data).</para>
        </section>

        <section id="conductor_extensibility">
          <title>Extensibility</title>

          <para>Another important consideration for the UI design is
          extensibility. The UI is able to dynamically discover, identify, and
          load UI elements for new component models. This capability keeps the
          level of difficulty involved in integrating new component models to
          a minimum since it eliminates the need for modifications to the core
          interface when new models are added.</para>

          <para>The dynamic discover and load capability is accomplished by
          loading user developed module UIs from dynamic link libraries (DLL
          in Windows) or shared libraries (SO lib in Linux/Unix). A plug-in
          C++ base class defining this UI-module interface is provided to all
          module developers. Developers can inherit from this class to create
          their own module UIs and then compile the resulting code into a
          DLL/shared library. The UI frameworkâ€™s plug loader code will
          recognize the new module and bring that into its user-module
          library. By this mechanism, the core UI can plug in the third-party
          module-specific UI directly from binaries.</para>
        </section>

        <section id="conductor_unified_control">
          <title>Unified Control</title>

          <para>Another feature of the UI is unified control for all user
          interaction. This ensures that the user is not burdened with moving
          between different UIs to perform operations. There is a single UI
          with the ability to: 1) construct, specify, execute and monitor
          simulations; and 2) provide complete control of the
          three-dimensional virtual environment.</para>

          <para>To provide this functionality, the UI is designed to
          communicate via CORBA to not only the computational engine, but also
          to the graphical engine (see Figure 1). As was discussed for the
          UI-to-computational engine link, the use of CORBA with an
          appropriate IDL provides a flexible, detachable, and platform
          independent communication mechanism for this link as well.</para>

          <para>The following figure shows the two-dimensional GUI. A list of
          available modules is maintained in a tree structure on the left side
          of the window, while the main canvas area shows the current
          simulation network.</para>

          <para>&lt;img&gt; (from Clearwater paper)</para>
        </section>
      </section>

      <section id="computational_engine_vece">
        <title>Computational Engine (VE-CE)</title>

        <para>The computational engine (VE-CE) is the core of the framework.
        Its duties are to construct, coordinate, schedule, and monitor plant
        simulation runs. It is capable of running a simulation containing a
        multitude of different types of models, each accepting and generating
        a myriad of data types. The computational engine is able to analyze a
        plant configuration, determine execution order, marshal system
        resources to create model instances, and coordinate the flow of data
        through the simulation framework. Tasks that require specific
        knowledge about a data type or model are relegated to either a
        detachable UI or to a specific model, thus keeping the computational
        engine generalized at a high level.</para>

        <para>Important functions that the computational engine controls can
        be broken down into several pieces for explanation: plant
        configuration, data handling, error handling, relationship to
        detachable UI, scheduling, and relationship to models. Each of these
        is described in detail in the following sections.</para>

        <section id="vece_plant_configuration">
          <title>Plant Configuration</title>

          <para>The configuration of the plant, provided by a detachable UI,
          is the primary data structure used by the computational engine.
          Nearly all algorithms utilized, such as proper data flow,
          scheduling, and resource allocation depend on this topology.</para>
        </section>

        <section id="vece_data_handling">
          <title>Data Handling</title>

          <para>Since there is an unlimited number of possible models capable
          of being integrated into the framework (with each model having a
          different input/output set), the computational engine operates with
          generalized datatypes. To address this requirement, we have designed
          the CORBA IDL interfaces between the computational engine and the
          component models to use mapped string blocks in combination with
          common dimensions of array data.</para>
        </section>

        <section id="vece_error_handling">
          <title>Error Handling</title>

          <para>With the computational engine being the centralized
          intelligence behind a simulation run, all errors that occur while
          performing this task (whether originating within its own structure
          or on an attached model) must be properly handled within the context
          of this overriding structure. Thus, the computational engine has
          sophisticated error handling routines and messaging facilities to
          alert attached users. To fit into the detached UI paradigm, any
          errors that occur on an attached UI are handled locally.</para>
        </section>

        <section id="vece_relationship_to_detachable_ui">
          <title>Relationship to Detachable UI</title>

          <para>The computational engine is a CORBA server into which a
          detachable UI client can connect. This detachable UI is where the
          user is able to create a plant configuration, set model inputs,
          start and stop execution of simulation, and view simulation results.
          Once a client-server connection is made, the engine is able to send
          results, messages, updates, and communications from other attached
          UIs in real time. The computational engine does not require a
          connection to a UI during a simulation run. Users can
          connect/disconnect at will to configure, modify, or monitor the
          simulation of a given plant configuration.</para>
        </section>

        <section id="vece_scheduling">
          <title>Scheduling</title>

          <para>The computational engine makes use of advanced scheduling
          algorithms. The scheduler, at minimum, will be capable of handling
          single and embedded feedback loops, iterative solves and,
          eventually, transient simulation runs.</para>
        </section>

        <section id="vece_relationship_to_models">
          <title>Relationship to Models</title>

          <para>The computational engine, with its CORBA interface, is able to
          connect to the various component models available for a simulation.
          Information passed through this connection includes inputs (user
          supplied and stream data), outputs, results, and general messages.
          The importance of the CORBA interface being used for this purpose is
          discussed in detail in the Model Integration section below.</para>
        </section>
      </section>

      <section id="graphical_engine_vexplorer">
        <title>Graphical Engine (VE-Xplorer)</title>

        <para>The graphical engine (VE-Xplorer) provides the core
        functionality for the virtual engineering aspect of the framework.
        VE-Xplorer enables the engineering analysis and design process to take
        place in a virtual environment. For maximum graphical performance on
        multiple operating systems, it is built upon VRJuggler&lt;link&gt;,
        OpenGL Performer&lt;link&gt;, and Kitwareâ€™s Visualization ToolKit
        &lt;link&gt;. This visual interface, controlled by the UI and the
        computational engine, is a graphical representation of the simulation
        under review. Figure 3 shows the immersive interface capabilities of
        the graphical engine.</para>

        <para>The graphical engine is generalized to load data not only from
        comprehensive models, but also from other engineering sources,
        including results generated from the CMU Vision 21 planner software
        and other generalized datasets (e.g., experimental data from a test
        rig). The engine is also being modified to make use of the high level
        CORBA interface specifications used throughout the software framework.
        This interface allows the visualization engine to communicate directly
        with the component models, computational engine, and UI. To
        communicate with the graphical engine there is an external socket
        connection that is made between individual component models and the
        respective graphical objects (described below). This connection allows
        large high fidelity datasets to be transferred to the graphical
        environment without interrupting the overall communication
        network.</para>

        <para>The graphical engine is also designed to allow graphics objects
        to be added to the virtual environment just like the objects are added
        in the GUI. This allows the graphical environment to be a direct
        representation of the system being designed by the engineer. In much
        the same way that the GUI auto-discovers the plug-ins for use by the
        engineer, the graphical engine also dynamically discovers plug-ins.
        Unlike the GUI, the graphical engine is controlled by the network
        string that is created by the GUI. This represents a significant
        capability since the graphical engine has no a priori knowledge of the
        system under interrogation.</para>

        <para>&lt;img&gt; (get from Clearwater paper)</para>
      </section>
    </chapter>

    <chapter id="software_development_documents">
      <title>Software Development Documents</title>

      <para></para>
    </chapter>

    <chapter id="software_development_tools">
      <title>Software Development Tools</title>

      <para>subversion</para>

      <para>svn tortoise</para>

      <para>trac</para>

      <para>bugzilla</para>

      <para>phpBB</para>

      <para>docbook</para>

      <para>visual studio</para>

      <para>gnu tools</para>

      <para>ddd</para>

      <para>DialogBlocks</para>

      <para>Valgrind</para>

      <para>openGL debuggers</para>

      <para>py2exe</para>

      <para>freeze</para>

      <para>inno setup</para>

      <para>rpm</para>

      <para>dmg builder</para>

      <para>&lt;format&gt;</para>

      <para>&lt;note: Check capitalization. Also, should these be linked to
      anything? Docbook will have a readme file eventually, but what about the
      rest?&gt;</para>
    </chapter>
  </part>
</book>