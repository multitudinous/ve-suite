// Name: VirtualPaint Demo
//
// Authors:
//   Chris 'Xenon' Hanson, AlphaPixel.
//   John Enright, Digital Transforms.
//
// Origination Date: June 21, 2011

// Configurable options
//#define SHOW_MODEL
//#define SHOW_RTT

// Platform includes
#ifdef WIN32
#include <windows.h>
// prevent stupid Windows macros
#undef min
#undef max
#endif // WIN32

#include "Types.h"

// STL includes
#include <string>
#include <iostream>
#include <sstream>

// OSG includes
#include <osg/Texture2D>
#include <osg/Geometry>
#include <osg/Image>
#include <osg/CameraNode>
#include <osgDB/ReadFile>
#include <osgDB/FileUtils>
#include <osgViewer/Viewer>
#include <osgViewer/ViewerEventHandlers>
#include <osg/MatrixTransform>
#include <osgGA/TrackballManipulator>
#include <osgGA/StateSetManipulator>
#include <osg/Depth>
#include <osg/PositionAttitudeTransform>

#include <osg/Program>
#include <osg/Shader>
#include <osg/Uniform>

#include "SoundSystem.h"
#include "PaintGun.h"
#include "Lesson.h"
#include "GunInputAdapterKeyboard.h"
#include "GunInputAdapterMouse.h"
#include "HUD.h"
#include "InputHandler.h"
#include "MainScene.h"
#include "Shadersupport.h"
#include "Utilities.h"
#include "RTTScene.h"

// pick this up from RTTScene for now
extern osg::ref_ptr<osg::Texture2D> RTTtex;


// a convenience so don't have to prefix STL stuff with "std::".
using namespace std;
// ditto osg
using namespace osg;


// --------------------------------------------------------------------------

SoundSystem g_SoundSystem;
Lesson gLesson;

// ************************************************************************** 

int main(int argc, char** argv)
{
// for extensive debugging:
//osg::setNotifyLevel(osg::DEBUG_FP);

    const int numScreens(getNumScreens());

// create a viewer for the data.
   osgViewer::Viewer viewer;
   viewer.setUpViewOnSingleScreen(numScreens - 1); // setup on highest-numbered screen

   // add the state manipulator (W and T keys)
   viewer.addEventHandler(new osgGA::StateSetManipulator(viewer.getCamera()->getOrCreateStateSet()));
   // add the window size toggle handler (F key)
   viewer.addEventHandler(new osgViewer::WindowSizeHandler);
   // add the stats handler (S key)
   viewer.addEventHandler(new osgViewer::StatsHandler);
   // manually add trackball
/*
   osg::ref_ptr<osgGA::TrackballManipulator> trackBall = new osgGA::TrackballManipulator();
   if (trackBall.valid())
   {
	   viewer.setCameraManipulator(trackBall.get());
	   trackBall->home(0.0);
   }
*/

   // the paint gun object.
   osg::ref_ptr<PaintGun> paintGun = new PaintGun;
   if (paintGun.valid() == false)
      {
		osg::notify(osg::WARN) << "Insufficient memory for PaintGun object." << endl;
      return 20;
      }
   // create and install a keyboard handler for the gun.
   osg::ref_ptr<GunInputAdapterKeyboard> giaKey = new GunInputAdapterKeyboard(paintGun.get());
   if (giaKey.valid())
      viewer.addEventHandler(giaKey.get());
   // create and install a mouse handler for the gun.
   osg::ref_ptr<GunInputAdapterMouse> giaMouse = new GunInputAdapterMouse(paintGun.get());
   if (giaMouse.valid())
      viewer.addEventHandler(giaMouse.get());
   // create and install the input handler for application global things.
   osg::ref_ptr<InputHandler> inHdl = new InputHandler();
   if (inHdl.valid())
	   viewer.addEventHandler(inHdl.get());

   // cause the viewer to create its working windows and environment.
   viewer.realize();

   osg::ref_ptr<osg::Node> bgQuad = BuildBackground();
   if (bgQuad.valid() == false)
      {
		osg::notify(osg::WARN) << "BuildBackground() failed. Check missing image file(s)." << endl;
      return 25;
      }

   // remove the normal mouse cursor from the screen when this app is active / has the input focus.
   // also, record window dimensions for use in sizing mouse pointer reticle
   osgViewer::Viewer::Windows windows;
   viewer.getWindows(windows);
   int x = 0, y = 0; 
   int width = 0, height = 0; 
   for (osgViewer::Viewer::Windows::iterator itr = windows.begin(); itr != windows.end(); itr++)
   {
#ifndef SHOW_RTT
	   (*itr)->setCursor(osgViewer::GraphicsWindow::NoCursor);
#endif // !SHOW_RTT
	   (*itr)->getWindowRectangle(x, y, width, height);
   }

   // load a custom mouse pointer. Note that in the real application, the mouse position is controlled
   // by a gun pointed at the screen. The gun simulates a real paint gun.
   osg::ref_ptr<osg::Node> mouse = LoadMousePointer("images/Reticle.png", 0.03f * ((float)height / (float)width), 0.03f);
   if (mouse.valid() == false)
      {
		osg::notify(osg::WARN) << "LoadMousePointer() failed. Check missing image file(s)." << endl;
      return 30;
      }
#ifdef SHOW_MODEL
   osg::ref_ptr<osg::Node> surface = LoadPaintSurface();
   if (surface.valid() == false)
      {
		osg::notify(osg::WARN) << "LoadPaintSurface() failed. Check missing model(s)." << endl;
      return 35;
      }
#endif
   osg::ref_ptr<osg::Node> hud = BuildHud(gLesson, *paintGun);
   if (hud.valid() == false)
      {
		osg::notify(osg::WARN) << "BuildHud() failed." << endl;
      return 40;
      }
   osg::ref_ptr<osg::Group> root = new osg::Group;
   if (root.valid() == false)
      return 45;


#ifndef SHOW_RTT
   osg::ref_ptr<osg::Node> preRenderGraph;
   preRenderGraph = createPreRenderGraph(width, height);
   if (preRenderGraph.valid() == false)
      {
		osg::notify(osg::WARN) << "Unable to create accumulation prerender graph." << endl;
	   return 50;
      }
   // add preRenderGraph to main scene root
   root->addChild(preRenderGraph.get());
#endif // !SHOW_RTT

   // assign RTT texture as layer #1 for both the quad and the model
#ifndef SHOW_RTT
   bgQuad->getOrCreateStateSet()->setTextureAttributeAndModes(TEXUNIT_ACCUM, RTTtex.get());
#endif // !SHOW_RTT
#ifdef SHOW_MODEL
	surface->getOrCreateStateSet()->setTextureAttributeAndModes(TEXUNIT_ACCUM, RTTtex.get());
#endif
	// assign shaders to the bgQuad
#ifdef SHOW_MODEL
	setupShaders(bgQuad, surface);
#else // !SHOW_MODEL
	setupShaders(bgQuad.get(), NULL);
#endif // !SHOW_MODEL
   root->addChild(bgQuad.get());
#ifdef SHOW_MODEL
   root->addChild(surface);
#endif
   root->addChild(hud.get());
   root->addChild(mouse.get());

   viewer.setSceneData(root.get());
   // test prerender subgraph
#ifdef SHOW_RTT
   viewer.setSceneData(createPreRenderSubGraph());
   configureCameraReferenceFrame(viewer.getCamera());
#endif
   // enter the render & display frame loop.
   while (!viewer.done())
		{
		viewer.frame();
      // update the HUD if the gun or lesson paramaters changed.
      if (paintGun->IsChanged() || gLesson.IsChanged())
         UpdateHud(gLesson, *paintGun);
      // clear the gun changed status every frame after everything that uses it has finished.
      paintGun->ClearChanged();
		} 
   return(0);
} // main
