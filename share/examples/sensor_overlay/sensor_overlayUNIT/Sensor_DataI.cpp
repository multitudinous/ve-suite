// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// ../../../TAO/TAO_IDL/be/be_codegen.cpp:1198

#include "Sensor_DataI.h"
#include <vector>


// Implementation skeleton constructor
Sensor_Data_i::Sensor_Data_i (void)
{
}

// Implementation skeleton destructor
Sensor_Data_i::~Sensor_Data_i (void)
{
}

::CORBA::Short Sensor_Data_i::setup_files (
										   const char * node_name)
{
	
	
	//creates file with a header line declaring the sensor node the data comes from
	std::string file_path;
	//file_path="/Volumes/adams/temperature_data/";
	file_path="./";
	file_path.append(node_name);
	
	std::ofstream data;
	data.open(file_path.c_str());
	data<<"Sensor Node:\t"<<node_name<<std::endl;
	data<<"DAQBox,Channel,Temperature,Time"<<std::endl;
	//data<<"\n"<<std::endl;
	data.close();
	return 0;
}

::CORBA::Short Sensor_Data_i::write_temperature_to_file (
														 const char * node_name,
														 ::CORBA::Short DAQBox,
														 ::CORBA::Short channel,
														 ::CORBA::Double temperature,
														 ::CORBA::Double time)
{
	ACE_Thread_Mutex _mutex;
	_mutex.acquire();
	
	std::string file_path;
	//file_path="/Volumes/adams/temperature_data/";
	file_path="./";
	file_path.append(node_name);
	
	std::ofstream data;
	data.open(file_path.c_str(), std::ios::app);
	data<<node_name<<","<<DAQBox<<","<<channel<<","<<std::setprecision(6)<<temperature<<","<<std::setprecision(11)<<time<<std::endl;
	data.close();
	_mutex.release();
	return 0;
	
}

::CORBA::Double Sensor_Data_i::send_temperature (
												 const char * node_name,
												 ::CORBA::Short DAQBox,
												 ::CORBA::Short channel,
												 ::CORBA::Double temperature,
												 ::CORBA::Double time)
{
	std::cout << "Temperature from: \t" << node_name <<"\t"<<DAQBox<<"\t"<<channel<<"\t"<<std::setprecision(6)<< temperature <<"\t"<<std::setprecision(11)<<time<< std::endl;
	return 0;
}

void Sensor_Data_i::createPLPLOT (
								  const char * node_name,
								  ::CORBA::Short channel,
								  ::CORBA::Short numberOfChannels)
{
	ACE_Thread_Mutex _mutex;
	_mutex.acquire();
	
	/* //uncomment to have user interaction
	 std::string pathToData;
	 std::cout<<"Please enter the path to the data file you wish to read (donot cut and paste!!!)"<<std::endl;
	 std::cin>>pathToData;
	 std::string sensorNode;
	 std::cout<<"Please enter the name of the file you want to plot"<<std::endl;
	 std::cin>>sensorNode;
	 
	 int hoursToPlot, numberOfSensors, sensorChannelToPlot;
	 std::cout<<"How many hours should the plot contain?"<<std::endl;
	 std::cin>>hoursToPlot;
	 std::cout<<"How many sensor channels are in your data?"<<std::endl;
	 std::cin>>numberOfSensors;
	 std::cout<<"What channel would you like to plot?"<<std::endl;
	 std::cin>>sensorChannelToPlot;
	 
	 */
	
	
	
	
	// uncomment to use command line
	
	//set the path to the data to be read
	std::string pathToData;
	pathToData="./";
	std::cout<<pathToData<<std::endl;
	
	//set what sensor node is requesting a plot
	std::string sensorNode;
	sensorNode=node_name;
	std::cout<<sensorNode<<std::endl;
	
	int numberOfSensors, sensorChannelToPlot;
	float hoursToPlot;
	
	//set the number of hours to plot
	hoursToPlot=(float)5/60; //plot 5 minutes of data
	std::cout<<hoursToPlot<<std::endl;
	
	//number of sensor channels that are in the data.  Must be set correctly for readData to work properly.
	numberOfSensors=numberOfChannels;
	std::cout<<numberOfSensors<<std::endl;
	
	
	
	
	//set the channel that you want to plot.
	sensorChannelToPlot=channel;
	std::cout<<sensorChannelToPlot<<std::endl;
	
	
	
	
	std::string plotFileName;
	
	
	//setup the plot filename and location
	plotFileName=pathToData;
	plotFileName.append(sensorNode);
	plotFileName.append(".png");
	
	//location to the data to be read.
	std::string dataRead;
	dataRead=pathToData;
	dataRead.append(sensorNode);
	
	
	
	readData(dataRead);  //read the data
	
	
	//used to be in pngClass::plot
	
	plstream pls;
	int i, npts, startIndex, endIndex;
	PLFLT xmin, xmax, ymin, ymax;
	PLFLT tstart;
	
	plsdev("png");
	
	plsfnam(plotFileName.c_str());
	
	plinit();
	
	plsesc('@');
	
	npts = hoursToPlot*60/(float)(15.0/60.0); //number of data points.  data is sampled every 15 seconds
	endIndex=dataTime.size()-1;
	std::cout<<"endIndex before check\t"<<endIndex<<std::endl;
	if(npts > dataTime.size())
	{
		npts=dataTime.size()-1;
		startIndex=0;
		std::cout<<"data time size"<<dataTime.size()<<std::endl;
		std::cout<<"dataTime has less than num pts requested"<<std::endl;
	}
	else
	{
		startIndex=endIndex-npts;
	}
	std::cout<<"numpoints"<<npts<<std::endl;
	std::cout<<"startIndex\t"<<startIndex<<"endIndex\t"<<endIndex<<std::endl;
	
	//some work needs done to make sure tstart does not try to reference data out of range.  If your
	//data does not have atleast the amount of time requested in it the vector references out of range.  fix this!
	//int timeEnd=dataTime.size()-1; //data location
	//std::cout<<"timeEnd\t"<<timeEnd<<std::endl;
	
	
	
	
	tstart=dataTime[startIndex]-5*3600;  //correct back to CDT
	std::cout<<"start time\t"<<tstart<<std::endl;
	
	PLFLT x[365], y[365];
	PLFLT xerr1[365], xerr2[365], yerr1[365], yerr2[365];
	
	xmin = (PLFLT)tstart;
	//xmax = xmin + npts*60.0*5.0;
	xmax = (PLFLT)dataTime[endIndex]-5*3600;
	ymin = 290-273.15;
	ymax = 310-273.15;
	
	int iteration=0;
	
	if (npts==numberOfSensors)
	{
		std::cout<<"I need more than 1 data point to plot"<<std::endl;
	}
	else
	{
		
		for (i = 0; i<npts/numberOfSensors; i++) 
		{
			
			
			/*	if (iteration==0)
			 {
			 //x[i] = dataTime[timeEnd-npts*numberOfSensors-numberOfSensors-1-sensorChannelToPlot]-6*3600;
			 //y[i] = temperature[timeEnd-npts*numberOfSensors-numberOfSensors-1-sensorChannelToPlot]-273.15;
			 x[i] = dataTime[endIndex-npts*(numberOfSensors-1) + sensorChannelToPlot]-6*3600;
			 y[i] = temperature[endIndex-npts*(numberOfSensors-1) + sensorChannelToPlot]-273.15;
			 std::cout<<std::setw(10)<<std::setprecision(10)<<std::fixed<<x[i]<<"\t"<<y[i]<<std::endl;
			 }*/
			//else{
			//x[i] = dataTime[timeEnd-npts*numberOfSensors+i*numberOfSensors-numberOfSensors-1-sensorChannelToPlot]-6*3600;
			//y[i] = temperature[timeEnd-npts*numberOfSensors+i*numberOfSensors-numberOfSensors-1-sensorChannelToPlot]-273.15;
			x[i] = dataTime[endIndex-npts*(numberOfSensors-1) + sensorChannelToPlot+ i*numberOfSensors]-5*3600;
			y[i] = temperature[endIndex-npts*(numberOfSensors-1) + sensorChannelToPlot+i*numberOfSensors]-273.15;
			
			std::cout<<x[i]<<"\t"<<y[i]<<std::endl;
			//	}
			iteration ++;
		}
	}
	
	pladv(0);
	
	plvsta();
	
	plwind(xmin-10, xmax+10, ymin, ymax);
	
	
	
	plcol0(2); //line color for box.
	
	// Set time format to be ISO 8601 standard YYYY-MM-HH. Note that this is
	// equivalent to %f for C99 compliant implementations of strftime.
	//pls->timefmt("%H-%M-%S");
	pltimefmt("%H.%M.%S");
	
	// Draw a box with ticks spaced every 5 minutes X and 1 hour in Y.
	//pls->box("bcnstd", hoursToPlot*60*60/5,1, "bcnstv", 1, 4);
	plbox("bcnstd",1/15,4, "bcnstv", 1, 4);
	
	plcol0(2);  //axis color
	
	pllab("Time(Hour, Minute, Second)", "Temperature (C)", sensorNode.c_str());
	
	plcol0(15);  //plotted line color
	
	// Rescale symbol size (used by plpoin) by 0.5
	plssym(0.0,0.5);
	
	plpoin(npts, x, y, 2);
	
	plline(npts, x, y);
	
	plend1();  //If you don't have this call you get a segfault.  PLPLOT has a problem releasing the stream.
	
	
	deleteVectors();
	
	_mutex.release();
	return;
}


void Sensor_Data_i::readData(std::string readfilepathandname)
{
	
	
	std::ifstream inFile(readfilepathandname.c_str(), std::ios::in);
	
	
	if(!inFile)
	{
		std::cerr<<"File was not opened"<<std::endl;
		exit(1);
	}
	
	std::cout<<"Reading File:\t"<<readfilepathandname<<std::endl;
	
	std::string tempNode, tempDaq, tempChannel, tempTemperature, tempTime;
	
	while (! inFile.eof())
	{
		
		getline(inFile, tempNode, ',');
		node.push_back(tempNode);
		//std::cout<<tempNode;
		
		getline(inFile, tempDaq, ',');
		daq.push_back(atoi(tempDaq.c_str()));
		//std::cout<<tempDaq;
		
		getline(inFile, tempChannel, ',');
		channel.push_back(atoi(tempChannel.c_str()));
		//std::cout<<tempChannel;
		
		getline(inFile, tempTemperature, ',');
		temperature.push_back(atof(tempTemperature.c_str()));
		//std::cout<<tempTemperature;
		
		getline(inFile, tempTime, '\n');
		dataTime.push_back(atof(tempTime.c_str()));
		//std::cout<<tempTime<<std::endl;
		
	}
	
	inFile.close();
	
	
	
	
}
void Sensor_Data_i::deleteVectors()
{
	node.clear();
	daq.clear();
	channel.clear();
	temperature.clear();
	dataTime.clear();
	
}
